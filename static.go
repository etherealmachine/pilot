package main
var static = map[string]string{"static/components/app.html": "<link rel=\"import\" href=\"/static/components/index.html\">\n<link rel=\"import\" href=\"/static/components/play.html\">\n<link rel=\"import\" href=\"/static/components/tv.html\">\n<dom-module id=\"pilot-main\">\n\n  <script src=\"/static/deps/page.js\"></script>\n\n  <template>\n    <pilot-index\n      style$=\"{{curr(page, 'index')}}\">\n    </pilot-index>\n    <pilot-play\n      style$=\"{{curr(page, 'play')}}\"\n      video=\"{{page.params.video}}\">\n    </pilot-play>\n    <pilot-tv\n      style$=\"{{curr(page, 'tv')}}\">\n    </pilot-tv>\n  </template>\n\n  <script>\n    Polymer({\n      is: 'pilot-main',\n      ready: function() {\n        this.page = null;\n        page('/', this.index.bind(this));\n        page('/tv', this.tv.bind(this));\n        page('/play/:video(.*)', this.play.bind(this));\n        page.base('/#!');\n        page();\n      },\n      index: function(ctx, next) {\n        this.set('page', {\n          name: 'index'\n        });\n      },\n      play: function(ctx, next) {\n        this.set('page', {\n          name: 'play',\n          params: {\n            video: ctx.params.video\n          }\n        });\n      },\n      tv: function(ctx, next) {\n        this.set('page', {\n          name: 'tv'\n        });\n      },\n      curr: function(page, name) {\n        if (page && page.name == name) {\n          return '';\n        }\n        return 'display: none';\n      }\n    });\n  </script>\n\n</dom-module>",
"static/deps/api.js": "var api = api || {};\n\n(function(api) {\n\nfunction call(method, req, callback) {\n  $.ajax({\n    url: \"/rpc\",\n    dataType: \"json\",\n    data: JSON.stringify({\n      method: method,\n      params: [req],\n      id: 1\n    }),\n    contentType: 'application/json',\n    timeout: 5000,\n    type: 'POST',\n    success: function(data, status, XHR) {\n      if (data.result) {\n        callback(data.result);\n      } else if (data.error) {\n        console.log(data.error);\n      }\n    },\n    error: function(jqXHR, textStatus, errorThrown) {\n      console.log(errorThrown);\n    }\n  });\n}\n\napi.Call = function(method, req, callback) {\n\tcall('Pilot.' + method, req, callback);\n};\n\n})(api);",
"static/deps/jquery.min.js": "/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */\n!function(a,b){\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\"jQuery requires a window with a document\");return b(a)}:b(a)}(\"undefined\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m=\"2.1.4\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,p=/^-ms-/,q=/-([\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\"\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\"boolean\"==typeof g&&(j=g,g=arguments[h]||{},h++),\"object\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:\"jQuery\"+(m+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\"function\"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return\"object\"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,\"isPrototypeOf\")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+\"\":\"object\"==typeof a||\"function\"==typeof a?h[i.call(a)]||\"object\":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf(\"use strict\")?(b=l.createElement(\"script\"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,\"ms-\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?\"\":(a+\"\").replace(o,\"\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\"string\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\"string\"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"),function(a,b){h[\"[object \"+b+\"]\"]=b.toLowerCase()});function s(a){var b=\"length\"in a&&a.length,c=n.type(a);return\"function\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\"array\"===c||0===b||\"number\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=\"sizzle\"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K=\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",L=\"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",M=\"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",N=M.replace(\"w\",\"w#\"),O=\"\\\\[\"+L+\"*(\"+M+\")(?:\"+L+\"*([*^$|!~]?=)\"+L+\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\"+N+\"))|)\"+L+\"*\\\\]\",P=\":(\"+M+\")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\"+O+\")*)|.*)\\\\)|)\",Q=new RegExp(L+\"+\",\"g\"),R=new RegExp(\"^\"+L+\"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\"+L+\"+$\",\"g\"),S=new RegExp(\"^\"+L+\"*,\"+L+\"*\"),T=new RegExp(\"^\"+L+\"*([>+~]|\"+L+\")\"+L+\"*\"),U=new RegExp(\"=\"+L+\"*([^\\\\]'\\\"]*?)\"+L+\"*\\\\]\",\"g\"),V=new RegExp(P),W=new RegExp(\"^\"+N+\"$\"),X={ID:new RegExp(\"^#(\"+M+\")\"),CLASS:new RegExp(\"^\\\\.(\"+M+\")\"),TAG:new RegExp(\"^(\"+M.replace(\"w\",\"w*\")+\")\"),ATTR:new RegExp(\"^\"+O),PSEUDO:new RegExp(\"^\"+P),CHILD:new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\"+L+\"*(even|odd|(([+-]|)(\\\\d*)n|)\"+L+\"*(?:([+-]|)\"+L+\"*(\\\\d+)|))\"+L+\"*\\\\)|)\",\"i\"),bool:new RegExp(\"^(?:\"+K+\")$\",\"i\"),needsContext:new RegExp(\"^\"+L+\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\"+L+\"*((?:-\\\\d)?\\\\d*)\"+L+\"*\\\\)|)(?=[^-]|$)\",\"i\")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\\d$/i,$=/^[^{]+\\{\\s*\\[native \\w/,_=/^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,aa=/[+~]/,ba=/'|\\\\/g,ca=new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\"+L+\"?|(\"+L+\")|.)\",\"ig\"),da=function(a,b,c){var d=\"0x\"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,\"string\"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&\"object\"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute(\"id\"))?s=r.replace(ba,\"\\\\$&\"):b.setAttribute(\"id\",s),s=\"[id='\"+s+\"'] \",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(\",\")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute(\"id\")}}}return i(a.replace(R,\"$1\"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+\" \")>d.cacheLength&&delete b[a.shift()],b[c+\" \"]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement(\"div\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split(\"|\"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return\"input\"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return(\"input\"===c||\"button\"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&\"undefined\"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?\"HTML\"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener(\"unload\",ea,!1):e.attachEvent&&e.attachEvent(\"onunload\",ea)),p=!f(g),c.attributes=ja(function(a){return a.className=\"i\",!a.getAttribute(\"className\")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment(\"\")),!a.getElementsByTagName(\"*\").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(\"undefined\"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute(\"id\")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c=\"undefined\"!=typeof a.getAttributeNode&&a.getAttributeNode(\"id\");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return\"undefined\"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\"*\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML=\"<a id='\"+u+\"'></a><select id='\"+u+\"-\\f]' msallowcapture=''><option selected=''></option></select>\",a.querySelectorAll(\"[msallowcapture^='']\").length&&q.push(\"[*^$]=\"+L+\"*(?:''|\\\"\\\")\"),a.querySelectorAll(\"[selected]\").length||q.push(\"\\\\[\"+L+\"*(?:value|\"+K+\")\"),a.querySelectorAll(\"[id~=\"+u+\"-]\").length||q.push(\"~=\"),a.querySelectorAll(\":checked\").length||q.push(\":checked\"),a.querySelectorAll(\"a#\"+u+\"+*\").length||q.push(\".#.+[+~]\")}),ja(function(a){var b=g.createElement(\"input\");b.setAttribute(\"type\",\"hidden\"),a.appendChild(b).setAttribute(\"name\",\"D\"),a.querySelectorAll(\"[name=d]\").length&&q.push(\"name\"+L+\"*[*^$|!~]?=\"),a.querySelectorAll(\":enabled\").length||q.push(\":enabled\",\":disabled\"),a.querySelectorAll(\"*,:x\"),q.push(\",.*:\")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,\"div\"),s.call(a,\"[s!='']:x\"),r.push(\"!=\",P)}),q=q.length&&new RegExp(q.join(\"|\")),r=r.length&&new RegExp(r.join(\"|\")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,\"='$1']\"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error(\"Syntax error, unrecognized expression: \"+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c=\"\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\"string\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{\">\":{dir:\"parentNode\",first:!0},\" \":{dir:\"parentNode\"},\"+\":{dir:\"previousSibling\",first:!0},\"~\":{dir:\"previousSibling\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||\"\").replace(ca,da),\"~=\"===a[2]&&(a[3]=\" \"+a[3]+\" \"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\"nth\"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\"even\"===a[3]||\"odd\"===a[3])),a[5]=+(a[7]+a[8]||\"odd\"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||\"\":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(\")\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return\"*\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+\" \"];return b||(b=new RegExp(\"(^|\"+L+\")\"+a+\"(\"+L+\"|$)\"))&&y(a,function(a){return b.test(\"string\"==typeof a.className&&a.className||\"undefined\"!=typeof a.getAttribute&&a.getAttribute(\"class\")||\"\")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?\"!=\"===b:b?(e+=\"\",\"=\"===b?e===c:\"!=\"===b?e!==c:\"^=\"===b?c&&0===e.indexOf(c):\"*=\"===b?c&&e.indexOf(c)>-1:\"$=\"===b?c&&e.slice(-c.length)===c:\"~=\"===b?(\" \"+e.replace(Q,\" \")+\" \").indexOf(c)>-1:\"|=\"===b?e===c||e.slice(0,c.length+1)===c+\"-\":!1):!0}},CHILD:function(a,b,c,d,e){var f=\"nth\"!==a.slice(0,3),g=\"last\"!==a.slice(-4),h=\"of-type\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\"nextSibling\":\"previousSibling\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p=\"only\"===a&&!o&&\"nextSibling\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error(\"unsupported pseudo: \"+a);return e[u]?e(b):e.length>1?(c=[a,a,\"\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,\"$1\"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||\"\")||ga.error(\"unsupported lang: \"+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute(\"xml:lang\")||b.getAttribute(\"lang\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\"-\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&!!a.checked||\"option\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\"input\"===b&&\"button\"===a.type||\"button\"===b},text:function(a){var b;return\"input\"===a.nodeName.toLowerCase()&&\"text\"===a.type&&(null==(b=a.getAttribute(\"type\"))||\"text\"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+\" \"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R,\" \")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d=\"\";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&\"parentNode\"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||\"*\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[\" \"],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:\" \"===a[i-2].type?\"*\":\"\"})).replace(R,\"$1\"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q=\"0\",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG(\"*\",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+\" \"];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n=\"function\"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&\"ID\"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split(\"\").sort(B).join(\"\")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement(\"div\"))}),ja(function(a){return a.innerHTML=\"<a href='#'></a>\",\"#\"===a.firstChild.getAttribute(\"href\")})||ka(\"type|href|height|width\",function(a,b,c){return c?void 0:a.getAttribute(b,\"type\"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML=\"<input/>\",a.firstChild.setAttribute(\"value\",\"\"),\"\"===a.firstChild.getAttribute(\"value\")})||ka(\"value\",function(a,b,c){return c||\"input\"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute(\"disabled\")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[\":\"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,w=/^.[^:#\\[\\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if(\"string\"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=\":not(\"+a+\")\"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if(\"string\"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+\" \"+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,\"string\"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if(\"string\"==typeof a){if(c=\"<\"===a[0]&&\">\"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?\"undefined\"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||\"string\"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?\"string\"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,\"parentNode\")},parentsUntil:function(a,b,c){return n.dir(a,\"parentNode\",c)},next:function(a){return D(a,\"nextSibling\")},prev:function(a){return D(a,\"previousSibling\")},nextAll:function(a){return n.dir(a,\"nextSibling\")},prevAll:function(a){return n.dir(a,\"previousSibling\")},nextUntil:function(a,b,c){return n.dir(a,\"nextSibling\",c)},prevUntil:function(a,b,c){return n.dir(a,\"previousSibling\",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return\"Until\"!==a.slice(-5)&&(d=c),d&&\"string\"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a=\"string\"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);\"function\"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&\"string\"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[[\"resolve\",\"done\",n.Callbacks(\"once memory\"),\"resolved\"],[\"reject\",\"fail\",n.Callbacks(\"once memory\"),\"rejected\"],[\"notify\",\"progress\",n.Callbacks(\"memory\")]],c=\"pending\",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+\"With\"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+\"With\"](this===e?d:this,arguments),this},e[f[0]+\"With\"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler(\"ready\"),n(l).off(\"ready\"))))}});function I(){l.removeEventListener(\"DOMContentLoaded\",I,!1),a.removeEventListener(\"load\",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),\"complete\"===l.readyState?setTimeout(n.ready):(l.addEventListener(\"DOMContentLoaded\",I,!1),a.addEventListener(\"load\",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\"object\"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if(\"string\"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&\"string\"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d=\"data-\"+b.replace(O,\"-$1\").toLowerCase(),c=a.getAttribute(d),\"string\"==typeof c){try{c=\"true\"===c?!0:\"false\"===c?!1:\"null\"===c?null:+c+\"\"===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){\nreturn M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,\"hasDataAttrs\"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf(\"data-\")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,\"hasDataAttrs\",!0)}return e}return\"object\"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf(\"-\")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||\"fx\")+\"queue\",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||\"fx\";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};\"inprogress\"===e&&(e=c.shift(),d--),e&&(\"fx\"===b&&c.unshift(\"inprogress\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\"queueHooks\";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks(\"once memory\").add(function(){L.remove(a,[b+\"queue\",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return\"string\"!=typeof a&&(b=a,a=\"fx\",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),\"fx\"===a&&\"inprogress\"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\"fx\",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\"string\"!=typeof a&&(b=a,a=void 0),a=a||\"fx\";while(g--)c=L.get(f[g],a+\"queueHooks\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,R=[\"Top\",\"Right\",\"Bottom\",\"Left\"],S=function(a,b){return a=b||a,\"none\"===n.css(a,\"display\")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement(\"div\")),c=l.createElement(\"input\");c.setAttribute(\"type\",\"radio\"),c.setAttribute(\"checked\",\"checked\"),c.setAttribute(\"name\",\"t\"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML=\"<textarea>x</textarea>\",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U=\"undefined\";k.focusinBubbles=\"onfocusin\"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(\".\")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||\"\").match(E)||[\"\"],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||\"\").split(\".\").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp(\"(^|\\\\.)\"+p.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&(\"**\"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,\"events\"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,\"type\")?b.type:b,r=j.call(b,\"namespace\")?b.namespace.split(\".\"):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(\".\")>=0&&(r=q.split(\".\"),q=r.shift(),r.sort()),k=q.indexOf(\":\")<0&&\"on\"+q,b=b[n.expando]?b:new n.Event(q,\"object\"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join(\".\"),b.namespace_re=b.namespace?new RegExp(\"(^|\\\\.)\"+r.join(\"\\\\.(?:.*\\\\.|)\")+\"(\\\\.|$)\"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,\"events\")||{})[b.type]&&L.get(g,\"handle\"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,\"events\")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||\"click\"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||\"click\"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+\" \",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),fixHooks:{},keyHooks:{props:\"char charCode key keyCode\".split(\" \"),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:\"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:\"focusin\"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:\"focusout\"},click:{trigger:function(){return\"checkbox\"===this.type&&this.click&&n.nodeName(this,\"input\")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,\"a\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:\"mouseover\",mouseleave:\"mouseout\",pointerenter:\"pointerover\",pointerleave:\"pointerout\"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:\"focusin\",blur:\"focusout\"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if(\"object\"==typeof a){\"string\"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&(\"string\"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+\".\"+d.namespace:d.origType,d.selector,d.handler),this;if(\"object\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||\"function\"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,ba=/<([\\w:]+)/,ca=/<|&#?\\w+;/,da=/<(?:script|style|link)/i,ea=/checked\\s*(?:[^=]|=\\s*.checked.)/i,fa=/^$|\\/(?:java|ecma)script/i,ga=/^true\\/(.*)/,ha=/^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,ia={option:[1,\"<select multiple='multiple'>\",\"</select>\"],thead:[1,\"<table>\",\"</table>\"],col:[2,\"<table><colgroup>\",\"</colgroup></table>\"],tr:[2,\"<table><tbody>\",\"</tbody></table>\"],td:[3,\"<table><tbody><tr>\",\"</tr></tbody></table>\"],_default:[0,\"\",\"\"]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,\"table\")&&n.nodeName(11!==b.nodeType?b:b.firstChild,\"tr\")?a.getElementsByTagName(\"tbody\")[0]||a.appendChild(a.ownerDocument.createElement(\"tbody\")):a}function ka(a){return a.type=(null!==a.getAttribute(\"type\"))+\"/\"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\"type\"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],\"globalEval\",!b||L.get(b[c],\"globalEval\"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||\"*\"):a.querySelectorAll?a.querySelectorAll(b||\"*\"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();\"input\"===c&&T.test(a.type)?b.checked=a.checked:(\"input\"===c||\"textarea\"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,\"script\"),g.length>0&&ma(g,!i&&oa(a,\"script\")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if(\"object\"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement(\"div\")),g=(ba.exec(e)||[\"\",\"\"])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,\"<$1></$2>\")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=\"\"}else l.push(b.createTextNode(e));k.textContent=\"\",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),\"script\"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||\"\")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,\"script\")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent=\"\");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if(\"string\"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||[\"\",\"\"])[1].toLowerCase()]){a=a.replace(aa,\"<$1></$2>\");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&\"string\"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,\"script\"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,\"script\"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||\"\")&&!L.access(h,\"globalEval\")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,\"\")))}return this}}),n.each({appendTo:\"append\",prependTo:\"prepend\",insertBefore:\"before\",insertAfter:\"after\",replaceAll:\"replaceWith\"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],\"display\");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),\"none\"!==c&&c||(qa=(qa||n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp(\"^(\"+Q+\")(?!px)[a-z%]+$\",\"i\"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(\"\"!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+\"\":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement(\"div\"),f=l.createElement(\"div\");if(f.style){f.style.backgroundClip=\"content-box\",f.cloneNode(!0).style.backgroundClip=\"\",k.clearCloneStyle=\"content-box\"===f.style.backgroundClip,e.style.cssText=\"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute\",e.appendChild(f);function g(){f.style.cssText=\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute\",f.innerHTML=\"\",d.appendChild(e);var g=a.getComputedStyle(f,null);b=\"1%\"!==g.top,c=\"4px\"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement(\"div\"));return c.style.cssText=f.style.cssText=\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\",c.style.marginRight=c.style.width=\"0\",f.style.width=\"1px\",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp(\"^(\"+Q+\")(.*)$\",\"i\"),Ba=new RegExp(\"^([+-])=(\"+Q+\")\",\"i\"),Ca={position:\"absolute\",visibility:\"hidden\",display:\"block\"},Da={letterSpacing:\"0\",fontWeight:\"400\"},Ea=[\"Webkit\",\"O\",\"Moz\",\"ms\"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||\"px\"):b}function Ha(a,b,c,d,e){for(var f=c===(d?\"border\":\"content\")?4:\"width\"===b?1:0,g=0;4>f;f+=2)\"margin\"===c&&(g+=n.css(a,c+R[f],!0,e)),d?(\"content\"===c&&(g-=n.css(a,\"padding\"+R[f],!0,e)),\"margin\"!==c&&(g-=n.css(a,\"border\"+R[f]+\"Width\",!0,e))):(g+=n.css(a,\"padding\"+R[f],!0,e),\"padding\"!==c&&(g+=n.css(a,\"border\"+R[f]+\"Width\",!0,e)));return g}function Ia(a,b,c){var d=!0,e=\"width\"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g=\"border-box\"===n.css(a,\"boxSizing\",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?\"border\":\"content\"),d,f)+\"px\"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,\"olddisplay\"),c=d.style.display,b?(f[g]||\"none\"!==c||(d.style.display=\"\"),\"\"===d.style.display&&S(d)&&(f[g]=L.access(d,\"olddisplay\",ta(d.nodeName)))):(e=S(d),\"none\"===c&&e||L.set(d,\"olddisplay\",e?c:n.css(d,\"display\"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&\"none\"!==d.style.display&&\"\"!==d.style.display||(d.style.display=b?f[g]||\"\":\"none\"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,\"opacity\");return\"\"===c?\"1\":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\"float\":\"cssFloat\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&\"get\"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,\"string\"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f=\"number\"),null!=c&&c===c&&(\"number\"!==f||n.cssNumber[h]||(c+=\"px\"),k.clearCloneStyle||\"\"!==c||0!==b.indexOf(\"background\")||(i[b]=\"inherit\"),g&&\"set\"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&\"get\"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),\"normal\"===e&&b in Da&&(e=Da[b]),\"\"===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each([\"height\",\"width\"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,\"display\"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,\"border-box\"===n.css(a,\"boxSizing\",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:\"inline-block\"},xa,[a,\"marginRight\"]):void 0}),n.each({margin:\"\",padding:\"\",border:\"Width\"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\"string\"==typeof c?c.split(\" \"):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return\"boolean\"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||\"swing\",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?\"\":\"px\")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,\"\"),b&&\"auto\"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp(\"^(?:([+-])=|)(\"+Q+\")([a-z%]*)$\",\"i\"),Pa=/queueHooks$/,Qa=[Va],Ra={\"*\":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?\"\":\"px\"),g=(n.cssNumber[a]||\"px\"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||\".5\",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e[\"margin\"+c]=e[\"padding\"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra[\"*\"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,\"fxshow\");c.queue||(h=n._queueHooks(a,\"fx\"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,\"fx\").length||h.empty.fire()})})),1===a.nodeType&&(\"height\"in b||\"width\"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,\"display\"),k=\"none\"===j?L.get(a,\"olddisplay\")||ta(a.nodeName):j,\"inline\"===k&&\"none\"===n.css(a,\"float\")&&(o.display=\"inline-block\")),c.overflow&&(o.overflow=\"hidden\",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||\"toggle\"===e,e===(p?\"hide\":\"show\")){if(\"show\"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))\"inline\"===(\"none\"===j?ta(a.nodeName):j)&&(o.display=j);else{q?\"hidden\"in q&&(p=q.hidden):q=L.access(a,\"fxshow\",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,\"fxshow\");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start=\"width\"===d||\"height\"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&\"expand\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=[\"*\"]):a=a.split(\" \");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&\"object\"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:\"number\"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue=\"fx\"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css(\"opacity\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,\"finish\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\"string\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\"fx\",[]),this.each(function(){var b=!0,e=null!=a&&a+\"queueHooks\",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\"fx\"),this.each(function(){var b,c=L.get(this),d=c[a+\"queue\"],e=c[a+\"queueHooks\"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each([\"toggle\",\"show\",\"hide\"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||\"boolean\"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta(\"show\"),slideUp:Ta(\"hide\"),slideToggle:Ta(\"toggle\"),fadeIn:{opacity:\"show\"},fadeOut:{opacity:\"hide\"},fadeToggle:{opacity:\"toggle\"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||\"fx\",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement(\"input\"),b=l.createElement(\"select\"),c=b.appendChild(l.createElement(\"option\"));a.type=\"checkbox\",k.checkOn=\"\"!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement(\"input\"),a.value=\"t\",a.type=\"radio\",k.radioValue=\"t\"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),\nvoid 0===c?d&&\"get\"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&\"set\"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+\"\"),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&\"radio\"===b&&n.nodeName(a,\"input\")){var c=a.value;return a.setAttribute(\"type\",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{\"for\":\"htmlFor\",\"class\":\"className\"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&\"set\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\"get\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute(\"tabindex\")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each([\"tabIndex\",\"readOnly\",\"maxLength\",\"cellSpacing\",\"cellPadding\",\"rowSpan\",\"colSpan\",\"useMap\",\"frameBorder\",\"contentEditable\"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\\t\\r\\n\\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\" \")){f=0;while(e=b[f++])d.indexOf(\" \"+e+\" \")<0&&(d+=e+\" \");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||\"string\"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||\"\").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(\" \"+c.className+\" \").replace(ab,\" \"):\"\")){f=0;while(e=b[f++])while(d.indexOf(\" \"+e+\" \")>=0)d=d.replace(\" \"+e+\" \",\" \");g=a?n.trim(d):\"\",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return\"boolean\"==typeof b&&\"string\"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if(\"string\"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||\"boolean\"===c)&&(this.className&&L.set(this,\"__className__\",this.className),this.className=this.className||a===!1?\"\":L.get(this,\"__className__\")||\"\")})},hasClass:function(a){for(var b=\" \"+a+\" \",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(\" \"+this[c].className+\" \").replace(ab,\" \").indexOf(b)>=0)return!0;return!1}});var bb=/\\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e=\"\":\"number\"==typeof e?e+=\"\":n.isArray(e)&&(e=n.map(e,function(a){return null==a?\"\":a+\"\"})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&\"set\"in b&&void 0!==b.set(this,e,\"value\")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&\"get\"in b&&void 0!==(c=b.get(e,\"value\"))?c:(c=e.value,\"string\"==typeof c?c.replace(bb,\"\"):null==c?\"\":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,\"value\");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f=\"select-one\"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute(\"disabled\"))||c.parentNode.disabled&&n.nodeName(c.parentNode,\"optgroup\"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each([\"radio\",\"checkbox\"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute(\"value\")?\"on\":a.value})}),n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\"**\"):this.off(b,a||\"**\",c)}});var cb=n.now(),db=/\\?/;n.parseJSON=function(a){return JSON.parse(a+\"\")},n.parseXML=function(a){var b,c;if(!a||\"string\"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,\"text/xml\")}catch(d){b=void 0}return(!b||b.getElementsByTagName(\"parsererror\").length)&&n.error(\"Invalid XML: \"+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \\t]*([^\\r\\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\\/\\//,kb=/^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,lb={},mb={},nb=\"*/\".concat(\"*\"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){\"string\"!=typeof b&&(c=b,b=\"*\");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])\"+\"===d[0]?(d=d.slice(1)||\"*\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return\"string\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\"*\"]&&g(\"*\")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\"*\"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader(\"Content-Type\"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+\" \"+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\"*\"===f)f=i;else if(\"*\"!==i&&i!==f){if(g=j[i+\" \"+f]||j[\"* \"+f],!g)for(e in j)if(h=e.split(\" \"),h[1]===f&&(g=j[i+\" \"+h[0]]||j[\"* \"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\"throws\"])b=g(b);else try{b=g(b)}catch(l){return{state:\"parsererror\",error:g?l:\"No conversion from \"+i+\" to \"+f}}}return{state:\"success\",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:\"GET\",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",accepts:{\"*\":nb,text:\"text/plain\",html:\"text/html\",xml:\"application/xml, text/xml\",json:\"application/json, text/javascript\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\"responseXML\",text:\"responseText\",json:\"responseJSON\"},converters:{\"* text\":String,\"text html\":!0,\"text json\":n.parseJSON,\"text xml\":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){\"object\"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks(\"once memory\"),q=k.statusCode||{},r={},s={},t=0,u=\"canceled\",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+\"\").replace(eb,\"\").replace(jb,pb[1]+\"//\"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||\"*\").toLowerCase().match(E)||[\"\"],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||(\"http:\"===h[1]?\"80\":\"443\"))===(pb[3]||(\"http:\"===pb[1]?\"80\":\"443\")))),k.data&&k.processData&&\"string\"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger(\"ajaxStart\"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?\"&\":\"?\")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,\"$1_=\"+cb++):d+(db.test(d)?\"&\":\"?\")+\"_=\"+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader(\"If-Modified-Since\",n.lastModified[d]),n.etag[d]&&v.setRequestHeader(\"If-None-Match\",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader(\"Content-Type\",k.contentType),v.setRequestHeader(\"Accept\",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+(\"*\"!==k.dataTypes[0]?\", \"+nb+\"; q=0.01\":\"\"):k.accepts[\"*\"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u=\"abort\";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger(\"ajaxSend\",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort(\"timeout\")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,\"No Transport\");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||\"\",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader(\"Last-Modified\"),w&&(n.lastModified[d]=w),w=v.getResponseHeader(\"etag\"),w&&(n.etag[d]=w)),204===a||\"HEAD\"===k.type?x=\"nocontent\":304===a?x=\"notmodified\":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x=\"error\",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+\"\",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?\"ajaxSuccess\":\"ajaxError\",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger(\"ajaxComplete\",[v,k]),--n.active||n.event.trigger(\"ajaxStop\")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,\"json\")},getScript:function(a,b){return n.get(a,void 0,b,\"script\")}}),n.each([\"get\",\"post\"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:\"GET\",dataType:\"script\",async:!1,global:!1,\"throws\":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,\"body\")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\\[\\]$/,xb=/\\r?\\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+\"[\"+(\"object\"==typeof e?b:\"\")+\"]\",e,c,d)});else if(c||\"object\"!==n.type(b))d(a,b);else for(e in b)Ab(a+\"[\"+e+\"]\",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?\"\":b,d[d.length]=encodeURIComponent(a)+\"=\"+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join(\"&\").replace(vb,\"+\")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,\"elements\");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(\":disabled\")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,\"\\r\\n\")}}):{name:b.name,value:c.replace(xb,\"\\r\\n\")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent(\"onunload\",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&\"withCredentials\"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c[\"X-Requested-With\"]||(c[\"X-Requested-With\"]=\"XMLHttpRequest\");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,\"abort\"===a?f.abort():\"error\"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,\"string\"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b(\"error\"),b=Cb[g]=b(\"abort\");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"},contents:{script:/(?:java|ecma)script/},converters:{\"text script\":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter(\"script\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\"GET\")}),n.ajaxTransport(\"script\",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n(\"<script>\").prop({async:!0,charset:a.scriptCharset,src:a.url}).on(\"load error\",c=function(a){b.remove(),c=null,a&&e(\"error\"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({jsonp:\"callback\",jsonpCallback:function(){var a=Fb.pop()||n.expando+\"_\"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter(\"json jsonp\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?\"url\":\"string\"==typeof b.data&&!(b.contentType||\"\").indexOf(\"application/x-www-form-urlencoded\")&&Gb.test(b.data)&&\"data\");return h||\"jsonp\"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,\"$1\"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?\"&\":\"?\")+b.jsonp+\"=\"+e),b.converters[\"script json\"]=function(){return g||n.error(e+\" was not called\"),g[0]},b.dataTypes[0]=\"json\",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),\"script\"):void 0}),n.parseHTML=function(a,b,c){if(!a||\"string\"!=typeof a)return null;\"boolean\"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if(\"string\"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(\" \");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&\"object\"==typeof b&&(e=\"POST\"),g.length>0&&n.ajax({url:a,type:e,dataType:\"html\",data:b}).done(function(a){f=arguments,g.html(d?n(\"<div>\").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each([\"ajaxStart\",\"ajaxStop\",\"ajaxComplete\",\"ajaxError\",\"ajaxSuccess\",\"ajaxSend\"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,\"position\"),l=n(a),m={};\"static\"===k&&(a.style.position=\"relative\"),h=l.offset(),f=n.css(a,\"top\"),i=n.css(a,\"left\"),j=(\"absolute\"===k||\"fixed\"===k)&&(f+i).indexOf(\"auto\")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\"using\"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return\"fixed\"===n.css(c,\"position\")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],\"html\")||(d=a.offset()),d.top+=n.css(a[0],\"borderTopWidth\",!0),d.left+=n.css(a[0],\"borderLeftWidth\",!0)),{top:b.top-d.top-n.css(c,\"marginTop\",!0),left:b.left-d.left-n.css(c,\"marginLeft\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,\"html\")&&\"static\"===n.css(a,\"position\"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:\"pageXOffset\",scrollTop:\"pageYOffset\"},function(b,c){var d=\"pageYOffset\"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each([\"top\",\"left\"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+\"px\":c):void 0})}),n.each({Height:\"height\",Width:\"width\"},function(a,b){n.each({padding:\"inner\"+a,content:b,\"\":\"outer\"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||\"boolean\"!=typeof d),g=c||(d===!0||e===!0?\"margin\":\"border\");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement[\"client\"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body[\"scroll\"+a],e[\"scroll\"+a],b.body[\"offset\"+a],e[\"offset\"+a],e[\"client\"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,\"function\"==typeof define&&define.amd&&define(\"jquery\",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});\n//# sourceMappingURL=jquery.min.map",
"static/deps/polymer-micro.html": "<!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><script>(function () {\nfunction resolve() {\ndocument.body.removeAttribute('unresolved');\n}\nif (window.WebComponents) {\naddEventListener('WebComponentsReady', resolve);\n} else {\nif (document.readyState === 'interactive' || document.readyState === 'complete') {\nresolve();\n} else {\naddEventListener('DOMContentLoaded', resolve);\n}\n}\n}());\nwindow.Polymer = {\nSettings: function () {\nvar user = window.Polymer || {};\nlocation.search.slice(1).split('&').forEach(function (o) {\no = o.split('=');\no[0] && (user[o[0]] = o[1] || true);\n});\nvar wantShadow = user.dom === 'shadow';\nvar hasShadow = Boolean(Element.prototype.createShadowRoot);\nvar nativeShadow = hasShadow && !window.ShadowDOMPolyfill;\nvar useShadow = wantShadow && hasShadow;\nvar hasNativeImports = Boolean('import' in document.createElement('link'));\nvar useNativeImports = hasNativeImports;\nvar useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;\nreturn {\nwantShadow: wantShadow,\nhasShadow: hasShadow,\nnativeShadow: nativeShadow,\nuseShadow: useShadow,\nuseNativeShadow: useShadow && nativeShadow,\nuseNativeImports: useNativeImports,\nuseNativeCustomElements: useNativeCustomElements\n};\n}()\n};\n(function () {\nvar userPolymer = window.Polymer;\nwindow.Polymer = function (prototype) {\nif (typeof prototype === 'function') {\nprototype = prototype.prototype;\n}\nif (!prototype) {\nprototype = {};\n}\nvar factory = desugar(prototype);\nprototype = factory.prototype;\nvar options = { prototype: prototype };\nif (prototype.extends) {\noptions.extends = prototype.extends;\n}\nPolymer.telemetry._registrate(prototype);\ndocument.registerElement(prototype.is, options);\nreturn factory;\n};\nvar desugar = function (prototype) {\nvar base = Polymer.Base;\nif (prototype.extends) {\nbase = Polymer.Base._getExtendedPrototype(prototype.extends);\n}\nprototype = Polymer.Base.chainObject(prototype, base);\nprototype.registerCallback();\nreturn prototype.constructor;\n};\nwindow.Polymer = Polymer;\nif (userPolymer) {\nfor (var i in userPolymer) {\nPolymer[i] = userPolymer[i];\n}\n}\nPolymer.Class = desugar;\n}());\nPolymer.telemetry = {\nregistrations: [],\n_regLog: function (prototype) {\nconsole.log('[' + prototype.is + ']: registered');\n},\n_registrate: function (prototype) {\nthis.registrations.push(prototype);\nPolymer.log && this._regLog(prototype);\n},\ndumpRegistrations: function () {\nthis.registrations.forEach(this._regLog);\n}\n};\nObject.defineProperty(window, 'currentImport', {\nenumerable: true,\nconfigurable: true,\nget: function () {\nreturn (document._currentScript || document.currentScript).ownerDocument;\n}\n});\nPolymer.RenderStatus = {\n_ready: false,\n_callbacks: [],\nwhenReady: function (cb) {\nif (this._ready) {\ncb();\n} else {\nthis._callbacks.push(cb);\n}\n},\n_makeReady: function () {\nthis._ready = true;\nthis._callbacks.forEach(function (cb) {\ncb();\n});\nthis._callbacks = [];\n},\n_catchFirstRender: function () {\nrequestAnimationFrame(function () {\nPolymer.RenderStatus._makeReady();\n});\n}\n};\nif (window.HTMLImports) {\nHTMLImports.whenReady(function () {\nPolymer.RenderStatus._catchFirstRender();\n});\n} else {\nPolymer.RenderStatus._catchFirstRender();\n}\nPolymer.ImportStatus = Polymer.RenderStatus;\nPolymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;\nPolymer.Base = {\n__isPolymerInstance__: true,\n_addFeature: function (feature) {\nthis.extend(this, feature);\n},\nregisterCallback: function () {\nthis._desugarBehaviors();\nthis._doBehavior('beforeRegister');\nthis._registerFeatures();\nthis._doBehavior('registered');\n},\ncreatedCallback: function () {\nPolymer.telemetry.instanceCount++;\nthis.root = this;\nthis._doBehavior('created');\nthis._initFeatures();\n},\nattachedCallback: function () {\nPolymer.RenderStatus.whenReady(function () {\nthis.isAttached = true;\nthis._doBehavior('attached');\n}.bind(this));\n},\ndetachedCallback: function () {\nthis.isAttached = false;\nthis._doBehavior('detached');\n},\nattributeChangedCallback: function (name) {\nthis._attributeChangedImpl(name);\nthis._doBehavior('attributeChanged', arguments);\n},\n_attributeChangedImpl: function (name) {\nthis._setAttributeToProperty(this, name);\n},\nextend: function (prototype, api) {\nif (prototype && api) {\nObject.getOwnPropertyNames(api).forEach(function (n) {\nthis.copyOwnProperty(n, api, prototype);\n}, this);\n}\nreturn prototype || api;\n},\nmixin: function (target, source) {\nfor (var i in source) {\ntarget[i] = source[i];\n}\nreturn target;\n},\ncopyOwnProperty: function (name, source, target) {\nvar pd = Object.getOwnPropertyDescriptor(source, name);\nif (pd) {\nObject.defineProperty(target, name, pd);\n}\n},\n_log: console.log.apply.bind(console.log, console),\n_warn: console.warn.apply.bind(console.warn, console),\n_error: console.error.apply.bind(console.error, console),\n_logf: function () {\nreturn this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));\n}\n};\nPolymer.Base._logPrefix = function () {\nvar color = window.chrome || /firefox/i.test(navigator.userAgent);\nreturn color ? [\n'%c[%s::%s]:',\n'font-weight: bold; background-color:#EEEE00;'\n] : ['[%s::%s]:'];\n}();\nPolymer.Base.chainObject = function (object, inherited) {\nif (object && inherited && object !== inherited) {\nif (!Object.__proto__) {\nobject = Polymer.Base.extend(Object.create(inherited), object);\n}\nobject.__proto__ = inherited;\n}\nreturn object;\n};\nPolymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);\nif (window.CustomElements) {\nPolymer.instanceof = CustomElements.instanceof;\n} else {\nPolymer.instanceof = function (obj, ctor) {\nreturn obj instanceof ctor;\n};\n}\nPolymer.isInstance = function (obj) {\nreturn Boolean(obj && obj.__isPolymerInstance__);\n};\nPolymer.telemetry.instanceCount = 0;\n(function () {\nvar modules = {};\nvar lcModules = {};\nvar findModule = function (id) {\nreturn modules[id] || lcModules[id.toLowerCase()];\n};\nvar DomModule = function () {\nreturn document.createElement('dom-module');\n};\nDomModule.prototype = Object.create(HTMLElement.prototype);\nPolymer.Base.extend(DomModule.prototype, {\nconstructor: DomModule,\ncreatedCallback: function () {\nthis.register();\n},\nregister: function (id) {\nvar id = id || this.id || this.getAttribute('name') || this.getAttribute('is');\nif (id) {\nthis.id = id;\nmodules[id] = this;\nlcModules[id.toLowerCase()] = this;\n}\n},\nimport: function (id, selector) {\nif (id) {\nvar m = findModule(id);\nif (!m) {\nforceDocumentUpgrade();\nm = findModule(id);\n}\nif (m && selector) {\nm = m.querySelector(selector);\n}\nreturn m;\n}\n}\n});\nvar cePolyfill = window.CustomElements && !CustomElements.useNative;\ndocument.registerElement('dom-module', DomModule);\nfunction forceDocumentUpgrade() {\nif (cePolyfill) {\nvar script = document._currentScript || document.currentScript;\nvar doc = script && script.ownerDocument;\nif (doc) {\nCustomElements.upgradeAll(doc);\n}\n}\n}\n}());\nPolymer.Base._addFeature({\n_prepIs: function () {\nif (!this.is) {\nvar module = (document._currentScript || document.currentScript).parentNode;\nif (module.localName === 'dom-module') {\nvar id = module.id || module.getAttribute('name') || module.getAttribute('is');\nthis.is = id;\n}\n}\nif (this.is) {\nthis.is = this.is.toLowerCase();\n}\n}\n});\nPolymer.Base._addFeature({\nbehaviors: [],\n_desugarBehaviors: function () {\nif (this.behaviors.length) {\nthis.behaviors = this._desugarSomeBehaviors(this.behaviors);\n}\n},\n_desugarSomeBehaviors: function (behaviors) {\nbehaviors = this._flattenBehaviorsList(behaviors);\nfor (var i = behaviors.length - 1; i >= 0; i--) {\nthis._mixinBehavior(behaviors[i]);\n}\nreturn behaviors;\n},\n_flattenBehaviorsList: function (behaviors) {\nvar flat = [];\nbehaviors.forEach(function (b) {\nif (b instanceof Array) {\nflat = flat.concat(this._flattenBehaviorsList(b));\n} else if (b) {\nflat.push(b);\n} else {\nthis._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));\n}\n}, this);\nreturn flat;\n},\n_mixinBehavior: function (b) {\nObject.getOwnPropertyNames(b).forEach(function (n) {\nswitch (n) {\ncase 'hostAttributes':\ncase 'registered':\ncase 'properties':\ncase 'observers':\ncase 'listeners':\ncase 'created':\ncase 'attached':\ncase 'detached':\ncase 'attributeChanged':\ncase 'configure':\ncase 'ready':\nbreak;\ndefault:\nif (!this.hasOwnProperty(n)) {\nthis.copyOwnProperty(n, b, this);\n}\nbreak;\n}\n}, this);\n},\n_prepBehaviors: function () {\nthis._prepFlattenedBehaviors(this.behaviors);\n},\n_prepFlattenedBehaviors: function (behaviors) {\nfor (var i = 0, l = behaviors.length; i < l; i++) {\nthis._prepBehavior(behaviors[i]);\n}\nthis._prepBehavior(this);\n},\n_doBehavior: function (name, args) {\nthis.behaviors.forEach(function (b) {\nthis._invokeBehavior(b, name, args);\n}, this);\nthis._invokeBehavior(this, name, args);\n},\n_invokeBehavior: function (b, name, args) {\nvar fn = b[name];\nif (fn) {\nfn.apply(this, args || Polymer.nar);\n}\n},\n_marshalBehaviors: function () {\nthis.behaviors.forEach(function (b) {\nthis._marshalBehavior(b);\n}, this);\nthis._marshalBehavior(this);\n}\n});\nPolymer.Base._addFeature({\n_getExtendedPrototype: function (tag) {\nreturn this._getExtendedNativePrototype(tag);\n},\n_nativePrototypes: {},\n_getExtendedNativePrototype: function (tag) {\nvar p = this._nativePrototypes[tag];\nif (!p) {\nvar np = this.getNativePrototype(tag);\np = this.extend(Object.create(np), Polymer.Base);\nthis._nativePrototypes[tag] = p;\n}\nreturn p;\n},\ngetNativePrototype: function (tag) {\nreturn Object.getPrototypeOf(document.createElement(tag));\n}\n});\nPolymer.Base._addFeature({\n_prepConstructor: function () {\nthis._factoryArgs = this.extends ? [\nthis.extends,\nthis.is\n] : [this.is];\nvar ctor = function () {\nreturn this._factory(arguments);\n};\nif (this.hasOwnProperty('extends')) {\nctor.extends = this.extends;\n}\nObject.defineProperty(this, 'constructor', {\nvalue: ctor,\nwritable: true,\nconfigurable: true\n});\nctor.prototype = this;\n},\n_factory: function (args) {\nvar elt = document.createElement.apply(document, this._factoryArgs);\nif (this.factoryImpl) {\nthis.factoryImpl.apply(elt, args);\n}\nreturn elt;\n}\n});\nPolymer.nob = Object.create(null);\nPolymer.Base._addFeature({\nproperties: {},\ngetPropertyInfo: function (property) {\nvar info = this._getPropertyInfo(property, this.properties);\nif (!info) {\nthis.behaviors.some(function (b) {\nreturn info = this._getPropertyInfo(property, b.properties);\n}, this);\n}\nreturn info || Polymer.nob;\n},\n_getPropertyInfo: function (property, properties) {\nvar p = properties && properties[property];\nif (typeof p === 'function') {\np = properties[property] = { type: p };\n}\nif (p) {\np.defined = true;\n}\nreturn p;\n}\n});\nPolymer.CaseMap = {\n_caseMap: {},\ndashToCamelCase: function (dash) {\nvar mapped = Polymer.CaseMap._caseMap[dash];\nif (mapped) {\nreturn mapped;\n}\nif (dash.indexOf('-') < 0) {\nreturn Polymer.CaseMap._caseMap[dash] = dash;\n}\nreturn Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {\nreturn m[1].toUpperCase();\n});\n},\ncamelToDashCase: function (camel) {\nvar mapped = Polymer.CaseMap._caseMap[camel];\nif (mapped) {\nreturn mapped;\n}\nreturn Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {\nreturn g[0] + '-' + g[1].toLowerCase();\n});\n}\n};\nPolymer.Base._addFeature({\n_prepAttributes: function () {\nthis._aggregatedAttributes = {};\n},\n_addHostAttributes: function (attributes) {\nif (attributes) {\nthis.mixin(this._aggregatedAttributes, attributes);\n}\n},\n_marshalHostAttributes: function () {\nthis._applyAttributes(this, this._aggregatedAttributes);\n},\n_applyAttributes: function (node, attr$) {\nfor (var n in attr$) {\nif (!this.hasAttribute(n) && n !== 'class') {\nthis.serializeValueToAttribute(attr$[n], n, this);\n}\n}\n},\n_marshalAttributes: function () {\nthis._takeAttributesToModel(this);\n},\n_takeAttributesToModel: function (model) {\nfor (var i = 0, l = this.attributes.length; i < l; i++) {\nthis._setAttributeToProperty(model, this.attributes[i].name);\n}\n},\n_setAttributeToProperty: function (model, attrName) {\nif (!this._serializing) {\nvar propName = Polymer.CaseMap.dashToCamelCase(attrName);\nvar info = this.getPropertyInfo(propName);\nif (info.defined || this._propertyEffects && this._propertyEffects[propName]) {\nvar val = this.getAttribute(attrName);\nmodel[propName] = this.deserialize(val, info.type);\n}\n}\n},\n_serializing: false,\nreflectPropertyToAttribute: function (name) {\nthis._serializing = true;\nthis.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));\nthis._serializing = false;\n},\nserializeValueToAttribute: function (value, attribute, node) {\nvar str = this.serialize(value);\n(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);\n},\ndeserialize: function (value, type) {\nswitch (type) {\ncase Number:\nvalue = Number(value);\nbreak;\ncase Boolean:\nvalue = value !== null;\nbreak;\ncase Object:\ntry {\nvalue = JSON.parse(value);\n} catch (x) {\n}\nbreak;\ncase Array:\ntry {\nvalue = JSON.parse(value);\n} catch (x) {\nvalue = null;\nconsole.warn('Polymer::Attributes: couldn`t decode Array as JSON');\n}\nbreak;\ncase Date:\nvalue = new Date(value);\nbreak;\ncase String:\ndefault:\nbreak;\n}\nreturn value;\n},\nserialize: function (value) {\nswitch (typeof value) {\ncase 'boolean':\nreturn value ? '' : undefined;\ncase 'object':\nif (value instanceof Date) {\nreturn value;\n} else if (value) {\ntry {\nreturn JSON.stringify(value);\n} catch (x) {\nreturn '';\n}\n}\ndefault:\nreturn value != null ? value : undefined;\n}\n}\n});\nPolymer.Base._addFeature({\n_setupDebouncers: function () {\nthis._debouncers = {};\n},\ndebounce: function (jobName, callback, wait) {\nreturn this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);\n},\nisDebouncerActive: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nreturn debouncer && debouncer.finish;\n},\nflushDebouncer: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nif (debouncer) {\ndebouncer.complete();\n}\n},\ncancelDebouncer: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nif (debouncer) {\ndebouncer.stop();\n}\n}\n});\nPolymer.version = '1.1.4';\nPolymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepAttributes();\nthis._prepBehaviors();\nthis._prepConstructor();\n},\n_prepBehavior: function (b) {\nthis._addHostAttributes(b.hostAttributes);\n},\n_marshalBehavior: function (b) {\n},\n_initFeatures: function () {\nthis._marshalHostAttributes();\nthis._setupDebouncers();\nthis._marshalBehaviors();\n}\n});</script>\n\n",
"static/deps/polymer-mini.html": "<!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><link rel=\"import\" href=\"polymer-micro.html\">\n\n<script>Polymer.Base._addFeature({\n_prepTemplate: function () {\nthis._template = this._template || Polymer.DomModule.import(this.is, 'template');\nif (this._template && this._template.hasAttribute('is')) {\nthis._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));\n}\nif (this._template && !this._template.content && HTMLTemplateElement.bootstrap) {\nHTMLTemplateElement.decorate(this._template);\nHTMLTemplateElement.bootstrap(this._template.content);\n}\n},\n_stampTemplate: function () {\nif (this._template) {\nthis.root = this.instanceTemplate(this._template);\n}\n},\ninstanceTemplate: function (template) {\nvar dom = document.importNode(template._content || template.content, true);\nreturn dom;\n}\n});\n(function () {\nvar baseAttachedCallback = Polymer.Base.attachedCallback;\nPolymer.Base._addFeature({\n_hostStack: [],\nready: function () {\n},\n_pushHost: function (host) {\nthis.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];\nif (host && host._clients) {\nhost._clients.push(this);\n}\nthis._beginHost();\n},\n_beginHost: function () {\nPolymer.Base._hostStack.push(this);\nif (!this._clients) {\nthis._clients = [];\n}\n},\n_popHost: function () {\nPolymer.Base._hostStack.pop();\n},\n_tryReady: function () {\nif (this._canReady()) {\nthis._ready();\n}\n},\n_canReady: function () {\nreturn !this.dataHost || this.dataHost._clientsReadied;\n},\n_ready: function () {\nthis._beforeClientsReady();\nthis._setupRoot();\nthis._readyClients();\nthis._afterClientsReady();\nthis._readySelf();\n},\n_readyClients: function () {\nthis._beginDistribute();\nvar c$ = this._clients;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._ready();\n}\nthis._finishDistribute();\nthis._clientsReadied = true;\nthis._clients = null;\n},\n_readySelf: function () {\nthis._doBehavior('ready');\nthis._readied = true;\nif (this._attachedPending) {\nthis._attachedPending = false;\nthis.attachedCallback();\n}\n},\n_beforeClientsReady: function () {\n},\n_afterClientsReady: function () {\n},\n_beforeAttached: function () {\n},\nattachedCallback: function () {\nif (this._readied) {\nthis._beforeAttached();\nbaseAttachedCallback.call(this);\n} else {\nthis._attachedPending = true;\n}\n}\n});\n}());\nPolymer.ArraySplice = function () {\nfunction newSplice(index, removed, addedCount) {\nreturn {\nindex: index,\nremoved: removed,\naddedCount: addedCount\n};\n}\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3;\nfunction ArraySplice() {\n}\nArraySplice.prototype = {\ncalcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar rowCount = oldEnd - oldStart + 1;\nvar columnCount = currentEnd - currentStart + 1;\nvar distances = new Array(rowCount);\nfor (var i = 0; i < rowCount; i++) {\ndistances[i] = new Array(columnCount);\ndistances[i][0] = i;\n}\nfor (var j = 0; j < columnCount; j++)\ndistances[0][j] = j;\nfor (var i = 1; i < rowCount; i++) {\nfor (var j = 1; j < columnCount; j++) {\nif (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\ndistances[i][j] = distances[i - 1][j - 1];\nelse {\nvar north = distances[i - 1][j] + 1;\nvar west = distances[i][j - 1] + 1;\ndistances[i][j] = north < west ? north : west;\n}\n}\n}\nreturn distances;\n},\nspliceOperationsFromEditDistances: function (distances) {\nvar i = distances.length - 1;\nvar j = distances[0].length - 1;\nvar current = distances[i][j];\nvar edits = [];\nwhile (i > 0 || j > 0) {\nif (i == 0) {\nedits.push(EDIT_ADD);\nj--;\ncontinue;\n}\nif (j == 0) {\nedits.push(EDIT_DELETE);\ni--;\ncontinue;\n}\nvar northWest = distances[i - 1][j - 1];\nvar west = distances[i - 1][j];\nvar north = distances[i][j - 1];\nvar min;\nif (west < north)\nmin = west < northWest ? west : northWest;\nelse\nmin = north < northWest ? north : northWest;\nif (min == northWest) {\nif (northWest == current) {\nedits.push(EDIT_LEAVE);\n} else {\nedits.push(EDIT_UPDATE);\ncurrent = northWest;\n}\ni--;\nj--;\n} else if (min == west) {\nedits.push(EDIT_DELETE);\ni--;\ncurrent = west;\n} else {\nedits.push(EDIT_ADD);\nj--;\ncurrent = north;\n}\n}\nedits.reverse();\nreturn edits;\n},\ncalcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar prefixCount = 0;\nvar suffixCount = 0;\nvar minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\nif (currentStart == 0 && oldStart == 0)\nprefixCount = this.sharedPrefix(current, old, minLength);\nif (currentEnd == current.length && oldEnd == old.length)\nsuffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\ncurrentStart += prefixCount;\noldStart += prefixCount;\ncurrentEnd -= suffixCount;\noldEnd -= suffixCount;\nif (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\nreturn [];\nif (currentStart == currentEnd) {\nvar splice = newSplice(currentStart, [], 0);\nwhile (oldStart < oldEnd)\nsplice.removed.push(old[oldStart++]);\nreturn [splice];\n} else if (oldStart == oldEnd)\nreturn [newSplice(currentStart, [], currentEnd - currentStart)];\nvar ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\nvar splice = undefined;\nvar splices = [];\nvar index = currentStart;\nvar oldIndex = oldStart;\nfor (var i = 0; i < ops.length; i++) {\nswitch (ops[i]) {\ncase EDIT_LEAVE:\nif (splice) {\nsplices.push(splice);\nsplice = undefined;\n}\nindex++;\noldIndex++;\nbreak;\ncase EDIT_UPDATE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\ncase EDIT_ADD:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nbreak;\ncase EDIT_DELETE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\n}\n}\nif (splice) {\nsplices.push(splice);\n}\nreturn splices;\n},\nsharedPrefix: function (current, old, searchLength) {\nfor (var i = 0; i < searchLength; i++)\nif (!this.equals(current[i], old[i]))\nreturn i;\nreturn searchLength;\n},\nsharedSuffix: function (current, old, searchLength) {\nvar index1 = current.length;\nvar index2 = old.length;\nvar count = 0;\nwhile (count < searchLength && this.equals(current[--index1], old[--index2]))\ncount++;\nreturn count;\n},\ncalculateSplices: function (current, previous) {\nreturn this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n},\nequals: function (currentValue, previousValue) {\nreturn currentValue === previousValue;\n}\n};\nreturn new ArraySplice();\n}();\nPolymer.EventApi = function () {\nvar Settings = Polymer.Settings;\nvar EventApi = function (event) {\nthis.event = event;\n};\nif (Settings.useShadow) {\nEventApi.prototype = {\nget rootTarget() {\nreturn this.event.path[0];\n},\nget localTarget() {\nreturn this.event.target;\n},\nget path() {\nreturn this.event.path;\n}\n};\n} else {\nEventApi.prototype = {\nget rootTarget() {\nreturn this.event.target;\n},\nget localTarget() {\nvar current = this.event.currentTarget;\nvar currentRoot = current && Polymer.dom(current).getOwnerRoot();\nvar p$ = this.path;\nfor (var i = 0; i < p$.length; i++) {\nif (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {\nreturn p$[i];\n}\n}\n},\nget path() {\nif (!this.event._path) {\nvar path = [];\nvar o = this.rootTarget;\nwhile (o) {\npath.push(o);\no = Polymer.dom(o).parentNode || o.host;\n}\npath.push(window);\nthis.event._path = path;\n}\nreturn this.event._path;\n}\n};\n}\nvar factory = function (event) {\nif (!event.__eventApi) {\nevent.__eventApi = new EventApi(event);\n}\nreturn event.__eventApi;\n};\nreturn { factory: factory };\n}();\nPolymer.domInnerHTML = function () {\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\nfunction escapeReplace(c) {\nswitch (c) {\ncase '&':\nreturn '&amp;';\ncase '<':\nreturn '&lt;';\ncase '>':\nreturn '&gt;';\ncase '\"':\nreturn '&quot;';\ncase '\\xA0':\nreturn '&nbsp;';\n}\n}\nfunction escapeAttr(s) {\nreturn s.replace(escapeAttrRegExp, escapeReplace);\n}\nfunction escapeData(s) {\nreturn s.replace(escapeDataRegExp, escapeReplace);\n}\nfunction makeSet(arr) {\nvar set = {};\nfor (var i = 0; i < arr.length; i++) {\nset[arr[i]] = true;\n}\nreturn set;\n}\nvar voidElements = makeSet([\n'area',\n'base',\n'br',\n'col',\n'command',\n'embed',\n'hr',\n'img',\n'input',\n'keygen',\n'link',\n'meta',\n'param',\n'source',\n'track',\n'wbr'\n]);\nvar plaintextParents = makeSet([\n'style',\n'script',\n'xmp',\n'iframe',\n'noembed',\n'noframes',\n'plaintext',\n'noscript'\n]);\nfunction getOuterHTML(node, parentNode, composed) {\nswitch (node.nodeType) {\ncase Node.ELEMENT_NODE:\nvar tagName = node.localName;\nvar s = '<' + tagName;\nvar attrs = node.attributes;\nfor (var i = 0, attr; attr = attrs[i]; i++) {\ns += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n}\ns += '>';\nif (voidElements[tagName]) {\nreturn s;\n}\nreturn s + getInnerHTML(node, composed) + '</' + tagName + '>';\ncase Node.TEXT_NODE:\nvar data = node.data;\nif (parentNode && plaintextParents[parentNode.localName]) {\nreturn data;\n}\nreturn escapeData(data);\ncase Node.COMMENT_NODE:\nreturn '<!--' + node.data + '-->';\ndefault:\nconsole.error(node);\nthrow new Error('not implemented');\n}\n}\nfunction getInnerHTML(node, composed) {\nif (node instanceof HTMLTemplateElement)\nnode = node.content;\nvar s = '';\nvar c$ = Polymer.dom(node).childNodes;\nc$ = composed ? node._composedChildren : c$;\nfor (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\ns += getOuterHTML(child, node, composed);\n}\nreturn s;\n}\nreturn { getInnerHTML: getInnerHTML };\n}();\nPolymer.DomApi = function () {\n'use strict';\nvar Settings = Polymer.Settings;\nvar getInnerHTML = Polymer.domInnerHTML.getInnerHTML;\nvar nativeInsertBefore = Element.prototype.insertBefore;\nvar nativeRemoveChild = Element.prototype.removeChild;\nvar nativeAppendChild = Element.prototype.appendChild;\nvar nativeCloneNode = Element.prototype.cloneNode;\nvar nativeImportNode = Document.prototype.importNode;\nvar DomApi = function (node) {\nthis.node = node;\nif (this.patch) {\nthis.patch();\n}\n};\nif (window.wrap && Settings.useShadow && !Settings.useNativeShadow) {\nDomApi = function (node) {\nthis.node = wrap(node);\nif (this.patch) {\nthis.patch();\n}\n};\n}\nDomApi.prototype = {\nflush: function () {\nPolymer.dom.flush();\n},\n_lazyDistribute: function (host) {\nif (host.shadyRoot && host.shadyRoot._distributionClean) {\nhost.shadyRoot._distributionClean = false;\nPolymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));\n}\n},\nappendChild: function (node) {\nreturn this._addNode(node);\n},\ninsertBefore: function (node, ref_node) {\nreturn this._addNode(node, ref_node);\n},\n_addNode: function (node, ref_node) {\nthis._removeNodeFromHost(node, true);\nvar addedInsertionPoint;\nvar root = this.getOwnerRoot();\nif (root) {\naddedInsertionPoint = this._maybeAddInsertionPoint(node, this.node);\n}\nif (this._nodeHasLogicalChildren(this.node)) {\nif (ref_node) {\nvar children = this.childNodes;\nvar index = children.indexOf(ref_node);\nif (index < 0) {\nthrow Error('The ref_node to be inserted before is not a child ' + 'of this node');\n}\n}\nthis._addLogicalInfo(node, this.node, index);\n}\nthis._addNodeToHost(node);\nif (!this._maybeDistribute(node, this.node) && !this._tryRemoveUndistributedNode(node)) {\nif (ref_node) {\nref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;\n}\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\naddToComposedParent(container, node, ref_node);\nif (ref_node) {\nnativeInsertBefore.call(container, node, ref_node);\n} else {\nnativeAppendChild.call(container, node);\n}\n}\nif (addedInsertionPoint) {\nthis._updateInsertionPoints(root.host);\n}\nreturn node;\n},\nremoveChild: function (node) {\nif (factory(node).parentNode !== this.node) {\nconsole.warn('The node to be removed is not a child of this node', node);\n}\nthis._removeNodeFromHost(node);\nif (!this._maybeDistribute(node, this.node)) {\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\nif (container === node.parentNode) {\nremoveFromComposedParent(container, node);\nnativeRemoveChild.call(container, node);\n}\n}\nreturn node;\n},\nreplaceChild: function (node, ref_node) {\nthis.insertBefore(node, ref_node);\nthis.removeChild(ref_node);\nreturn node;\n},\n_hasCachedOwnerRoot: function (node) {\nreturn Boolean(node._ownerShadyRoot !== undefined);\n},\ngetOwnerRoot: function () {\nreturn this._ownerShadyRootForNode(this.node);\n},\n_ownerShadyRootForNode: function (node) {\nif (!node) {\nreturn;\n}\nif (node._ownerShadyRoot === undefined) {\nvar root;\nif (node._isShadyRoot) {\nroot = node;\n} else {\nvar parent = Polymer.dom(node).parentNode;\nif (parent) {\nroot = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);\n} else {\nroot = null;\n}\n}\nnode._ownerShadyRoot = root;\n}\nreturn node._ownerShadyRoot;\n},\n_maybeDistribute: function (node, parent) {\nvar fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && Polymer.dom(node).querySelector(CONTENT);\nvar wrappedContent = fragContent && Polymer.dom(fragContent).parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;\nvar hasContent = fragContent || node.localName === CONTENT;\nif (hasContent) {\nvar root = this._ownerShadyRootForNode(parent);\nif (root) {\nvar host = root.host;\nthis._lazyDistribute(host);\n}\n}\nvar parentNeedsDist = this._parentNeedsDistribution(parent);\nif (parentNeedsDist) {\nthis._lazyDistribute(parent);\n}\nreturn parentNeedsDist || hasContent && !wrappedContent;\n},\n_maybeAddInsertionPoint: function (node, parent) {\nvar added;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {\nvar c$ = factory(node).querySelectorAll(CONTENT);\nfor (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {\nnp = factory(n).parentNode;\nif (np === node) {\nnp = parent;\n}\nna = this._maybeAddInsertionPoint(n, np);\nadded = added || na;\n}\n} else if (node.localName === CONTENT) {\nsaveLightChildrenIfNeeded(parent);\nsaveLightChildrenIfNeeded(node);\nadded = true;\n}\nreturn added;\n},\n_tryRemoveUndistributedNode: function (node) {\nif (this.node.shadyRoot) {\nvar parent = getComposedParent(node);\nif (parent) {\nnativeRemoveChild.call(parent, node);\n}\nreturn true;\n}\n},\n_updateInsertionPoints: function (host) {\nvar i$ = host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nsaveLightChildrenIfNeeded(c);\nsaveLightChildrenIfNeeded(factory(c).parentNode);\n}\n},\n_nodeHasLogicalChildren: function (node) {\nreturn Boolean(node._lightChildren !== undefined);\n},\n_parentNeedsDistribution: function (parent) {\nreturn parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);\n},\n_removeNodeFromHost: function (node, ensureComposedRemoval) {\nvar hostNeedsDist;\nvar root;\nvar parent = node._lightParent;\nif (parent) {\nfactory(node)._distributeParent();\nroot = this._ownerShadyRootForNode(node);\nif (root) {\nroot.host._elementRemove(node);\nhostNeedsDist = this._removeDistributedChildren(root, node);\n}\nthis._removeLogicalInfo(node, node._lightParent);\n}\nthis._removeOwnerShadyRoot(node);\nif (root && hostNeedsDist) {\nthis._updateInsertionPoints(root.host);\nthis._lazyDistribute(root.host);\n} else if (ensureComposedRemoval) {\nremoveFromComposedParent(getComposedParent(node), node);\n}\n},\n_removeDistributedChildren: function (root, container) {\nvar hostNeedsDist;\nvar ip$ = root._insertionPoints;\nfor (var i = 0; i < ip$.length; i++) {\nvar content = ip$[i];\nif (this._contains(container, content)) {\nvar dc$ = factory(content).getDistributedNodes();\nfor (var j = 0; j < dc$.length; j++) {\nhostNeedsDist = true;\nvar node = dc$[j];\nvar parent = node.parentNode;\nif (parent) {\nremoveFromComposedParent(parent, node);\nnativeRemoveChild.call(parent, node);\n}\n}\n}\n}\nreturn hostNeedsDist;\n},\n_contains: function (container, node) {\nwhile (node) {\nif (node == container) {\nreturn true;\n}\nnode = factory(node).parentNode;\n}\n},\n_addNodeToHost: function (node) {\nvar root = this.getOwnerRoot();\nif (root) {\nroot.host._elementAdd(node);\n}\n},\n_addLogicalInfo: function (node, container, index) {\nvar children = factory(container).childNodes;\nindex = index === undefined ? children.length : index;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nvar c$ = Array.prototype.slice.call(node.childNodes);\nfor (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\nchildren.splice(index++, 0, n);\nn._lightParent = container;\n}\n} else {\nchildren.splice(index, 0, node);\nnode._lightParent = container;\n}\n},\n_removeLogicalInfo: function (node, container) {\nvar children = factory(container).childNodes;\nvar index = children.indexOf(node);\nif (index < 0 || container !== node._lightParent) {\nthrow Error('The node to be removed is not a child of this node');\n}\nchildren.splice(index, 1);\nnode._lightParent = null;\n},\n_removeOwnerShadyRoot: function (node) {\nif (this._hasCachedOwnerRoot(node)) {\nvar c$ = factory(node).childNodes;\nfor (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {\nthis._removeOwnerShadyRoot(n);\n}\n}\nnode._ownerShadyRoot = undefined;\n},\n_firstComposedNode: function (content) {\nvar n$ = factory(content).getDistributedNodes();\nfor (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {\np$ = factory(n).getDestinationInsertionPoints();\nif (p$[p$.length - 1] === content) {\nreturn n;\n}\n}\n},\nquerySelector: function (selector) {\nreturn this.querySelectorAll(selector)[0];\n},\nquerySelectorAll: function (selector) {\nreturn this._query(function (n) {\nreturn matchesSelector.call(n, selector);\n}, this.node);\n},\n_query: function (matcher, node) {\nnode = node || this.node;\nvar list = [];\nthis._queryElements(factory(node).childNodes, matcher, list);\nreturn list;\n},\n_queryElements: function (elements, matcher, list) {\nfor (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {\nif (c.nodeType === Node.ELEMENT_NODE) {\nthis._queryElement(c, matcher, list);\n}\n}\n},\n_queryElement: function (node, matcher, list) {\nif (matcher(node)) {\nlist.push(node);\n}\nthis._queryElements(factory(node).childNodes, matcher, list);\n},\ngetDestinationInsertionPoints: function () {\nreturn this.node._destinationInsertionPoints || [];\n},\ngetDistributedNodes: function () {\nreturn this.node._distributedNodes || [];\n},\nqueryDistributedElements: function (selector) {\nvar c$ = this.childNodes;\nvar list = [];\nthis._distributedFilter(selector, c$, list);\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.localName === CONTENT) {\nthis._distributedFilter(selector, factory(c).getDistributedNodes(), list);\n}\n}\nreturn list;\n},\n_distributedFilter: function (selector, list, results) {\nresults = results || [];\nfor (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {\nif (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {\nresults.push(d);\n}\n}\nreturn results;\n},\n_clear: function () {\nwhile (this.childNodes.length) {\nthis.removeChild(this.childNodes[0]);\n}\n},\nsetAttribute: function (name, value) {\nthis.node.setAttribute(name, value);\nthis._distributeParent();\n},\nremoveAttribute: function (name) {\nthis.node.removeAttribute(name);\nthis._distributeParent();\n},\n_distributeParent: function () {\nif (this._parentNeedsDistribution(this.parentNode)) {\nthis._lazyDistribute(this.parentNode);\n}\n},\ncloneNode: function (deep) {\nvar n = nativeCloneNode.call(this.node, false);\nif (deep) {\nvar c$ = this.childNodes;\nvar d = factory(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = factory(c$[i]).cloneNode(true);\nd.appendChild(nc);\n}\n}\nreturn n;\n},\nimportNode: function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nvar n = nativeImportNode.call(doc, externalNode, false);\nif (deep) {\nvar c$ = factory(externalNode).childNodes;\nvar d = factory(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = factory(doc).importNode(c$[i], true);\nd.appendChild(nc);\n}\n}\nreturn n;\n}\n};\nObject.defineProperty(DomApi.prototype, 'classList', {\nget: function () {\nif (!this._classList) {\nthis._classList = new DomApi.ClassList(this);\n}\nreturn this._classList;\n},\nconfigurable: true\n});\nDomApi.ClassList = function (host) {\nthis.domApi = host;\nthis.node = host.node;\n};\nDomApi.ClassList.prototype = {\nadd: function () {\nthis.node.classList.add.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\nremove: function () {\nthis.node.classList.remove.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\ntoggle: function () {\nthis.node.classList.toggle.apply(this.node.classList, arguments);\nthis.domApi._distributeParent();\n},\ncontains: function () {\nreturn this.node.classList.contains.apply(this.node.classList, arguments);\n}\n};\nif (!Settings.useShadow) {\nObject.defineProperties(DomApi.prototype, {\nchildNodes: {\nget: function () {\nvar c$ = getLightChildren(this.node);\nreturn Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nreturn Array.prototype.filter.call(this.childNodes, function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n},\nconfigurable: true\n},\nparentNode: {\nget: function () {\nreturn this.node._lightParent || getComposedParent(this.node);\n},\nconfigurable: true\n},\nfirstChild: {\nget: function () {\nreturn this.childNodes[0];\n},\nconfigurable: true\n},\nlastChild: {\nget: function () {\nvar c$ = this.childNodes;\nreturn c$[c$.length - 1];\n},\nconfigurable: true\n},\nnextSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).childNodes;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) + 1];\n}\n},\nconfigurable: true\n},\npreviousSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).childNodes;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) - 1];\n}\n},\nconfigurable: true\n},\nfirstElementChild: {\nget: function () {\nreturn this.children[0];\n},\nconfigurable: true\n},\nlastElementChild: {\nget: function () {\nvar c$ = this.children;\nreturn c$[c$.length - 1];\n},\nconfigurable: true\n},\nnextElementSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).children;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) + 1];\n}\n},\nconfigurable: true\n},\npreviousElementSibling: {\nget: function () {\nvar c$ = this.parentNode && factory(this.parentNode).children;\nif (c$) {\nreturn c$[Array.prototype.indexOf.call(c$, this.node) - 1];\n}\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn this.node.textContent;\n} else {\nvar tc = [];\nfor (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {\nif (c.nodeType !== Node.COMMENT_NODE) {\ntc.push(c.textContent);\n}\n}\nreturn tc.join('');\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nthis.node.textContent = text;\n} else {\nthis._clear();\nif (text) {\nthis.appendChild(document.createTextNode(text));\n}\n}\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn null;\n} else {\nreturn getInnerHTML(this.node);\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {\nthis._clear();\nvar d = document.createElement('div');\nd.innerHTML = text;\nvar c$ = Array.prototype.slice.call(d.childNodes);\nfor (var i = 0; i < c$.length; i++) {\nthis.appendChild(c$[i]);\n}\n}\n},\nconfigurable: true\n}\n});\nDomApi.prototype._getComposedInnerHTML = function () {\nreturn getInnerHTML(this.node, true);\n};\n} else {\nvar forwardMethods = [\n'cloneNode',\n'appendChild',\n'insertBefore',\n'removeChild',\n'replaceChild'\n];\nforwardMethods.forEach(function (name) {\nDomApi.prototype[name] = function () {\nreturn this.node[name].apply(this.node, arguments);\n};\n});\nDomApi.prototype.querySelectorAll = function (selector) {\nreturn Array.prototype.slice.call(this.node.querySelectorAll(selector));\n};\nDomApi.prototype.getOwnerRoot = function () {\nvar n = this.node;\nwhile (n) {\nif (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {\nreturn n;\n}\nn = n.parentNode;\n}\n};\nDomApi.prototype.importNode = function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nreturn doc.importNode(externalNode, deep);\n};\nDomApi.prototype.getDestinationInsertionPoints = function () {\nvar n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();\nreturn n$ ? Array.prototype.slice.call(n$) : [];\n};\nDomApi.prototype.getDistributedNodes = function () {\nvar n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();\nreturn n$ ? Array.prototype.slice.call(n$) : [];\n};\nDomApi.prototype._distributeParent = function () {\n};\nObject.defineProperties(DomApi.prototype, {\nchildNodes: {\nget: function () {\nreturn Array.prototype.slice.call(this.node.childNodes);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nreturn Array.prototype.slice.call(this.node.children);\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nreturn this.node.textContent;\n},\nset: function (value) {\nreturn this.node.textContent = value;\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nreturn this.node.innerHTML;\n},\nset: function (value) {\nreturn this.node.innerHTML = value;\n},\nconfigurable: true\n}\n});\nvar forwardProperties = [\n'parentNode',\n'firstChild',\n'lastChild',\n'nextSibling',\n'previousSibling',\n'firstElementChild',\n'lastElementChild',\n'nextElementSibling',\n'previousElementSibling'\n];\nforwardProperties.forEach(function (name) {\nObject.defineProperty(DomApi.prototype, name, {\nget: function () {\nreturn this.node[name];\n},\nconfigurable: true\n});\n});\n}\nvar CONTENT = 'content';\nvar factory = function (node, patch) {\nnode = node || document;\nif (!node.__domApi) {\nnode.__domApi = new DomApi(node, patch);\n}\nreturn node.__domApi;\n};\nPolymer.dom = function (obj, patch) {\nif (obj instanceof Event) {\nreturn Polymer.EventApi.factory(obj);\n} else {\nreturn factory(obj, patch);\n}\n};\nPolymer.Base.extend(Polymer.dom, {\n_flushGuard: 0,\n_FLUSH_MAX: 100,\n_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,\n_debouncers: [],\n_finishDebouncer: null,\nflush: function () {\nfor (var i = 0; i < this._debouncers.length; i++) {\nthis._debouncers[i].complete();\n}\nif (this._finishDebouncer) {\nthis._finishDebouncer.complete();\n}\nthis._flushPolyfills();\nif (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {\nthis._flushGuard++;\nthis.flush();\n} else {\nif (this._flushGuard >= this._FLUSH_MAX) {\nconsole.warn('Polymer.dom.flush aborted. Flush may not be complete.');\n}\nthis._flushGuard = 0;\n}\n},\n_flushPolyfills: function () {\nif (this._needsTakeRecords) {\nCustomElements.takeRecords();\n}\n},\naddDebouncer: function (debouncer) {\nthis._debouncers.push(debouncer);\nthis._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);\n},\n_finishFlush: function () {\nPolymer.dom._debouncers = [];\n}\n});\nfunction getLightChildren(node) {\nvar children = node._lightChildren;\nreturn children ? children : node.childNodes;\n}\nfunction getComposedChildren(node) {\nif (!node._composedChildren) {\nnode._composedChildren = Array.prototype.slice.call(node.childNodes);\n}\nreturn node._composedChildren;\n}\nfunction addToComposedParent(parent, node, ref_node) {\nvar children = getComposedChildren(parent);\nvar i = ref_node ? children.indexOf(ref_node) : -1;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nvar fragChildren = getComposedChildren(node);\nfor (var j = 0; j < fragChildren.length; j++) {\naddNodeToComposedChildren(fragChildren[j], parent, children, i + j);\n}\nnode._composedChildren = null;\n} else {\naddNodeToComposedChildren(node, parent, children, i);\n}\n}\nfunction getComposedParent(node) {\nreturn node.__patched ? node._composedParent : node.parentNode;\n}\nfunction addNodeToComposedChildren(node, parent, children, i) {\nnode._composedParent = parent;\nchildren.splice(i >= 0 ? i : children.length, 0, node);\n}\nfunction removeFromComposedParent(parent, node) {\nnode._composedParent = null;\nif (parent) {\nvar children = getComposedChildren(parent);\nvar i = children.indexOf(node);\nif (i >= 0) {\nchildren.splice(i, 1);\n}\n}\n}\nfunction saveLightChildrenIfNeeded(node) {\nif (!node._lightChildren) {\nvar c$ = Array.prototype.slice.call(node.childNodes);\nfor (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\nchild._lightParent = child._lightParent || node;\n}\nnode._lightChildren = c$;\n}\n}\nfunction hasInsertionPoint(root) {\nreturn Boolean(root && root._insertionPoints.length);\n}\nvar p = Element.prototype;\nvar matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\nreturn {\ngetLightChildren: getLightChildren,\ngetComposedParent: getComposedParent,\ngetComposedChildren: getComposedChildren,\nremoveFromComposedParent: removeFromComposedParent,\nsaveLightChildrenIfNeeded: saveLightChildrenIfNeeded,\nmatchesSelector: matchesSelector,\nhasInsertionPoint: hasInsertionPoint,\nctor: DomApi,\nfactory: factory\n};\n}();\n(function () {\nPolymer.Base._addFeature({\n_prepShady: function () {\nthis._useContent = this._useContent || Boolean(this._template);\n},\n_poolContent: function () {\nif (this._useContent) {\nsaveLightChildrenIfNeeded(this);\n}\n},\n_setupRoot: function () {\nif (this._useContent) {\nthis._createLocalRoot();\nif (!this.dataHost) {\nupgradeLightChildren(this._lightChildren);\n}\n}\n},\n_createLocalRoot: function () {\nthis.shadyRoot = this.root;\nthis.shadyRoot._distributionClean = false;\nthis.shadyRoot._isShadyRoot = true;\nthis.shadyRoot._dirtyRoots = [];\nvar i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];\nsaveLightChildrenIfNeeded(this.shadyRoot);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nsaveLightChildrenIfNeeded(c);\nsaveLightChildrenIfNeeded(c.parentNode);\n}\nthis.shadyRoot.host = this;\n},\nget domHost() {\nvar root = Polymer.dom(this).getOwnerRoot();\nreturn root && root.host;\n},\ndistributeContent: function (updateInsertionPoints) {\nif (this.shadyRoot) {\nvar dom = Polymer.dom(this);\nif (updateInsertionPoints) {\ndom._updateInsertionPoints(this);\n}\nvar host = getTopDistributingHost(this);\ndom._lazyDistribute(host);\n}\n},\n_distributeContent: function () {\nif (this._useContent && !this.shadyRoot._distributionClean) {\nthis._beginDistribute();\nthis._distributeDirtyRoots();\nthis._finishDistribute();\n}\n},\n_beginDistribute: function () {\nif (this._useContent && hasInsertionPoint(this.shadyRoot)) {\nthis._resetDistribution();\nthis._distributePool(this.shadyRoot, this._collectPool());\n}\n},\n_distributeDirtyRoots: function () {\nvar c$ = this.shadyRoot._dirtyRoots;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._distributeContent();\n}\nthis.shadyRoot._dirtyRoots = [];\n},\n_finishDistribute: function () {\nif (this._useContent) {\nthis.shadyRoot._distributionClean = true;\nif (hasInsertionPoint(this.shadyRoot)) {\nthis._composeTree();\n} else {\nif (!this.shadyRoot._hasDistributed) {\nthis.textContent = '';\nthis._composedChildren = null;\nthis.appendChild(this.shadyRoot);\n} else {\nvar children = this._composeNode(this);\nthis._updateChildNodes(this, children);\n}\n}\nthis.shadyRoot._hasDistributed = true;\n}\n},\nelementMatches: function (selector, node) {\nnode = node || this;\nreturn matchesSelector.call(node, selector);\n},\n_resetDistribution: function () {\nvar children = getLightChildren(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (child._destinationInsertionPoints) {\nchild._destinationInsertionPoints = undefined;\n}\nif (isInsertionPoint(child)) {\nclearDistributedDestinationInsertionPoints(child);\n}\n}\nvar root = this.shadyRoot;\nvar p$ = root._insertionPoints;\nfor (var j = 0; j < p$.length; j++) {\np$[j]._distributedNodes = [];\n}\n},\n_collectPool: function () {\nvar pool = [];\nvar children = getLightChildren(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (isInsertionPoint(child)) {\npool.push.apply(pool, child._distributedNodes);\n} else {\npool.push(child);\n}\n}\nreturn pool;\n},\n_distributePool: function (node, pool) {\nvar p$ = node._insertionPoints;\nfor (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\nthis._distributeInsertionPoint(p, pool);\nmaybeRedistributeParent(p, this);\n}\n},\n_distributeInsertionPoint: function (content, pool) {\nvar anyDistributed = false;\nfor (var i = 0, l = pool.length, node; i < l; i++) {\nnode = pool[i];\nif (!node) {\ncontinue;\n}\nif (this._matchesContentSelect(node, content)) {\ndistributeNodeInto(node, content);\npool[i] = undefined;\nanyDistributed = true;\n}\n}\nif (!anyDistributed) {\nvar children = getLightChildren(content);\nfor (var j = 0; j < children.length; j++) {\ndistributeNodeInto(children[j], content);\n}\n}\n},\n_composeTree: function () {\nthis._updateChildNodes(this, this._composeNode(this));\nvar p$ = this.shadyRoot._insertionPoints;\nfor (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {\nparent = p._lightParent || p.parentNode;\nif (!parent._useContent && parent !== this && parent !== this.shadyRoot) {\nthis._updateChildNodes(parent, this._composeNode(parent));\n}\n}\n},\n_composeNode: function (node) {\nvar children = [];\nvar c$ = getLightChildren(node.shadyRoot || node);\nfor (var i = 0; i < c$.length; i++) {\nvar child = c$[i];\nif (isInsertionPoint(child)) {\nvar distributedNodes = child._distributedNodes;\nfor (var j = 0; j < distributedNodes.length; j++) {\nvar distributedNode = distributedNodes[j];\nif (isFinalDestination(child, distributedNode)) {\nchildren.push(distributedNode);\n}\n}\n} else {\nchildren.push(child);\n}\n}\nreturn children;\n},\n_updateChildNodes: function (container, children) {\nvar composed = getComposedChildren(container);\nvar splices = Polymer.ArraySplice.calculateSplices(children, composed);\nfor (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\nif (getComposedParent(n) === container) {\nremove(n);\n}\ncomposed.splice(s.index + d, 1);\n}\nd -= s.addedCount;\n}\nfor (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {\nnext = composed[s.index];\nfor (var j = s.index, n; j < s.index + s.addedCount; j++) {\nn = children[j];\ninsertBefore(container, n, next);\ncomposed.splice(j, 0, n);\n}\n}\nensureComposedParent(container, children);\n},\n_matchesContentSelect: function (node, contentElement) {\nvar select = contentElement.getAttribute('select');\nif (!select) {\nreturn true;\n}\nselect = select.trim();\nif (!select) {\nreturn true;\n}\nif (!(node instanceof Element)) {\nreturn false;\n}\nvar validSelectors = /^(:not\\()?[*.#[a-zA-Z_|]/;\nif (!validSelectors.test(select)) {\nreturn false;\n}\nreturn this.elementMatches(select, node);\n},\n_elementAdd: function () {\n},\n_elementRemove: function () {\n}\n});\nvar saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;\nvar getLightChildren = Polymer.DomApi.getLightChildren;\nvar matchesSelector = Polymer.DomApi.matchesSelector;\nvar hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;\nvar getComposedChildren = Polymer.DomApi.getComposedChildren;\nvar getComposedParent = Polymer.DomApi.getComposedParent;\nvar removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;\nfunction distributeNodeInto(child, insertionPoint) {\ninsertionPoint._distributedNodes.push(child);\nvar points = child._destinationInsertionPoints;\nif (!points) {\nchild._destinationInsertionPoints = [insertionPoint];\n} else {\npoints.push(insertionPoint);\n}\n}\nfunction clearDistributedDestinationInsertionPoints(content) {\nvar e$ = content._distributedNodes;\nif (e$) {\nfor (var i = 0; i < e$.length; i++) {\nvar d = e$[i]._destinationInsertionPoints;\nif (d) {\nd.splice(d.indexOf(content) + 1, d.length);\n}\n}\n}\n}\nfunction maybeRedistributeParent(content, host) {\nvar parent = content._lightParent;\nif (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {\nparent.shadyRoot._distributionClean = false;\nhost.shadyRoot._dirtyRoots.push(parent);\n}\n}\nfunction isFinalDestination(insertionPoint, node) {\nvar points = node._destinationInsertionPoints;\nreturn points && points[points.length - 1] === insertionPoint;\n}\nfunction isInsertionPoint(node) {\nreturn node.localName == 'content';\n}\nvar nativeInsertBefore = Element.prototype.insertBefore;\nvar nativeRemoveChild = Element.prototype.removeChild;\nfunction insertBefore(parentNode, newChild, refChild) {\nvar newChildParent = getComposedParent(newChild);\nif (newChildParent !== parentNode) {\nremoveFromComposedParent(newChildParent, newChild);\n}\nremove(newChild);\nnativeInsertBefore.call(parentNode, newChild, refChild || null);\nnewChild._composedParent = parentNode;\n}\nfunction remove(node) {\nvar parentNode = getComposedParent(node);\nif (parentNode) {\nnode._composedParent = null;\nnativeRemoveChild.call(parentNode, node);\n}\n}\nfunction ensureComposedParent(parent, children) {\nfor (var i = 0, n; i < children.length; i++) {\nchildren[i]._composedParent = parent;\n}\n}\nfunction getTopDistributingHost(host) {\nwhile (host && hostNeedsRedistribution(host)) {\nhost = host.domHost;\n}\nreturn host;\n}\nfunction hostNeedsRedistribution(host) {\nvar c$ = Polymer.dom(host).children;\nfor (var i = 0, c; i < c$.length; i++) {\nc = c$[i];\nif (c.localName === 'content') {\nreturn host.domHost;\n}\n}\n}\nvar needsUpgrade = window.CustomElements && !CustomElements.useNative;\nfunction upgradeLightChildren(children) {\nif (needsUpgrade && children) {\nfor (var i = 0; i < children.length; i++) {\nCustomElements.upgrade(children[i]);\n}\n}\n}\n}());\nif (Polymer.Settings.useShadow) {\nPolymer.Base._addFeature({\n_poolContent: function () {\n},\n_beginDistribute: function () {\n},\ndistributeContent: function () {\n},\n_distributeContent: function () {\n},\n_finishDistribute: function () {\n},\n_createLocalRoot: function () {\nthis.createShadowRoot();\nthis.shadowRoot.appendChild(this.root);\nthis.root = this.shadowRoot;\n}\n});\n}\nPolymer.DomModule = document.createElement('dom-module');\nPolymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepAttributes();\nthis._prepBehaviors();\nthis._prepConstructor();\nthis._prepTemplate();\nthis._prepShady();\n},\n_prepBehavior: function (b) {\nthis._addHostAttributes(b.hostAttributes);\n},\n_initFeatures: function () {\nthis._poolContent();\nthis._pushHost();\nthis._stampTemplate();\nthis._popHost();\nthis._marshalHostAttributes();\nthis._setupDebouncers();\nthis._marshalBehaviors();\nthis._tryReady();\n},\n_marshalBehavior: function (b) {\n}\n});</script>\n\n",
"static/deps/polymer.html": "<!--\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><link rel=\"import\" href=\"polymer-mini.html\">\n\n<script>Polymer.nar = [];\nPolymer.Annotations = {\nparseAnnotations: function (template) {\nvar list = [];\nvar content = template._content || template.content;\nthis._parseNodeAnnotations(content, list);\nreturn list;\n},\n_parseNodeAnnotations: function (node, list) {\nreturn node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);\n},\n_testEscape: function (value) {\nvar escape = value.slice(0, 2);\nif (escape === '{{' || escape === '[[') {\nreturn escape;\n}\n},\n_parseTextNodeAnnotation: function (node, list) {\nvar v = node.textContent;\nvar escape = this._testEscape(v);\nif (escape) {\nnode.textContent = ' ';\nvar annote = {\nbindings: [{\nkind: 'text',\nmode: escape[0],\nvalue: v.slice(2, -2).trim()\n}]\n};\nlist.push(annote);\nreturn annote;\n}\n},\n_parseElementAnnotations: function (element, list) {\nvar annote = {\nbindings: [],\nevents: []\n};\nif (element.localName === 'content') {\nlist._hasContent = true;\n}\nthis._parseChildNodesAnnotations(element, annote, list);\nif (element.attributes) {\nthis._parseNodeAttributeAnnotations(element, annote, list);\nif (this.prepElement) {\nthis.prepElement(element);\n}\n}\nif (annote.bindings.length || annote.events.length || annote.id) {\nlist.push(annote);\n}\nreturn annote;\n},\n_parseChildNodesAnnotations: function (root, annote, list, callback) {\nif (root.firstChild) {\nfor (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {\nif (node.localName === 'template' && !node.hasAttribute('preserve-content')) {\nthis._parseTemplate(node, i, list, annote);\n}\nif (node.nodeType === Node.TEXT_NODE) {\nvar n = node.nextSibling;\nwhile (n && n.nodeType === Node.TEXT_NODE) {\nnode.textContent += n.textContent;\nroot.removeChild(n);\nn = n.nextSibling;\n}\n}\nvar childAnnotation = this._parseNodeAnnotations(node, list, callback);\nif (childAnnotation) {\nchildAnnotation.parent = annote;\nchildAnnotation.index = i;\n}\n}\n}\n},\n_parseTemplate: function (node, index, list, parent) {\nvar content = document.createDocumentFragment();\ncontent._notes = this.parseAnnotations(node);\ncontent.appendChild(node.content);\nlist.push({\nbindings: Polymer.nar,\nevents: Polymer.nar,\ntemplateContent: content,\nparent: parent,\nindex: index\n});\n},\n_parseNodeAttributeAnnotations: function (node, annotation) {\nfor (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {\nvar n = a.name, v = a.value;\nif (n === 'id' && !this._testEscape(v)) {\nannotation.id = v;\n} else if (n.slice(0, 3) === 'on-') {\nnode.removeAttribute(n);\nannotation.events.push({\nname: n.slice(3),\nvalue: v\n});\n} else {\nvar b = this._parseNodeAttributeAnnotation(node, n, v);\nif (b) {\nannotation.bindings.push(b);\n}\n}\n}\n},\n_parseNodeAttributeAnnotation: function (node, n, v) {\nvar escape = this._testEscape(v);\nif (escape) {\nvar customEvent;\nvar name = n;\nvar mode = escape[0];\nv = v.slice(2, -2).trim();\nvar not = false;\nif (v[0] == '!') {\nv = v.substring(1);\nnot = true;\n}\nvar kind = 'property';\nif (n[n.length - 1] == '$') {\nname = n.slice(0, -1);\nkind = 'attribute';\n}\nvar notifyEvent, colon;\nif (mode == '{' && (colon = v.indexOf('::')) > 0) {\nnotifyEvent = v.substring(colon + 2);\nv = v.substring(0, colon);\ncustomEvent = true;\n}\nif (node.localName == 'input' && n == 'value') {\nnode.setAttribute(n, '');\n}\nnode.removeAttribute(n);\nif (kind === 'property') {\nname = Polymer.CaseMap.dashToCamelCase(name);\n}\nreturn {\nkind: kind,\nmode: mode,\nname: name,\nvalue: v,\nnegate: not,\nevent: notifyEvent,\ncustomEvent: customEvent\n};\n}\n},\n_localSubTree: function (node, host) {\nreturn node === host ? node.childNodes : node._lightChildren || node.childNodes;\n},\nfindAnnotatedNode: function (root, annote) {\nvar parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);\nreturn !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];\n}\n};\n(function () {\nfunction resolveCss(cssText, ownerDocument) {\nreturn cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\nreturn pre + '\\'' + resolve(url.replace(/[\"']/g, ''), ownerDocument) + '\\'' + post;\n});\n}\nfunction resolveAttrs(element, ownerDocument) {\nfor (var name in URL_ATTRS) {\nvar a$ = URL_ATTRS[name];\nfor (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {\nif (name === '*' || element.localName === name) {\nat = element.attributes[a];\nv = at && at.value;\nif (v && v.search(BINDING_RX) < 0) {\nat.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);\n}\n}\n}\n}\n}\nfunction resolve(url, ownerDocument) {\nif (url && url[0] === '#') {\nreturn url;\n}\nvar resolver = getUrlResolver(ownerDocument);\nresolver.href = url;\nreturn resolver.href || url;\n}\nvar tempDoc;\nvar tempDocBase;\nfunction resolveUrl(url, baseUri) {\nif (!tempDoc) {\ntempDoc = document.implementation.createHTMLDocument('temp');\ntempDocBase = tempDoc.createElement('base');\ntempDoc.head.appendChild(tempDocBase);\n}\ntempDocBase.href = baseUri;\nreturn resolve(url, tempDoc);\n}\nfunction getUrlResolver(ownerDocument) {\nreturn ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));\n}\nvar CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nvar URL_ATTRS = {\n'*': [\n'href',\n'src',\n'style',\n'url'\n],\nform: ['action']\n};\nvar BINDING_RX = /\\{\\{|\\[\\[/;\nPolymer.ResolveUrl = {\nresolveCss: resolveCss,\nresolveAttrs: resolveAttrs,\nresolveUrl: resolveUrl\n};\n}());\nPolymer.Base._addFeature({\n_prepAnnotations: function () {\nif (!this._template) {\nthis._notes = [];\n} else {\nPolymer.Annotations.prepElement = this._prepElement.bind(this);\nif (this._template._content && this._template._content._notes) {\nthis._notes = this._template._content._notes;\n} else {\nthis._notes = Polymer.Annotations.parseAnnotations(this._template);\n}\nthis._processAnnotations(this._notes);\nPolymer.Annotations.prepElement = null;\n}\n},\n_processAnnotations: function (notes) {\nfor (var i = 0; i < notes.length; i++) {\nvar note = notes[i];\nfor (var j = 0; j < note.bindings.length; j++) {\nvar b = note.bindings[j];\nb.signature = this._parseMethod(b.value);\nif (!b.signature) {\nb.model = this._modelForPath(b.value);\n}\n}\nif (note.templateContent) {\nthis._processAnnotations(note.templateContent._notes);\nvar pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);\nvar bindings = [];\nfor (var prop in pp) {\nbindings.push({\nindex: note.index,\nkind: 'property',\nmode: '{',\nname: '_parent_' + prop,\nmodel: prop,\nvalue: prop\n});\n}\nnote.bindings = note.bindings.concat(bindings);\n}\n}\n},\n_discoverTemplateParentProps: function (notes) {\nvar pp = {};\nnotes.forEach(function (n) {\nn.bindings.forEach(function (b) {\nif (b.signature) {\nvar args = b.signature.args;\nfor (var k = 0; k < args.length; k++) {\npp[args[k].model] = true;\n}\n} else {\npp[b.model] = true;\n}\n});\nif (n.templateContent) {\nvar tpp = n.templateContent._parentProps;\nPolymer.Base.mixin(pp, tpp);\n}\n});\nreturn pp;\n},\n_prepElement: function (element) {\nPolymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);\n},\n_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,\n_marshalAnnotationReferences: function () {\nif (this._template) {\nthis._marshalIdNodes();\nthis._marshalAnnotatedNodes();\nthis._marshalAnnotatedListeners();\n}\n},\n_configureAnnotationReferences: function () {\nthis._configureTemplateContent();\n},\n_configureTemplateContent: function () {\nthis._notes.forEach(function (note, i) {\nif (note.templateContent) {\nthis._nodes[i]._content = note.templateContent;\n}\n}, this);\n},\n_marshalIdNodes: function () {\nthis.$ = {};\nthis._notes.forEach(function (a) {\nif (a.id) {\nthis.$[a.id] = this._findAnnotatedNode(this.root, a);\n}\n}, this);\n},\n_marshalAnnotatedNodes: function () {\nif (this._nodes) {\nthis._nodes = this._nodes.map(function (a) {\nreturn this._findAnnotatedNode(this.root, a);\n}, this);\n}\n},\n_marshalAnnotatedListeners: function () {\nthis._notes.forEach(function (a) {\nif (a.events && a.events.length) {\nvar node = this._findAnnotatedNode(this.root, a);\na.events.forEach(function (e) {\nthis.listen(node, e.name, e.value);\n}, this);\n}\n}, this);\n}\n});\nPolymer.Base._addFeature({\nlisteners: {},\n_listenListeners: function (listeners) {\nvar node, name, key;\nfor (key in listeners) {\nif (key.indexOf('.') < 0) {\nnode = this;\nname = key;\n} else {\nname = key.split('.');\nnode = this.$[name[0]];\nname = name[1];\n}\nthis.listen(node, name, listeners[key]);\n}\n},\nlisten: function (node, eventName, methodName) {\nthis._listen(node, eventName, this._createEventHandler(node, eventName, methodName));\n},\n_boundListenerKey: function (eventName, methodName) {\nreturn eventName + ':' + methodName;\n},\n_recordEventHandler: function (host, eventName, target, methodName, handler) {\nvar hbl = host.__boundListeners;\nif (!hbl) {\nhbl = host.__boundListeners = new WeakMap();\n}\nvar bl = hbl.get(target);\nif (!bl) {\nbl = {};\nhbl.set(target, bl);\n}\nvar key = this._boundListenerKey(eventName, methodName);\nbl[key] = handler;\n},\n_recallEventHandler: function (host, eventName, target, methodName) {\nvar hbl = host.__boundListeners;\nif (!hbl) {\nreturn;\n}\nvar bl = hbl.get(target);\nif (!bl) {\nreturn;\n}\nvar key = this._boundListenerKey(eventName, methodName);\nreturn bl[key];\n},\n_createEventHandler: function (node, eventName, methodName) {\nvar host = this;\nvar handler = function (e) {\nif (host[methodName]) {\nhost[methodName](e, e.detail);\n} else {\nhost._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));\n}\n};\nthis._recordEventHandler(host, eventName, node, methodName, handler);\nreturn handler;\n},\nunlisten: function (node, eventName, methodName) {\nvar handler = this._recallEventHandler(this, eventName, node, methodName);\nif (handler) {\nthis._unlisten(node, eventName, handler);\n}\n},\n_listen: function (node, eventName, handler) {\nnode.addEventListener(eventName, handler);\n},\n_unlisten: function (node, eventName, handler) {\nnode.removeEventListener(eventName, handler);\n}\n});\n(function () {\n'use strict';\nvar HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nvar GESTURE_KEY = '__polymerGestures';\nvar HANDLED_OBJ = '__polymerGesturesHandled';\nvar TOUCH_ACTION = '__polymerGesturesTouchAction';\nvar TAP_DISTANCE = 25;\nvar TRACK_DISTANCE = 5;\nvar TRACK_LENGTH = 2;\nvar MOUSE_TIMEOUT = 2500;\nvar MOUSE_EVENTS = [\n'mousedown',\n'mousemove',\n'mouseup',\n'click'\n];\nvar MOUSE_WHICH_TO_BUTTONS = [\n0,\n1,\n4,\n2\n];\nvar MOUSE_HAS_BUTTONS = function () {\ntry {\nreturn new MouseEvent('test', { buttons: 1 }).buttons === 1;\n} catch (e) {\nreturn false;\n}\n}();\nvar IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\nvar mouseCanceller = function (mouseEvent) {\nmouseEvent[HANDLED_OBJ] = { skip: true };\nif (mouseEvent.type === 'click') {\nvar path = Polymer.dom(mouseEvent).path;\nfor (var i = 0; i < path.length; i++) {\nif (path[i] === POINTERSTATE.mouse.target) {\nreturn;\n}\n}\nmouseEvent.preventDefault();\nmouseEvent.stopPropagation();\n}\n};\nfunction setupTeardownMouseCanceller(setup) {\nfor (var i = 0, en; i < MOUSE_EVENTS.length; i++) {\nen = MOUSE_EVENTS[i];\nif (setup) {\ndocument.addEventListener(en, mouseCanceller, true);\n} else {\ndocument.removeEventListener(en, mouseCanceller, true);\n}\n}\n}\nfunction ignoreMouse() {\nif (IS_TOUCH_ONLY) {\nreturn;\n}\nif (!POINTERSTATE.mouse.mouseIgnoreJob) {\nsetupTeardownMouseCanceller(true);\n}\nvar unset = function () {\nsetupTeardownMouseCanceller();\nPOINTERSTATE.mouse.target = null;\nPOINTERSTATE.mouse.mouseIgnoreJob = null;\n};\nPOINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);\n}\nfunction hasLeftMouseButton(ev) {\nvar type = ev.type;\nif (MOUSE_EVENTS.indexOf(type) === -1) {\nreturn false;\n}\nif (type === 'mousemove') {\nvar buttons = ev.buttons === undefined ? 1 : ev.buttons;\nif (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\nbuttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n}\nreturn Boolean(buttons & 1);\n} else {\nvar button = ev.button === undefined ? 0 : ev.button;\nreturn button === 0;\n}\n}\nfunction isSyntheticClick(ev) {\nif (ev.type === 'click') {\nif (ev.detail === 0) {\nreturn true;\n}\nvar t = Gestures.findOriginalTarget(ev);\nvar bcr = t.getBoundingClientRect();\nvar x = ev.pageX, y = ev.pageY;\nreturn !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));\n}\nreturn false;\n}\nvar POINTERSTATE = {\nmouse: {\ntarget: null,\nmouseIgnoreJob: null\n},\ntouch: {\nx: 0,\ny: 0,\nid: -1,\nscrollDecided: false\n}\n};\nfunction firstTouchAction(ev) {\nvar path = Polymer.dom(ev).path;\nvar ta = 'auto';\nfor (var i = 0, n; i < path.length; i++) {\nn = path[i];\nif (n[TOUCH_ACTION]) {\nta = n[TOUCH_ACTION];\nbreak;\n}\n}\nreturn ta;\n}\nfunction trackDocument(stateObj, movefn, upfn) {\nstateObj.movefn = movefn;\nstateObj.upfn = upfn;\ndocument.addEventListener('mousemove', movefn);\ndocument.addEventListener('mouseup', upfn);\n}\nfunction untrackDocument(stateObj) {\ndocument.removeEventListener('mousemove', stateObj.movefn);\ndocument.removeEventListener('mouseup', stateObj.upfn);\n}\nvar Gestures = {\ngestures: {},\nrecognizers: [],\ndeepTargetFind: function (x, y) {\nvar node = document.elementFromPoint(x, y);\nvar next = node;\nwhile (next && next.shadowRoot) {\nnext = next.shadowRoot.elementFromPoint(x, y);\nif (next) {\nnode = next;\n}\n}\nreturn node;\n},\nfindOriginalTarget: function (ev) {\nif (ev.path) {\nreturn ev.path[0];\n}\nreturn ev.target;\n},\nhandleNative: function (ev) {\nvar handled;\nvar type = ev.type;\nvar node = ev.currentTarget;\nvar gobj = node[GESTURE_KEY];\nvar gs = gobj[type];\nif (!gs) {\nreturn;\n}\nif (!ev[HANDLED_OBJ]) {\nev[HANDLED_OBJ] = {};\nif (type.slice(0, 5) === 'touch') {\nvar t = ev.changedTouches[0];\nif (type === 'touchstart') {\nif (ev.touches.length === 1) {\nPOINTERSTATE.touch.id = t.identifier;\n}\n}\nif (POINTERSTATE.touch.id !== t.identifier) {\nreturn;\n}\nif (!HAS_NATIVE_TA) {\nif (type === 'touchstart' || type === 'touchmove') {\nGestures.handleTouchAction(ev);\n}\n}\nif (type === 'touchend') {\nPOINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;\nignoreMouse(true);\n}\n}\n}\nhandled = ev[HANDLED_OBJ];\nif (handled.skip) {\nreturn;\n}\nvar recognizers = Gestures.recognizers;\nfor (var i = 0, r; i < recognizers.length; i++) {\nr = recognizers[i];\nif (gs[r.name] && !handled[r.name]) {\nif (r.flow && r.flow.start.indexOf(ev.type) > -1) {\nif (r.reset) {\nr.reset();\n}\n}\n}\n}\nfor (var i = 0, r; i < recognizers.length; i++) {\nr = recognizers[i];\nif (gs[r.name] && !handled[r.name]) {\nhandled[r.name] = true;\nr[type](ev);\n}\n}\n},\nhandleTouchAction: function (ev) {\nvar t = ev.changedTouches[0];\nvar type = ev.type;\nif (type === 'touchstart') {\nPOINTERSTATE.touch.x = t.clientX;\nPOINTERSTATE.touch.y = t.clientY;\nPOINTERSTATE.touch.scrollDecided = false;\n} else if (type === 'touchmove') {\nif (POINTERSTATE.touch.scrollDecided) {\nreturn;\n}\nPOINTERSTATE.touch.scrollDecided = true;\nvar ta = firstTouchAction(ev);\nvar prevent = false;\nvar dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\nvar dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\nif (!ev.cancelable) {\n} else if (ta === 'none') {\nprevent = true;\n} else if (ta === 'pan-x') {\nprevent = dy > dx;\n} else if (ta === 'pan-y') {\nprevent = dx > dy;\n}\nif (prevent) {\nev.preventDefault();\n} else {\nGestures.prevent('track');\n}\n}\n},\nadd: function (node, evType, handler) {\nvar recognizer = this.gestures[evType];\nvar deps = recognizer.deps;\nvar name = recognizer.name;\nvar gobj = node[GESTURE_KEY];\nif (!gobj) {\nnode[GESTURE_KEY] = gobj = {};\n}\nfor (var i = 0, dep, gd; i < deps.length; i++) {\ndep = deps[i];\nif (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {\ncontinue;\n}\ngd = gobj[dep];\nif (!gd) {\ngobj[dep] = gd = { _count: 0 };\n}\nif (gd._count === 0) {\nnode.addEventListener(dep, this.handleNative);\n}\ngd[name] = (gd[name] || 0) + 1;\ngd._count = (gd._count || 0) + 1;\n}\nnode.addEventListener(evType, handler);\nif (recognizer.touchAction) {\nthis.setTouchAction(node, recognizer.touchAction);\n}\n},\nremove: function (node, evType, handler) {\nvar recognizer = this.gestures[evType];\nvar deps = recognizer.deps;\nvar name = recognizer.name;\nvar gobj = node[GESTURE_KEY];\nif (gobj) {\nfor (var i = 0, dep, gd; i < deps.length; i++) {\ndep = deps[i];\ngd = gobj[dep];\nif (gd && gd[name]) {\ngd[name] = (gd[name] || 1) - 1;\ngd._count = (gd._count || 1) - 1;\nif (gd._count === 0) {\nnode.removeEventListener(dep, this.handleNative);\n}\n}\n}\n}\nnode.removeEventListener(evType, handler);\n},\nregister: function (recog) {\nthis.recognizers.push(recog);\nfor (var i = 0; i < recog.emits.length; i++) {\nthis.gestures[recog.emits[i]] = recog;\n}\n},\nfindRecognizerByEvent: function (evName) {\nfor (var i = 0, r; i < this.recognizers.length; i++) {\nr = this.recognizers[i];\nfor (var j = 0, n; j < r.emits.length; j++) {\nn = r.emits[j];\nif (n === evName) {\nreturn r;\n}\n}\n}\nreturn null;\n},\nsetTouchAction: function (node, value) {\nif (HAS_NATIVE_TA) {\nnode.style.touchAction = value;\n}\nnode[TOUCH_ACTION] = value;\n},\nfire: function (target, type, detail) {\nvar ev = Polymer.Base.fire(type, detail, {\nnode: target,\nbubbles: true,\ncancelable: true\n});\nif (ev.defaultPrevented) {\nvar se = detail.sourceEvent;\nif (se && se.preventDefault) {\nse.preventDefault();\n}\n}\n},\nprevent: function (evName) {\nvar recognizer = this.findRecognizerByEvent(evName);\nif (recognizer.info) {\nrecognizer.info.prevent = true;\n}\n}\n};\nGestures.register({\nname: 'downup',\ndeps: [\n'mousedown',\n'touchstart',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'mouseup',\n'touchend'\n]\n},\nemits: [\n'down',\n'up'\n],\ninfo: {\nmovefn: function () {\n},\nupfn: function () {\n}\n},\nreset: function () {\nuntrackDocument(this.info);\n},\nmousedown: function (e) {\nif (!hasLeftMouseButton(e)) {\nreturn;\n}\nvar t = Gestures.findOriginalTarget(e);\nvar self = this;\nvar movefn = function movefn(e) {\nif (!hasLeftMouseButton(e)) {\nself.fire('up', t, e);\nuntrackDocument(self.info);\n}\n};\nvar upfn = function upfn(e) {\nif (hasLeftMouseButton(e)) {\nself.fire('up', t, e);\n}\nuntrackDocument(self.info);\n};\ntrackDocument(this.info, movefn, upfn);\nthis.fire('down', t, e);\n},\ntouchstart: function (e) {\nthis.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0]);\n},\ntouchend: function (e) {\nthis.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0]);\n},\nfire: function (type, target, event) {\nvar self = this;\nGestures.fire(target, type, {\nx: event.clientX,\ny: event.clientY,\nsourceEvent: event,\nprevent: Gestures.prevent.bind(Gestures)\n});\n}\n});\nGestures.register({\nname: 'track',\ntouchAction: 'none',\ndeps: [\n'mousedown',\n'touchstart',\n'touchmove',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'mouseup',\n'touchend'\n]\n},\nemits: ['track'],\ninfo: {\nx: 0,\ny: 0,\nstate: 'start',\nstarted: false,\nmoves: [],\naddMove: function (move) {\nif (this.moves.length > TRACK_LENGTH) {\nthis.moves.shift();\n}\nthis.moves.push(move);\n},\nmovefn: function () {\n},\nupfn: function () {\n},\nprevent: false\n},\nreset: function () {\nthis.info.state = 'start';\nthis.info.started = false;\nthis.info.moves = [];\nthis.info.x = 0;\nthis.info.y = 0;\nthis.info.prevent = false;\nuntrackDocument(this.info);\n},\nhasMovedEnough: function (x, y) {\nif (this.info.prevent) {\nreturn false;\n}\nif (this.info.started) {\nreturn true;\n}\nvar dx = Math.abs(this.info.x - x);\nvar dy = Math.abs(this.info.y - y);\nreturn dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n},\nmousedown: function (e) {\nif (!hasLeftMouseButton(e)) {\nreturn;\n}\nvar t = Gestures.findOriginalTarget(e);\nvar self = this;\nvar movefn = function movefn(e) {\nvar x = e.clientX, y = e.clientY;\nif (self.hasMovedEnough(x, y)) {\nself.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';\nself.info.addMove({\nx: x,\ny: y\n});\nif (!hasLeftMouseButton(e)) {\nself.info.state = 'end';\nuntrackDocument(self.info);\n}\nself.fire(t, e);\nself.info.started = true;\n}\n};\nvar upfn = function upfn(e) {\nif (self.info.started) {\nGestures.prevent('tap');\nmovefn(e);\n}\nuntrackDocument(self.info);\n};\ntrackDocument(this.info, movefn, upfn);\nthis.info.x = e.clientX;\nthis.info.y = e.clientY;\n},\ntouchstart: function (e) {\nvar ct = e.changedTouches[0];\nthis.info.x = ct.clientX;\nthis.info.y = ct.clientY;\n},\ntouchmove: function (e) {\nvar t = Gestures.findOriginalTarget(e);\nvar ct = e.changedTouches[0];\nvar x = ct.clientX, y = ct.clientY;\nif (this.hasMovedEnough(x, y)) {\nthis.info.addMove({\nx: x,\ny: y\n});\nthis.fire(t, ct);\nthis.info.state = 'track';\nthis.info.started = true;\n}\n},\ntouchend: function (e) {\nvar t = Gestures.findOriginalTarget(e);\nvar ct = e.changedTouches[0];\nif (this.info.started) {\nGestures.prevent('tap');\nthis.info.state = 'end';\nthis.info.addMove({\nx: ct.clientX,\ny: ct.clientY\n});\nthis.fire(t, ct);\n}\n},\nfire: function (target, touch) {\nvar secondlast = this.info.moves[this.info.moves.length - 2];\nvar lastmove = this.info.moves[this.info.moves.length - 1];\nvar dx = lastmove.x - this.info.x;\nvar dy = lastmove.y - this.info.y;\nvar ddx, ddy = 0;\nif (secondlast) {\nddx = lastmove.x - secondlast.x;\nddy = lastmove.y - secondlast.y;\n}\nreturn Gestures.fire(target, 'track', {\nstate: this.info.state,\nx: touch.clientX,\ny: touch.clientY,\ndx: dx,\ndy: dy,\nddx: ddx,\nddy: ddy,\nsourceEvent: touch,\nhover: function () {\nreturn Gestures.deepTargetFind(touch.clientX, touch.clientY);\n}\n});\n}\n});\nGestures.register({\nname: 'tap',\ndeps: [\n'mousedown',\n'click',\n'touchstart',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'click',\n'touchend'\n]\n},\nemits: ['tap'],\ninfo: {\nx: NaN,\ny: NaN,\nprevent: false\n},\nreset: function () {\nthis.info.x = NaN;\nthis.info.y = NaN;\nthis.info.prevent = false;\n},\nsave: function (e) {\nthis.info.x = e.clientX;\nthis.info.y = e.clientY;\n},\nmousedown: function (e) {\nif (hasLeftMouseButton(e)) {\nthis.save(e);\n}\n},\nclick: function (e) {\nif (hasLeftMouseButton(e)) {\nthis.forward(e);\n}\n},\ntouchstart: function (e) {\nthis.save(e.changedTouches[0]);\n},\ntouchend: function (e) {\nthis.forward(e.changedTouches[0]);\n},\nforward: function (e) {\nvar dx = Math.abs(e.clientX - this.info.x);\nvar dy = Math.abs(e.clientY - this.info.y);\nvar t = Gestures.findOriginalTarget(e);\nif (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {\nif (!this.info.prevent) {\nGestures.fire(t, 'tap', {\nx: e.clientX,\ny: e.clientY,\nsourceEvent: e\n});\n}\n}\n}\n});\nvar DIRECTION_MAP = {\nx: 'pan-x',\ny: 'pan-y',\nnone: 'none',\nall: 'auto'\n};\nPolymer.Base._addFeature({\n_listen: function (node, eventName, handler) {\nif (Gestures.gestures[eventName]) {\nGestures.add(node, eventName, handler);\n} else {\nnode.addEventListener(eventName, handler);\n}\n},\n_unlisten: function (node, eventName, handler) {\nif (Gestures.gestures[eventName]) {\nGestures.remove(node, eventName, handler);\n} else {\nnode.removeEventListener(eventName, handler);\n}\n},\nsetScrollDirection: function (direction, node) {\nnode = node || this;\nGestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');\n}\n});\nPolymer.Gestures = Gestures;\n}());\nPolymer.Async = {\n_currVal: 0,\n_lastVal: 0,\n_callbacks: [],\n_twiddleContent: 0,\n_twiddle: document.createTextNode(''),\nrun: function (callback, waitTime) {\nif (waitTime > 0) {\nreturn ~setTimeout(callback, waitTime);\n} else {\nthis._twiddle.textContent = this._twiddleContent++;\nthis._callbacks.push(callback);\nreturn this._currVal++;\n}\n},\ncancel: function (handle) {\nif (handle < 0) {\nclearTimeout(~handle);\n} else {\nvar idx = handle - this._lastVal;\nif (idx >= 0) {\nif (!this._callbacks[idx]) {\nthrow 'invalid async handle: ' + handle;\n}\nthis._callbacks[idx] = null;\n}\n}\n},\n_atEndOfMicrotask: function () {\nvar len = this._callbacks.length;\nfor (var i = 0; i < len; i++) {\nvar cb = this._callbacks[i];\nif (cb) {\ntry {\ncb();\n} catch (e) {\ni++;\nthis._callbacks.splice(0, i);\nthis._lastVal += i;\nthis._twiddle.textContent = this._twiddleContent++;\nthrow e;\n}\n}\n}\nthis._callbacks.splice(0, len);\nthis._lastVal += len;\n}\n};\nnew (window.MutationObserver || JsMutationObserver)(Polymer.Async._atEndOfMicrotask.bind(Polymer.Async)).observe(Polymer.Async._twiddle, { characterData: true });\nPolymer.Debounce = function () {\nvar Async = Polymer.Async;\nvar Debouncer = function (context) {\nthis.context = context;\nthis.boundComplete = this.complete.bind(this);\n};\nDebouncer.prototype = {\ngo: function (callback, wait) {\nvar h;\nthis.finish = function () {\nAsync.cancel(h);\n};\nh = Async.run(this.boundComplete, wait);\nthis.callback = callback;\n},\nstop: function () {\nif (this.finish) {\nthis.finish();\nthis.finish = null;\n}\n},\ncomplete: function () {\nif (this.finish) {\nthis.stop();\nthis.callback.call(this.context);\n}\n}\n};\nfunction debounce(debouncer, callback, wait) {\nif (debouncer) {\ndebouncer.stop();\n} else {\ndebouncer = new Debouncer(this);\n}\ndebouncer.go(callback, wait);\nreturn debouncer;\n}\nreturn debounce;\n}();\nPolymer.Base._addFeature({\n$$: function (slctr) {\nreturn Polymer.dom(this.root).querySelector(slctr);\n},\ntoggleClass: function (name, bool, node) {\nnode = node || this;\nif (arguments.length == 1) {\nbool = !node.classList.contains(name);\n}\nif (bool) {\nPolymer.dom(node).classList.add(name);\n} else {\nPolymer.dom(node).classList.remove(name);\n}\n},\ntoggleAttribute: function (name, bool, node) {\nnode = node || this;\nif (arguments.length == 1) {\nbool = !node.hasAttribute(name);\n}\nif (bool) {\nPolymer.dom(node).setAttribute(name, '');\n} else {\nPolymer.dom(node).removeAttribute(name);\n}\n},\nclassFollows: function (name, toElement, fromElement) {\nif (fromElement) {\nPolymer.dom(fromElement).classList.remove(name);\n}\nif (toElement) {\nPolymer.dom(toElement).classList.add(name);\n}\n},\nattributeFollows: function (name, toElement, fromElement) {\nif (fromElement) {\nPolymer.dom(fromElement).removeAttribute(name);\n}\nif (toElement) {\nPolymer.dom(toElement).setAttribute(name, '');\n}\n},\ngetContentChildNodes: function (slctr) {\nvar content = Polymer.dom(this.root).querySelector(slctr || 'content');\nreturn content ? Polymer.dom(content).getDistributedNodes() : [];\n},\ngetContentChildren: function (slctr) {\nreturn this.getContentChildNodes(slctr).filter(function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n},\nfire: function (type, detail, options) {\noptions = options || Polymer.nob;\nvar node = options.node || this;\nvar detail = detail === null || detail === undefined ? Polymer.nob : detail;\nvar bubbles = options.bubbles === undefined ? true : options.bubbles;\nvar cancelable = Boolean(options.cancelable);\nvar event = new CustomEvent(type, {\nbubbles: Boolean(bubbles),\ncancelable: cancelable,\ndetail: detail\n});\nnode.dispatchEvent(event);\nreturn event;\n},\nasync: function (callback, waitTime) {\nreturn Polymer.Async.run(callback.bind(this), waitTime);\n},\ncancelAsync: function (handle) {\nPolymer.Async.cancel(handle);\n},\narrayDelete: function (path, item) {\nvar index;\nif (Array.isArray(path)) {\nindex = path.indexOf(item);\nif (index >= 0) {\nreturn path.splice(index, 1);\n}\n} else {\nvar arr = this.get(path);\nindex = arr.indexOf(item);\nif (index >= 0) {\nreturn this.splice(path, index, 1);\n}\n}\n},\ntransform: function (transform, node) {\nnode = node || this;\nnode.style.webkitTransform = transform;\nnode.style.transform = transform;\n},\ntranslate3d: function (x, y, z, node) {\nnode = node || this;\nthis.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n},\nimportHref: function (href, onload, onerror) {\nvar l = document.createElement('link');\nl.rel = 'import';\nl.href = href;\nif (onload) {\nl.onload = onload.bind(this);\n}\nif (onerror) {\nl.onerror = onerror.bind(this);\n}\ndocument.head.appendChild(l);\nreturn l;\n},\ncreate: function (tag, props) {\nvar elt = document.createElement(tag);\nif (props) {\nfor (var n in props) {\nelt[n] = props[n];\n}\n}\nreturn elt;\n}\n});\nPolymer.Bind = {\nprepareModel: function (model) {\nmodel._propertyEffects = {};\nmodel._bindListeners = [];\nPolymer.Base.mixin(model, this._modelApi);\n},\n_modelApi: {\n_notifyChange: function (property) {\nvar eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';\nPolymer.Base.fire(eventName, { value: this[property] }, {\nbubbles: false,\nnode: this\n});\n},\n_propertySetter: function (property, value, effects, fromAbove) {\nvar old = this.__data__[property];\nif (old !== value && (old === old || value === value)) {\nthis.__data__[property] = value;\nif (typeof value == 'object') {\nthis._clearPath(property);\n}\nif (this._propertyChanged) {\nthis._propertyChanged(property, value, old);\n}\nif (effects) {\nthis._effectEffects(property, value, effects, old, fromAbove);\n}\n}\nreturn old;\n},\n__setProperty: function (property, value, quiet, node) {\nnode = node || this;\nvar effects = node._propertyEffects && node._propertyEffects[property];\nif (effects) {\nnode._propertySetter(property, value, effects, quiet);\n} else {\nnode[property] = value;\n}\n},\n_effectEffects: function (property, value, effects, old, fromAbove) {\neffects.forEach(function (fx) {\nvar fn = Polymer.Bind['_' + fx.kind + 'Effect'];\nif (fn) {\nfn.call(this, property, value, fx.effect, old, fromAbove);\n}\n}, this);\n},\n_clearPath: function (path) {\nfor (var prop in this.__data__) {\nif (prop.indexOf(path + '.') === 0) {\nthis.__data__[prop] = undefined;\n}\n}\n}\n},\nensurePropertyEffects: function (model, property) {\nvar fx = model._propertyEffects[property];\nif (!fx) {\nfx = model._propertyEffects[property] = [];\n}\nreturn fx;\n},\naddPropertyEffect: function (model, property, kind, effect) {\nvar fx = this.ensurePropertyEffects(model, property);\nfx.push({\nkind: kind,\neffect: effect\n});\n},\ncreateBindings: function (model) {\nvar fx$ = model._propertyEffects;\nif (fx$) {\nfor (var n in fx$) {\nvar fx = fx$[n];\nfx.sort(this._sortPropertyEffects);\nthis._createAccessors(model, n, fx);\n}\n}\n},\n_sortPropertyEffects: function () {\nvar EFFECT_ORDER = {\n'compute': 0,\n'annotation': 1,\n'computedAnnotation': 2,\n'reflect': 3,\n'notify': 4,\n'observer': 5,\n'complexObserver': 6,\n'function': 7\n};\nreturn function (a, b) {\nreturn EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];\n};\n}(),\n_createAccessors: function (model, property, effects) {\nvar defun = {\nget: function () {\nreturn this.__data__[property];\n}\n};\nvar setter = function (value) {\nthis._propertySetter(property, value, effects);\n};\nvar info = model.getPropertyInfo && model.getPropertyInfo(property);\nif (info && info.readOnly) {\nif (!info.computed) {\nmodel['_set' + this.upper(property)] = setter;\n}\n} else {\ndefun.set = setter;\n}\nObject.defineProperty(model, property, defun);\n},\nupper: function (name) {\nreturn name[0].toUpperCase() + name.substring(1);\n},\n_addAnnotatedListener: function (model, index, property, path, event) {\nvar fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);\nvar eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';\nmodel._bindListeners.push({\nindex: index,\nproperty: property,\npath: path,\nchangedFn: fn,\nevent: eventName\n});\n},\n_isStructured: function (path) {\nreturn path.indexOf('.') > 0;\n},\n_isEventBogus: function (e, target) {\nreturn e.path && e.path[0] !== target;\n},\n_notedListenerFactory: function (property, path, isStructured, bogusTest) {\nreturn function (e, target) {\nif (!bogusTest(e, target)) {\nif (e.detail && e.detail.path) {\nthis.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);\n} else {\nvar value = target[property];\nif (!isStructured) {\nthis[path] = target[property];\n} else {\nif (this.__data__[path] != value) {\nthis.set(path, value);\n}\n}\n}\n}\n};\n},\nprepareInstance: function (inst) {\ninst.__data__ = Object.create(null);\n},\nsetupBindListeners: function (inst) {\ninst._bindListeners.forEach(function (info) {\nvar node = inst._nodes[info.index];\nnode.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));\n});\n}\n};\nPolymer.Base.extend(Polymer.Bind, {\n_shouldAddListener: function (effect) {\nreturn effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';\n},\n_annotationEffect: function (source, value, effect) {\nif (source != effect.value) {\nvalue = this.get(effect.value);\nthis.__data__[effect.value] = value;\n}\nvar calc = effect.negate ? !value : value;\nif (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {\nreturn this._applyEffectValue(calc, effect);\n}\n},\n_reflectEffect: function (source) {\nthis.reflectPropertyToAttribute(source);\n},\n_notifyEffect: function (source, value, effect, old, fromAbove) {\nif (!fromAbove) {\nthis._notifyChange(source);\n}\n},\n_functionEffect: function (source, value, fn, old, fromAbove) {\nfn.call(this, source, value, old, fromAbove);\n},\n_observerEffect: function (source, value, effect, old) {\nvar fn = this[effect.method];\nif (fn) {\nfn.call(this, value, old);\n} else {\nthis._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));\n}\n},\n_complexObserverEffect: function (source, value, effect) {\nvar fn = this[effect.method];\nif (fn) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nfn.apply(this, args);\n}\n} else {\nthis._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));\n}\n},\n_computeEffect: function (source, value, effect) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nvar fn = this[effect.method];\nif (fn) {\nthis.__setProperty(effect.property, fn.apply(this, args));\n} else {\nthis._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));\n}\n}\n},\n_annotatedComputationEffect: function (source, value, effect) {\nvar computedHost = this._rootDataHost || this;\nvar fn = computedHost[effect.method];\nif (fn) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nvar computedvalue = fn.apply(computedHost, args);\nif (effect.negate) {\ncomputedvalue = !computedvalue;\n}\nthis._applyEffectValue(computedvalue, effect);\n}\n} else {\ncomputedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));\n}\n},\n_marshalArgs: function (model, effect, path, value) {\nvar values = [];\nvar args = effect.args;\nfor (var i = 0, l = args.length; i < l; i++) {\nvar arg = args[i];\nvar name = arg.name;\nvar v;\nif (arg.literal) {\nv = arg.value;\n} else if (arg.structured) {\nv = Polymer.Base.get(name, model);\n} else {\nv = model[name];\n}\nif (args.length > 1 && v === undefined) {\nreturn;\n}\nif (arg.wildcard) {\nvar baseChanged = name.indexOf(path + '.') === 0;\nvar matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;\nvalues[i] = {\npath: matches ? path : name,\nvalue: matches ? value : v,\nbase: v\n};\n} else {\nvalues[i] = v;\n}\n}\nreturn values;\n}\n});\nPolymer.Base._addFeature({\n_addPropertyEffect: function (property, kind, effect) {\nPolymer.Bind.addPropertyEffect(this, property, kind, effect);\n},\n_prepEffects: function () {\nPolymer.Bind.prepareModel(this);\nthis._addAnnotationEffects(this._notes);\n},\n_prepBindings: function () {\nPolymer.Bind.createBindings(this);\n},\n_addPropertyEffects: function (properties) {\nif (properties) {\nfor (var p in properties) {\nvar prop = properties[p];\nif (prop.observer) {\nthis._addObserverEffect(p, prop.observer);\n}\nif (prop.computed) {\nprop.readOnly = true;\nthis._addComputedEffect(p, prop.computed);\n}\nif (prop.notify) {\nthis._addPropertyEffect(p, 'notify');\n}\nif (prop.reflectToAttribute) {\nthis._addPropertyEffect(p, 'reflect');\n}\nif (prop.readOnly) {\nPolymer.Bind.ensurePropertyEffects(this, p);\n}\n}\n}\n},\n_addComputedEffect: function (name, expression) {\nvar sig = this._parseMethod(expression);\nsig.args.forEach(function (arg) {\nthis._addPropertyEffect(arg.model, 'compute', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: arg,\nproperty: name\n});\n}, this);\n},\n_addObserverEffect: function (property, observer) {\nthis._addPropertyEffect(property, 'observer', {\nmethod: observer,\nproperty: property\n});\n},\n_addComplexObserverEffects: function (observers) {\nif (observers) {\nobservers.forEach(function (observer) {\nthis._addComplexObserverEffect(observer);\n}, this);\n}\n},\n_addComplexObserverEffect: function (observer) {\nvar sig = this._parseMethod(observer);\nsig.args.forEach(function (arg) {\nthis._addPropertyEffect(arg.model, 'complexObserver', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: arg\n});\n}, this);\n},\n_addAnnotationEffects: function (notes) {\nthis._nodes = [];\nnotes.forEach(function (note) {\nvar index = this._nodes.push(note) - 1;\nnote.bindings.forEach(function (binding) {\nthis._addAnnotationEffect(binding, index);\n}, this);\n}, this);\n},\n_addAnnotationEffect: function (note, index) {\nif (Polymer.Bind._shouldAddListener(note)) {\nPolymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);\n}\nif (note.signature) {\nthis._addAnnotatedComputationEffect(note, index);\n} else {\nnote.index = index;\nthis._addPropertyEffect(note.model, 'annotation', note);\n}\n},\n_addAnnotatedComputationEffect: function (note, index) {\nvar sig = note.signature;\nif (sig.static) {\nthis.__addAnnotatedComputationEffect('__static__', index, note, sig, null);\n} else {\nsig.args.forEach(function (arg) {\nif (!arg.literal) {\nthis.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);\n}\n}, this);\n}\n},\n__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {\nthis._addPropertyEffect(property, 'annotatedComputation', {\nindex: index,\nkind: note.kind,\nproperty: note.name,\nnegate: note.negate,\nmethod: sig.method,\nargs: sig.args,\ntrigger: trigger\n});\n},\n_parseMethod: function (expression) {\nvar m = expression.match(/([^\\s]+)\\((.*)\\)/);\nif (m) {\nvar sig = {\nmethod: m[1],\nstatic: true\n};\nif (m[2].trim()) {\nvar args = m[2].replace(/\\\\,/g, '&comma;').split(',');\nreturn this._parseArgs(args, sig);\n} else {\nsig.args = Polymer.nar;\nreturn sig;\n}\n}\n},\n_parseArgs: function (argList, sig) {\nsig.args = argList.map(function (rawArg) {\nvar arg = this._parseArg(rawArg);\nif (!arg.literal) {\nsig.static = false;\n}\nreturn arg;\n}, this);\nreturn sig;\n},\n_parseArg: function (rawArg) {\nvar arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\\\(.)/g, '$1');\nvar a = {\nname: arg,\nmodel: this._modelForPath(arg)\n};\nvar fc = arg[0];\nif (fc === '-') {\nfc = arg[1];\n}\nif (fc >= '0' && fc <= '9') {\nfc = '#';\n}\nswitch (fc) {\ncase '\\'':\ncase '\"':\na.value = arg.slice(1, -1);\na.literal = true;\nbreak;\ncase '#':\na.value = Number(arg);\na.literal = true;\nbreak;\n}\nif (!a.literal) {\na.structured = arg.indexOf('.') > 0;\nif (a.structured) {\na.wildcard = arg.slice(-2) == '.*';\nif (a.wildcard) {\na.name = arg.slice(0, -2);\n}\n}\n}\nreturn a;\n},\n_marshalInstanceEffects: function () {\nPolymer.Bind.prepareInstance(this);\nPolymer.Bind.setupBindListeners(this);\n},\n_applyEffectValue: function (value, info) {\nvar node = this._nodes[info.index];\nvar property = info.property || info.name || 'textContent';\nif (info.kind == 'attribute') {\nthis.serializeValueToAttribute(value, property, node);\n} else {\nif (property === 'className') {\nvalue = this._scopeElementClass(node, value);\n}\nif (property === 'textContent' || node.localName == 'input' && property == 'value') {\nvalue = value == undefined ? '' : value;\n}\nreturn node[property] = value;\n}\n},\n_executeStaticEffects: function () {\nif (this._propertyEffects.__static__) {\nthis._effectEffects('__static__', null, this._propertyEffects.__static__);\n}\n}\n});\nPolymer.Base._addFeature({\n_setupConfigure: function (initialConfig) {\nthis._config = {};\nfor (var i in initialConfig) {\nif (initialConfig[i] !== undefined) {\nthis._config[i] = initialConfig[i];\n}\n}\nthis._handlers = [];\n},\n_marshalAttributes: function () {\nthis._takeAttributesToModel(this._config);\n},\n_attributeChangedImpl: function (name) {\nvar model = this._clientsReadied ? this : this._config;\nthis._setAttributeToProperty(model, name);\n},\n_configValue: function (name, value) {\nthis._config[name] = value;\n},\n_beforeClientsReady: function () {\nthis._configure();\n},\n_configure: function () {\nthis._configureAnnotationReferences();\nthis._aboveConfig = this.mixin({}, this._config);\nvar config = {};\nthis.behaviors.forEach(function (b) {\nthis._configureProperties(b.properties, config);\n}, this);\nthis._configureProperties(this.properties, config);\nthis._mixinConfigure(config, this._aboveConfig);\nthis._config = config;\nthis._distributeConfig(this._config);\n},\n_configureProperties: function (properties, config) {\nfor (var i in properties) {\nvar c = properties[i];\nif (c.value !== undefined) {\nvar value = c.value;\nif (typeof value == 'function') {\nvalue = value.call(this, this._config);\n}\nconfig[i] = value;\n}\n}\n},\n_mixinConfigure: function (a, b) {\nfor (var prop in b) {\nif (!this.getPropertyInfo(prop).readOnly) {\na[prop] = b[prop];\n}\n}\n},\n_distributeConfig: function (config) {\nvar fx$ = this._propertyEffects;\nif (fx$) {\nfor (var p in config) {\nvar fx = fx$[p];\nif (fx) {\nfor (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {\nif (x.kind === 'annotation') {\nvar node = this._nodes[x.effect.index];\nif (node._configValue) {\nvar value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);\nnode._configValue(x.effect.name, value);\n}\n}\n}\n}\n}\n}\n},\n_afterClientsReady: function () {\nthis._executeStaticEffects();\nthis._applyConfig(this._config, this._aboveConfig);\nthis._flushHandlers();\n},\n_applyConfig: function (config, aboveConfig) {\nfor (var n in config) {\nif (this[n] === undefined) {\nthis.__setProperty(n, config[n], n in aboveConfig);\n}\n}\n},\n_notifyListener: function (fn, e) {\nif (!this._clientsReadied) {\nthis._queueHandler([\nfn,\ne,\ne.target\n]);\n} else {\nreturn fn.call(this, e, e.target);\n}\n},\n_queueHandler: function (args) {\nthis._handlers.push(args);\n},\n_flushHandlers: function () {\nvar h$ = this._handlers;\nfor (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {\nh[0].call(this, h[1], h[2]);\n}\nthis._handlers = [];\n}\n});\n(function () {\n'use strict';\nPolymer.Base._addFeature({\nnotifyPath: function (path, value, fromAbove) {\nvar old = this._propertySetter(path, value);\nif (old !== value && (old === old || value === value)) {\nthis._pathEffector(path, value);\nif (!fromAbove) {\nthis._notifyPath(path, value);\n}\nreturn true;\n}\n},\n_getPathParts: function (path) {\nif (Array.isArray(path)) {\nvar parts = [];\nfor (var i = 0; i < path.length; i++) {\nvar args = path[i].toString().split('.');\nfor (var j = 0; j < args.length; j++) {\nparts.push(args[j]);\n}\n}\nreturn parts;\n} else {\nreturn path.toString().split('.');\n}\n},\nset: function (path, value, root) {\nvar prop = root || this;\nvar parts = this._getPathParts(path);\nvar array;\nvar last = parts[parts.length - 1];\nif (parts.length > 1) {\nfor (var i = 0; i < parts.length - 1; i++) {\nvar part = parts[i];\nprop = prop[part];\nif (array && parseInt(part) == part) {\nparts[i] = Polymer.Collection.get(array).getKey(prop);\n}\nif (!prop) {\nreturn;\n}\narray = Array.isArray(prop) ? prop : null;\n}\nif (array && parseInt(last) == last) {\nvar coll = Polymer.Collection.get(array);\nvar old = prop[last];\nvar key = coll.getKey(old);\nparts[i] = key;\ncoll.setItem(key, value);\n}\nprop[last] = value;\nif (!root) {\nthis.notifyPath(parts.join('.'), value);\n}\n} else {\nprop[path] = value;\n}\n},\nget: function (path, root) {\nvar prop = root || this;\nvar parts = this._getPathParts(path);\nvar last = parts.pop();\nwhile (parts.length) {\nprop = prop[parts.shift()];\nif (!prop) {\nreturn;\n}\n}\nreturn prop[last];\n},\n_pathEffector: function (path, value) {\nvar model = this._modelForPath(path);\nvar fx$ = this._propertyEffects[model];\nif (fx$) {\nfx$.forEach(function (fx) {\nvar fxFn = this['_' + fx.kind + 'PathEffect'];\nif (fxFn) {\nfxFn.call(this, path, value, fx.effect);\n}\n}, this);\n}\nif (this._boundPaths) {\nthis._notifyBoundPaths(path, value);\n}\n},\n_annotationPathEffect: function (path, value, effect) {\nif (effect.value === path || effect.value.indexOf(path + '.') === 0) {\nPolymer.Bind._annotationEffect.call(this, path, value, effect);\n} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {\nvar node = this._nodes[effect.index];\nif (node && node.notifyPath) {\nvar p = this._fixPath(effect.name, effect.value, path);\nnode.notifyPath(p, value, true);\n}\n}\n},\n_complexObserverPathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._complexObserverEffect.call(this, path, value, effect);\n}\n},\n_computePathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._computeEffect.call(this, path, value, effect);\n}\n},\n_annotatedComputationPathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._annotatedComputationEffect.call(this, path, value, effect);\n}\n},\n_pathMatchesEffect: function (path, effect) {\nvar effectArg = effect.trigger.name;\nreturn effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;\n},\nlinkPaths: function (to, from) {\nthis._boundPaths = this._boundPaths || {};\nif (from) {\nthis._boundPaths[to] = from;\n} else {\nthis.unlinkPaths(to);\n}\n},\nunlinkPaths: function (path) {\nif (this._boundPaths) {\ndelete this._boundPaths[path];\n}\n},\n_notifyBoundPaths: function (path, value) {\nfor (var a in this._boundPaths) {\nvar b = this._boundPaths[a];\nif (path.indexOf(a + '.') == 0) {\nthis.notifyPath(this._fixPath(b, a, path), value);\n} else if (path.indexOf(b + '.') == 0) {\nthis.notifyPath(this._fixPath(a, b, path), value);\n}\n}\n},\n_fixPath: function (property, root, path) {\nreturn property + path.slice(root.length);\n},\n_notifyPath: function (path, value) {\nvar rootName = this._modelForPath(path);\nvar dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);\nvar eventName = dashCaseName + this._EVENT_CHANGED;\nthis.fire(eventName, {\npath: path,\nvalue: value\n}, { bubbles: false });\n},\n_modelForPath: function (path) {\nvar dot = path.indexOf('.');\nreturn dot < 0 ? path : path.slice(0, dot);\n},\n_EVENT_CHANGED: '-changed',\n_notifySplice: function (array, path, index, added, removed) {\nvar splices = [{\nindex: index,\naddedCount: added,\nremoved: removed,\nobject: array,\ntype: 'splice'\n}];\nvar change = {\nkeySplices: Polymer.Collection.applySplices(array, splices),\nindexSplices: splices\n};\nthis.set(path + '.splices', change);\nif (added != removed.length) {\nthis.notifyPath(path + '.length', array.length);\n}\nchange.keySplices = null;\nchange.indexSplices = null;\n},\npush: function (path) {\nvar array = this.get(path);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar len = array.length;\nvar ret = array.push.apply(array, args);\nif (args.length) {\nthis._notifySplice(array, path, len, args.length, []);\n}\nreturn ret;\n},\npop: function (path) {\nvar array = this.get(path);\nvar hadLength = Boolean(array.length);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.pop.apply(array, args);\nif (hadLength) {\nthis._notifySplice(array, path, array.length, 0, [ret]);\n}\nreturn ret;\n},\nsplice: function (path, start, deleteCount) {\nvar array = this.get(path);\nif (start < 0) {\nstart = array.length - Math.floor(-start);\n} else {\nstart = Math.floor(start);\n}\nif (!start) {\nstart = 0;\n}\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.splice.apply(array, args);\nvar addedCount = Math.max(args.length - 2, 0);\nif (addedCount || ret.length) {\nthis._notifySplice(array, path, start, addedCount, ret);\n}\nreturn ret;\n},\nshift: function (path) {\nvar array = this.get(path);\nvar hadLength = Boolean(array.length);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.shift.apply(array, args);\nif (hadLength) {\nthis._notifySplice(array, path, 0, 0, [ret]);\n}\nreturn ret;\n},\nunshift: function (path) {\nvar array = this.get(path);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.unshift.apply(array, args);\nif (args.length) {\nthis._notifySplice(array, path, 0, args.length, []);\n}\nreturn ret;\n}\n});\n}());\nPolymer.Base._addFeature({\nresolveUrl: function (url) {\nvar module = Polymer.DomModule.import(this.is);\nvar root = '';\nif (module) {\nvar assetPath = module.getAttribute('assetpath') || '';\nroot = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);\n}\nreturn Polymer.ResolveUrl.resolveUrl(url, root);\n}\n});\nPolymer.CssParse = function () {\nvar api = {\nparse: function (text) {\ntext = this._clean(text);\nreturn this._parseCss(this._lex(text), text);\n},\n_clean: function (cssText) {\nreturn cssText.replace(this._rx.comments, '').replace(this._rx.port, '');\n},\n_lex: function (text) {\nvar root = {\nstart: 0,\nend: text.length\n};\nvar n = root;\nfor (var i = 0, s = 0, l = text.length; i < l; i++) {\nswitch (text[i]) {\ncase this.OPEN_BRACE:\nif (!n.rules) {\nn.rules = [];\n}\nvar p = n;\nvar previous = p.rules[p.rules.length - 1];\nn = {\nstart: i + 1,\nparent: p,\nprevious: previous\n};\np.rules.push(n);\nbreak;\ncase this.CLOSE_BRACE:\nn.end = i + 1;\nn = n.parent || root;\nbreak;\n}\n}\nreturn root;\n},\n_parseCss: function (node, text) {\nvar t = text.substring(node.start, node.end - 1);\nnode.parsedCssText = node.cssText = t.trim();\nif (node.parent) {\nvar ss = node.previous ? node.previous.end : node.parent.start;\nt = text.substring(ss, node.start - 1);\nt = t.substring(t.lastIndexOf(';') + 1);\nvar s = node.parsedSelector = node.selector = t.trim();\nnode.atRule = s.indexOf(this.AT_START) === 0;\nif (node.atRule) {\nif (s.indexOf(this.MEDIA_START) === 0) {\nnode.type = this.types.MEDIA_RULE;\n} else if (s.match(this._rx.keyframesRule)) {\nnode.type = this.types.KEYFRAMES_RULE;\n}\n} else {\nif (s.indexOf(this.VAR_START) === 0) {\nnode.type = this.types.MIXIN_RULE;\n} else {\nnode.type = this.types.STYLE_RULE;\n}\n}\n}\nvar r$ = node.rules;\nif (r$) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\nthis._parseCss(r, text);\n}\n}\nreturn node;\n},\nstringify: function (node, preserveProperties, text) {\ntext = text || '';\nvar cssText = '';\nif (node.cssText || node.rules) {\nvar r$ = node.rules;\nif (r$ && (preserveProperties || !this._hasMixinRules(r$))) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\ncssText = this.stringify(r, preserveProperties, cssText);\n}\n} else {\ncssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);\ncssText = cssText.trim();\nif (cssText) {\ncssText = '  ' + cssText + '\\n';\n}\n}\n}\nif (cssText) {\nif (node.selector) {\ntext += node.selector + ' ' + this.OPEN_BRACE + '\\n';\n}\ntext += cssText;\nif (node.selector) {\ntext += this.CLOSE_BRACE + '\\n\\n';\n}\n}\nreturn text;\n},\n_hasMixinRules: function (rules) {\nreturn rules[0].selector.indexOf(this.VAR_START) >= 0;\n},\nremoveCustomProps: function (cssText) {\ncssText = this.removeCustomPropAssignment(cssText);\nreturn this.removeCustomPropApply(cssText);\n},\nremoveCustomPropAssignment: function (cssText) {\nreturn cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');\n},\nremoveCustomPropApply: function (cssText) {\nreturn cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');\n},\ntypes: {\nSTYLE_RULE: 1,\nKEYFRAMES_RULE: 7,\nMEDIA_RULE: 4,\nMIXIN_RULE: 1000\n},\nOPEN_BRACE: '{',\nCLOSE_BRACE: '}',\n_rx: {\ncomments: /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim,\nport: /@import[^;]*;/gim,\ncustomProp: /(?:^|[\\s;])--[^;{]*?:[^{};]*?(?:[;\\n]|$)/gim,\nmixinProp: /(?:^|[\\s;])--[^;{]*?:[^{;]*?{[^}]*?}(?:[;\\n]|$)?/gim,\nmixinApply: /@apply[\\s]*\\([^)]*?\\)[\\s]*(?:[;\\n]|$)?/gim,\nvarApply: /[^;:]*?:[^;]*var[^;]*(?:[;\\n]|$)?/gim,\nkeyframesRule: /^@[^\\s]*keyframes/\n},\nVAR_START: '--',\nMEDIA_START: '@media',\nAT_START: '@'\n};\nreturn api;\n}();\nPolymer.StyleUtil = function () {\nreturn {\nMODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',\nINCLUDE_ATTR: 'include',\ntoCssText: function (rules, callback, preserveProperties) {\nif (typeof rules === 'string') {\nrules = this.parser.parse(rules);\n}\nif (callback) {\nthis.forEachStyleRule(rules, callback);\n}\nreturn this.parser.stringify(rules, preserveProperties);\n},\nforRulesInStyles: function (styles, callback) {\nif (styles) {\nfor (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\nthis.forEachStyleRule(this.rulesForStyle(s), callback);\n}\n}\n},\nrulesForStyle: function (style) {\nif (!style.__cssRules && style.textContent) {\nstyle.__cssRules = this.parser.parse(style.textContent);\n}\nreturn style.__cssRules;\n},\nclearStyleRules: function (style) {\nstyle.__cssRules = null;\n},\nforEachStyleRule: function (node, callback) {\nif (!node) {\nreturn;\n}\nvar s = node.parsedSelector;\nvar skipRules = false;\nif (node.type === this.ruleTypes.STYLE_RULE) {\ncallback(node);\n} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {\nskipRules = true;\n}\nvar r$ = node.rules;\nif (r$ && !skipRules) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\nthis.forEachStyleRule(r, callback);\n}\n}\n},\napplyCss: function (cssText, moniker, target, afterNode) {\nvar style = document.createElement('style');\nif (moniker) {\nstyle.setAttribute('scope', moniker);\n}\nstyle.textContent = cssText;\ntarget = target || document.head;\nif (!afterNode) {\nvar n$ = target.querySelectorAll('style[scope]');\nafterNode = n$[n$.length - 1];\n}\ntarget.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);\nreturn style;\n},\ncssFromModules: function (moduleIds, warnIfNotFound) {\nvar modules = moduleIds.trim().split(' ');\nvar cssText = '';\nfor (var i = 0; i < modules.length; i++) {\ncssText += this.cssFromModule(modules[i], warnIfNotFound);\n}\nreturn cssText;\n},\ncssFromModule: function (moduleId, warnIfNotFound) {\nvar m = Polymer.DomModule.import(moduleId);\nif (m && !m._cssText) {\nm._cssText = this._cssFromElement(m);\n}\nif (!m && warnIfNotFound) {\nconsole.warn('Could not find style data in module named', moduleId);\n}\nreturn m && m._cssText || '';\n},\n_cssFromElement: function (element) {\nvar cssText = '';\nvar content = element.content || element;\nvar e$ = Array.prototype.slice.call(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));\nfor (var i = 0, e; i < e$.length; i++) {\ne = e$[i];\nif (e.localName === 'template') {\ncssText += this._cssFromElement(e);\n} else {\nif (e.localName === 'style') {\nvar include = e.getAttribute(this.INCLUDE_ATTR);\nif (include) {\ncssText += this.cssFromModules(include, true);\n}\ne = e.__appliedElement || e;\ne.parentNode.removeChild(e);\ncssText += this.resolveCss(e.textContent, element.ownerDocument);\n} else if (e.import && e.import.body) {\ncssText += this.resolveCss(e.import.body.textContent, e.import);\n}\n}\n}\nreturn cssText;\n},\nresolveCss: Polymer.ResolveUrl.resolveCss,\nparser: Polymer.CssParse,\nruleTypes: Polymer.CssParse.types\n};\n}();\nPolymer.StyleTransformer = function () {\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar styleUtil = Polymer.StyleUtil;\nvar api = {\ndom: function (node, scope, useAttr, shouldRemoveScope) {\nthis._transformDom(node, scope || '', useAttr, shouldRemoveScope);\n},\n_transformDom: function (node, selector, useAttr, shouldRemoveScope) {\nif (node.setAttribute) {\nthis.element(node, selector, useAttr, shouldRemoveScope);\n}\nvar c$ = Polymer.dom(node).childNodes;\nfor (var i = 0; i < c$.length; i++) {\nthis._transformDom(c$[i], selector, useAttr, shouldRemoveScope);\n}\n},\nelement: function (element, scope, useAttr, shouldRemoveScope) {\nif (useAttr) {\nif (shouldRemoveScope) {\nelement.removeAttribute(SCOPE_NAME);\n} else {\nelement.setAttribute(SCOPE_NAME, scope);\n}\n} else {\nif (scope) {\nif (element.classList) {\nif (shouldRemoveScope) {\nelement.classList.remove(SCOPE_NAME);\nelement.classList.remove(scope);\n} else {\nelement.classList.add(SCOPE_NAME);\nelement.classList.add(scope);\n}\n} else if (element.getAttribute) {\nvar c = element.getAttribute(CLASS);\nif (shouldRemoveScope) {\nif (c) {\nelement.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n}\n} else {\nelement.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);\n}\n}\n}\n}\n},\nelementStyles: function (element, callback) {\nvar styles = element._styles;\nvar cssText = '';\nfor (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {\nvar rules = styleUtil.rulesForStyle(s);\ncssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\\n\\n';\n}\nreturn cssText.trim();\n},\ncss: function (rules, scope, ext, callback, useAttr) {\nvar hostScope = this._calcHostScope(scope, ext);\nscope = this._calcElementScope(scope, useAttr);\nvar self = this;\nreturn styleUtil.toCssText(rules, function (rule) {\nif (!rule.isScoped) {\nself.rule(rule, scope, hostScope);\nrule.isScoped = true;\n}\nif (callback) {\ncallback(rule, scope, hostScope);\n}\n});\n},\n_calcElementScope: function (scope, useAttr) {\nif (scope) {\nreturn useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;\n} else {\nreturn '';\n}\n},\n_calcHostScope: function (scope, ext) {\nreturn ext ? '[is=' + scope + ']' : scope;\n},\nrule: function (rule, scope, hostScope) {\nthis._transformRule(rule, this._transformComplexSelector, scope, hostScope);\n},\n_transformRule: function (rule, transformer, scope, hostScope) {\nvar p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\nfor (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\np$[i] = transformer.call(this, p, scope, hostScope);\n}\nrule.selector = rule.transformedSelector = p$.join(COMPLEX_SELECTOR_SEP);\n},\n_transformComplexSelector: function (selector, scope, hostScope) {\nvar stop = false;\nvar hostContext = false;\nvar self = this;\nselector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\nif (!stop) {\nvar info = self._transformCompoundSelector(s, c, scope, hostScope);\nstop = stop || info.stop;\nhostContext = hostContext || info.hostContext;\nc = info.combinator;\ns = info.value;\n} else {\ns = s.replace(SCOPE_JUMP, ' ');\n}\nreturn c + s;\n});\nif (hostContext) {\nselector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {\nreturn pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;\n});\n}\nreturn selector;\n},\n_transformCompoundSelector: function (selector, combinator, scope, hostScope) {\nvar jumpIndex = selector.search(SCOPE_JUMP);\nvar hostContext = false;\nif (selector.indexOf(HOST_CONTEXT) >= 0) {\nhostContext = true;\n} else if (selector.indexOf(HOST) >= 0) {\nselector = selector.replace(HOST_PAREN, function (m, host, paren) {\nreturn hostScope + paren;\n});\nselector = selector.replace(HOST, hostScope);\n} else if (jumpIndex !== 0) {\nselector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n}\nif (selector.indexOf(CONTENT) >= 0) {\ncombinator = '';\n}\nvar stop;\nif (jumpIndex >= 0) {\nselector = selector.replace(SCOPE_JUMP, ' ');\nstop = true;\n}\nreturn {\nvalue: selector,\ncombinator: combinator,\nstop: stop,\nhostContext: hostContext\n};\n},\n_transformSimpleSelector: function (selector, scope) {\nvar p$ = selector.split(PSEUDO_PREFIX);\np$[0] += scope;\nreturn p$.join(PSEUDO_PREFIX);\n},\ndocumentRule: function (rule) {\nrule.selector = rule.parsedSelector;\nthis.normalizeRootSelector(rule);\nif (!nativeShadow) {\nthis._transformRule(rule, this._transformDocumentSelector);\n}\n},\nnormalizeRootSelector: function (rule) {\nif (rule.selector === ROOT) {\nrule.selector = 'body';\n}\n},\n_transformDocumentSelector: function (selector) {\nreturn selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n},\nSCOPE_NAME: 'style-scope'\n};\nvar SCOPE_NAME = api.SCOPE_NAME;\nvar SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';\nvar COMPLEX_SELECTOR_SEP = ',';\nvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)([^\\s>+~]+)/g;\nvar HOST = ':host';\nvar ROOT = ':root';\nvar HOST_PAREN = /(\\:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/g;\nvar HOST_CONTEXT = ':host-context';\nvar HOST_CONTEXT_PAREN = /(.*)(?:\\:host-context)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))(.*)/;\nvar CONTENT = '::content';\nvar SCOPE_JUMP = /\\:\\:content|\\:\\:shadow|\\/deep\\//;\nvar CSS_CLASS_PREFIX = '.';\nvar CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';\nvar CSS_ATTR_SUFFIX = ']';\nvar PSEUDO_PREFIX = ':';\nvar CLASS = 'class';\nreturn api;\n}();\nPolymer.StyleExtends = function () {\nvar styleUtil = Polymer.StyleUtil;\nreturn {\nhasExtends: function (cssText) {\nreturn Boolean(cssText.match(this.rx.EXTEND));\n},\ntransform: function (style) {\nvar rules = styleUtil.rulesForStyle(style);\nvar self = this;\nstyleUtil.forEachStyleRule(rules, function (rule) {\nvar map = self._mapRule(rule);\nif (rule.parent) {\nvar m;\nwhile (m = self.rx.EXTEND.exec(rule.cssText)) {\nvar extend = m[1];\nvar extendor = self._findExtendor(extend, rule);\nif (extendor) {\nself._extendRule(rule, extendor);\n}\n}\n}\nrule.cssText = rule.cssText.replace(self.rx.EXTEND, '');\n});\nreturn styleUtil.toCssText(rules, function (rule) {\nif (rule.selector.match(self.rx.STRIP)) {\nrule.cssText = '';\n}\n}, true);\n},\n_mapRule: function (rule) {\nif (rule.parent) {\nvar map = rule.parent.map || (rule.parent.map = {});\nvar parts = rule.selector.split(',');\nfor (var i = 0, p; i < parts.length; i++) {\np = parts[i];\nmap[p.trim()] = rule;\n}\nreturn map;\n}\n},\n_findExtendor: function (extend, rule) {\nreturn rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);\n},\n_extendRule: function (target, source) {\nif (target.parent !== source.parent) {\nthis._cloneAndAddRuleToParent(source, target.parent);\n}\ntarget.extends = target.extends || (target.extends = []);\ntarget.extends.push(source);\nsource.selector = source.selector.replace(this.rx.STRIP, '');\nsource.selector = (source.selector && source.selector + ',\\n') + target.selector;\nif (source.extends) {\nsource.extends.forEach(function (e) {\nthis._extendRule(target, e);\n}, this);\n}\n},\n_cloneAndAddRuleToParent: function (rule, parent) {\nrule = Object.create(rule);\nrule.parent = parent;\nif (rule.extends) {\nrule.extends = rule.extends.slice();\n}\nparent.rules.push(rule);\n},\nrx: {\nEXTEND: /@extends\\(([^)]*)\\)\\s*?;/gim,\nSTRIP: /%[^,]*$/\n}\n};\n}();\n(function () {\nvar prepElement = Polymer.Base._prepElement;\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar styleUtil = Polymer.StyleUtil;\nvar styleTransformer = Polymer.StyleTransformer;\nvar styleExtends = Polymer.StyleExtends;\nPolymer.Base._addFeature({\n_prepElement: function (element) {\nif (this._encapsulateStyle) {\nstyleTransformer.element(element, this.is, this._scopeCssViaAttr);\n}\nprepElement.call(this, element);\n},\n_prepStyles: function () {\nif (this._encapsulateStyle === undefined) {\nthis._encapsulateStyle = !nativeShadow && Boolean(this._template);\n}\nthis._styles = this._collectStyles();\nvar cssText = styleTransformer.elementStyles(this);\nif (cssText && this._template) {\nvar style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);\nif (!nativeShadow) {\nthis._scopeStyle = style;\n}\n}\n},\n_collectStyles: function () {\nvar styles = [];\nvar cssText = '', m$ = this.styleModules;\nif (m$) {\nfor (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {\ncssText += styleUtil.cssFromModule(m);\n}\n}\ncssText += styleUtil.cssFromModule(this.is);\nif (cssText) {\nvar style = document.createElement('style');\nstyle.textContent = cssText;\nif (styleExtends.hasExtends(style.textContent)) {\ncssText = styleExtends.transform(style);\n}\nstyles.push(style);\n}\nreturn styles;\n},\n_elementAdd: function (node) {\nif (this._encapsulateStyle) {\nif (node.__styleScoped) {\nnode.__styleScoped = false;\n} else {\nstyleTransformer.dom(node, this.is, this._scopeCssViaAttr);\n}\n}\n},\n_elementRemove: function (node) {\nif (this._encapsulateStyle) {\nstyleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);\n}\n},\nscopeSubtree: function (container, shouldObserve) {\nif (nativeShadow) {\nreturn;\n}\nvar self = this;\nvar scopify = function (node) {\nif (node.nodeType === Node.ELEMENT_NODE) {\nnode.className = self._scopeElementClass(node, node.className);\nvar n$ = node.querySelectorAll('*');\nArray.prototype.forEach.call(n$, function (n) {\nn.className = self._scopeElementClass(n, n.className);\n});\n}\n};\nscopify(container);\nif (shouldObserve) {\nvar mo = new MutationObserver(function (mxns) {\nmxns.forEach(function (m) {\nif (m.addedNodes) {\nfor (var i = 0; i < m.addedNodes.length; i++) {\nscopify(m.addedNodes[i]);\n}\n}\n});\n});\nmo.observe(container, {\nchildList: true,\nsubtree: true\n});\nreturn mo;\n}\n}\n});\n}());\nPolymer.StyleProperties = function () {\n'use strict';\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar matchesSelector = Polymer.DomApi.matchesSelector;\nvar styleUtil = Polymer.StyleUtil;\nvar styleTransformer = Polymer.StyleTransformer;\nreturn {\ndecorateStyles: function (styles) {\nvar self = this, props = {};\nstyleUtil.forRulesInStyles(styles, function (rule) {\nself.decorateRule(rule);\nself.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n});\nvar names = [];\nfor (var i in props) {\nnames.push(i);\n}\nreturn names;\n},\ndecorateRule: function (rule) {\nif (rule.propertyInfo) {\nreturn rule.propertyInfo;\n}\nvar info = {}, properties = {};\nvar hasProperties = this.collectProperties(rule, properties);\nif (hasProperties) {\ninfo.properties = properties;\nrule.rules = null;\n}\ninfo.cssText = this.collectCssText(rule);\nrule.propertyInfo = info;\nreturn info;\n},\ncollectProperties: function (rule, properties) {\nvar info = rule.propertyInfo;\nif (info) {\nif (info.properties) {\nPolymer.Base.mixin(properties, info.properties);\nreturn true;\n}\n} else {\nvar m, rx = this.rx.VAR_ASSIGN;\nvar cssText = rule.parsedCssText;\nvar any;\nwhile (m = rx.exec(cssText)) {\nproperties[m[1]] = (m[2] || m[3]).trim();\nany = true;\n}\nreturn any;\n}\n},\ncollectCssText: function (rule) {\nvar customCssText = '';\nvar cssText = rule.parsedCssText;\ncssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\nvar parts = cssText.split(';');\nfor (var i = 0, p; i < parts.length; i++) {\np = parts[i];\nif (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {\ncustomCssText += p + ';\\n';\n}\n}\nreturn customCssText;\n},\ncollectPropertiesInCssText: function (cssText, props) {\nvar m;\nwhile (m = this.rx.VAR_CAPTURE.exec(cssText)) {\nprops[m[1]] = true;\nvar def = m[2];\nif (def && def.match(this.rx.IS_VAR)) {\nprops[def] = true;\n}\n}\n},\nreify: function (props) {\nvar names = Object.getOwnPropertyNames(props);\nfor (var i = 0, n; i < names.length; i++) {\nn = names[i];\nprops[n] = this.valueForProperty(props[n], props);\n}\n},\nvalueForProperty: function (property, props) {\nif (property) {\nif (property.indexOf(';') >= 0) {\nproperty = this.valueForProperties(property, props);\n} else {\nvar self = this;\nvar fn = function (all, prefix, value, fallback) {\nvar propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);\nreturn prefix + (propertyValue || '');\n};\nproperty = property.replace(this.rx.VAR_MATCH, fn);\n}\n}\nreturn property && property.trim() || '';\n},\nvalueForProperties: function (property, props) {\nvar parts = property.split(';');\nfor (var i = 0, p, m; i < parts.length; i++) {\nif (p = parts[i]) {\nm = p.match(this.rx.MIXIN_MATCH);\nif (m) {\np = this.valueForProperty(props[m[1]], props);\n} else {\nvar pp = p.split(':');\nif (pp[1]) {\npp[1] = pp[1].trim();\npp[1] = this.valueForProperty(pp[1], props) || pp[1];\n}\np = pp.join(':');\n}\nparts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';\n}\n}\nreturn parts.join(';');\n},\napplyProperties: function (rule, props) {\nvar output = '';\nif (!rule.propertyInfo) {\nthis.decorateRule(rule);\n}\nif (rule.propertyInfo.cssText) {\noutput = this.valueForProperties(rule.propertyInfo.cssText, props);\n}\nrule.cssText = output;\n},\npropertyDataFromStyles: function (styles, element) {\nvar props = {}, self = this;\nvar o = [], i = 0;\nstyleUtil.forRulesInStyles(styles, function (rule) {\nif (!rule.propertyInfo) {\nself.decorateRule(rule);\n}\nif (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.transformedSelector || rule.parsedSelector)) {\nself.collectProperties(rule, props);\naddToBitMask(i, o);\n}\ni++;\n});\nreturn {\nproperties: props,\nkey: o\n};\n},\nscopePropertiesFromStyles: function (styles) {\nif (!styles._scopeStyleProperties) {\nstyles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);\n}\nreturn styles._scopeStyleProperties;\n},\nhostPropertiesFromStyles: function (styles) {\nif (!styles._hostStyleProperties) {\nstyles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);\n}\nreturn styles._hostStyleProperties;\n},\nselectedPropertiesFromStyles: function (styles, selectors) {\nvar props = {}, self = this;\nstyleUtil.forRulesInStyles(styles, function (rule) {\nif (!rule.propertyInfo) {\nself.decorateRule(rule);\n}\nfor (var i = 0; i < selectors.length; i++) {\nif (rule.parsedSelector === selectors[i]) {\nself.collectProperties(rule, props);\nreturn;\n}\n}\n});\nreturn props;\n},\ntransformStyles: function (element, properties, scopeSelector) {\nvar self = this;\nvar hostSelector = styleTransformer._calcHostScope(element.is, element.extends);\nvar rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\nvar hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\nreturn styleTransformer.elementStyles(element, function (rule) {\nself.applyProperties(rule, properties);\nif (rule.cssText && !nativeShadow) {\nself._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);\n}\n});\n},\n_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {\nrule.transformedSelector = rule.transformedSelector || rule.selector;\nvar selector = rule.transformedSelector;\nvar scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;\nvar parts = selector.split(',');\nfor (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\nparts[i] = p.match(hostRx) ? p.replace(hostSelector, hostSelector + scope) : scope + ' ' + p;\n}\nrule.selector = parts.join(',');\n},\napplyElementScopeSelector: function (element, selector, old, viaAttr) {\nvar c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;\nvar v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\nif (c !== v) {\nif (viaAttr) {\nelement.setAttribute(styleTransformer.SCOPE_NAME, v);\n} else {\nelement.className = v;\n}\n}\n},\napplyElementStyle: function (element, properties, selector, style) {\nvar cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\nvar s = element._customStyle;\nif (s && !nativeShadow && s !== style) {\ns._useCount--;\nif (s._useCount <= 0 && s.parentNode) {\ns.parentNode.removeChild(s);\n}\n}\nif (nativeShadow || (!style || !style.parentNode)) {\nif (nativeShadow && element._customStyle) {\nelement._customStyle.textContent = cssText;\nstyle = element._customStyle;\n} else if (cssText) {\nstyle = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);\n}\n}\nif (style) {\nstyle._useCount = style._useCount || 0;\nif (element._customStyle != style) {\nstyle._useCount++;\n}\nelement._customStyle = style;\n}\nreturn style;\n},\nmixinCustomStyle: function (props, customStyle) {\nvar v;\nfor (var i in customStyle) {\nv = customStyle[i];\nif (v || v === 0) {\nprops[i] = v;\n}\n}\n},\nrx: {\nVAR_ASSIGN: /(?:^|[;\\n]\\s*)(--[\\w-]*?):\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\n])|$)/gi,\nMIXIN_MATCH: /(?:^|\\W+)@apply[\\s]*\\(([^)]*)\\)/i,\nVAR_MATCH: /(^|\\W+)var\\([\\s]*([^,)]*)[\\s]*,?[\\s]*((?:[^,)]*)|(?:[^;]*\\([^;)]*\\)))[\\s]*?\\)/gi,\nVAR_CAPTURE: /\\([\\s]*(--[^,\\s)]*)(?:,[\\s]*(--[^,\\s)]*))?(?:\\)|,)/gi,\nIS_VAR: /^--/,\nBRACKETED: /\\{[^}]*\\}/g,\nHOST_PREFIX: '(?:^|[^.#[:])',\nHOST_SUFFIX: '($|[.:[\\\\s>+~])'\n},\nHOST_SELECTORS: [':host'],\nSCOPE_SELECTORS: [':root'],\nXSCOPE_NAME: 'x-scope'\n};\nfunction addToBitMask(n, bits) {\nvar o = parseInt(n / 32);\nvar v = 1 << n % 32;\nbits[o] = (bits[o] || 0) | v;\n}\n}();\n(function () {\nPolymer.StyleCache = function () {\nthis.cache = {};\n};\nPolymer.StyleCache.prototype = {\nMAX: 100,\nstore: function (is, data, keyValues, keyStyles) {\ndata.keyValues = keyValues;\ndata.styles = keyStyles;\nvar s$ = this.cache[is] = this.cache[is] || [];\ns$.push(data);\nif (s$.length > this.MAX) {\ns$.shift();\n}\n},\nretrieve: function (is, keyValues, keyStyles) {\nvar cache = this.cache[is];\nif (cache) {\nfor (var i = cache.length - 1, data; i >= 0; i--) {\ndata = cache[i];\nif (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {\nreturn data;\n}\n}\n}\n},\nclear: function () {\nthis.cache = {};\n},\n_objectsEqual: function (target, source) {\nvar t, s;\nfor (var i in target) {\nt = target[i], s = source[i];\nif (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {\nreturn false;\n}\n}\nif (Array.isArray(target)) {\nreturn target.length === source.length;\n}\nreturn true;\n},\n_objectsStrictlyEqual: function (target, source) {\nreturn this._objectsEqual(target, source) && this._objectsEqual(source, target);\n}\n};\n}());\nPolymer.StyleDefaults = function () {\nvar styleProperties = Polymer.StyleProperties;\nvar styleUtil = Polymer.StyleUtil;\nvar StyleCache = Polymer.StyleCache;\nvar api = {\n_styles: [],\n_properties: null,\ncustomStyle: {},\n_styleCache: new StyleCache(),\naddStyle: function (style) {\nthis._styles.push(style);\nthis._properties = null;\n},\nget _styleProperties() {\nif (!this._properties) {\nstyleProperties.decorateStyles(this._styles);\nthis._styles._scopeStyleProperties = null;\nthis._properties = styleProperties.scopePropertiesFromStyles(this._styles);\nstyleProperties.mixinCustomStyle(this._properties, this.customStyle);\nstyleProperties.reify(this._properties);\n}\nreturn this._properties;\n},\n_needsStyleProperties: function () {\n},\n_computeStyleProperties: function () {\nreturn this._styleProperties;\n},\nupdateStyles: function (properties) {\nthis._properties = null;\nif (properties) {\nPolymer.Base.mixin(this.customStyle, properties);\n}\nthis._styleCache.clear();\nfor (var i = 0, s; i < this._styles.length; i++) {\ns = this._styles[i];\ns = s.__importElement || s;\ns._apply();\n}\n}\n};\nreturn api;\n}();\n(function () {\n'use strict';\nvar serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;\nvar propertyUtils = Polymer.StyleProperties;\nvar styleTransformer = Polymer.StyleTransformer;\nvar styleUtil = Polymer.StyleUtil;\nvar styleDefaults = Polymer.StyleDefaults;\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nPolymer.Base._addFeature({\n_prepStyleProperties: function () {\nthis._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];\n},\ncustomStyle: {},\n_setupStyleProperties: function () {\nthis.customStyle = {};\n},\n_needsStyleProperties: function () {\nreturn Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);\n},\n_beforeAttached: function () {\nif (!this._scopeSelector && this._needsStyleProperties()) {\nthis._updateStyleProperties();\n}\n},\n_findStyleHost: function () {\nvar e = this, root;\nwhile (root = Polymer.dom(e).getOwnerRoot()) {\nif (Polymer.isInstance(root.host)) {\nreturn root.host;\n}\ne = root.host;\n}\nreturn styleDefaults;\n},\n_updateStyleProperties: function () {\nvar info, scope = this._findStyleHost();\nif (!scope._styleCache) {\nscope._styleCache = new Polymer.StyleCache();\n}\nvar scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);\nscopeData.key.customStyle = this.customStyle;\ninfo = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);\nvar scopeCached = Boolean(info);\nif (scopeCached) {\nthis._styleProperties = info._styleProperties;\n} else {\nthis._computeStyleProperties(scopeData.properties);\n}\nthis._computeOwnStyleProperties();\nif (!scopeCached) {\ninfo = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);\n}\nvar globalCached = Boolean(info) && !scopeCached;\nvar style = this._applyStyleProperties(info);\nif (!scopeCached) {\nstyle = style && nativeShadow ? style.cloneNode(true) : style;\ninfo = {\nstyle: style,\n_scopeSelector: this._scopeSelector,\n_styleProperties: this._styleProperties\n};\nscopeData.key.customStyle = {};\nthis.mixin(scopeData.key.customStyle, this.customStyle);\nscope._styleCache.store(this.is, info, scopeData.key, this._styles);\nif (!globalCached) {\nstyleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);\n}\n}\n},\n_computeStyleProperties: function (scopeProps) {\nvar scope = this._findStyleHost();\nif (!scope._styleProperties) {\nscope._computeStyleProperties();\n}\nvar props = Object.create(scope._styleProperties);\nthis.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));\nscopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;\nthis.mixin(props, scopeProps);\nthis.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));\npropertyUtils.mixinCustomStyle(props, this.customStyle);\npropertyUtils.reify(props);\nthis._styleProperties = props;\n},\n_computeOwnStyleProperties: function () {\nvar props = {};\nfor (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {\nn = this._ownStylePropertyNames[i];\nprops[n] = this._styleProperties[n];\n}\nthis._ownStyleProperties = props;\n},\n_scopeCount: 0,\n_applyStyleProperties: function (info) {\nvar oldScopeSelector = this._scopeSelector;\nthis._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;\nvar style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);\nif (!nativeShadow) {\npropertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);\n}\nreturn style;\n},\nserializeValueToAttribute: function (value, attribute, node) {\nnode = node || this;\nif (attribute === 'class' && !nativeShadow) {\nvar host = node === this ? this.domHost || this.dataHost : this;\nif (host) {\nvalue = host._scopeElementClass(node, value);\n}\n}\nnode = Polymer.dom(node);\nserializeValueToAttribute.call(this, value, attribute, node);\n},\n_scopeElementClass: function (element, selector) {\nif (!nativeShadow && !this._scopeCssViaAttr) {\nselector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');\n}\nreturn selector;\n},\nupdateStyles: function (properties) {\nif (this.isAttached) {\nif (properties) {\nthis.mixin(this.customStyle, properties);\n}\nif (this._needsStyleProperties()) {\nthis._updateStyleProperties();\n} else {\nthis._styleProperties = null;\n}\nif (this._styleCache) {\nthis._styleCache.clear();\n}\nthis._updateRootStyles();\n}\n},\n_updateRootStyles: function (root) {\nroot = root || this.root;\nvar c$ = Polymer.dom(root)._query(function (e) {\nreturn e.shadyRoot || e.shadowRoot;\n});\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.updateStyles) {\nc.updateStyles();\n}\n}\n}\n});\nPolymer.updateStyles = function (properties) {\nstyleDefaults.updateStyles(properties);\nPolymer.Base._updateRootStyles(document);\n};\nvar styleCache = new Polymer.StyleCache();\nPolymer.customStyleCache = styleCache;\nvar SCOPE_NAME = styleTransformer.SCOPE_NAME;\nvar XSCOPE_NAME = propertyUtils.XSCOPE_NAME;\n}());\nPolymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepAttributes();\nthis._prepConstructor();\nthis._prepTemplate();\nthis._prepStyles();\nthis._prepStyleProperties();\nthis._prepAnnotations();\nthis._prepEffects();\nthis._prepBehaviors();\nthis._prepBindings();\nthis._prepShady();\n},\n_prepBehavior: function (b) {\nthis._addPropertyEffects(b.properties);\nthis._addComplexObserverEffects(b.observers);\nthis._addHostAttributes(b.hostAttributes);\n},\n_initFeatures: function () {\nthis._poolContent();\nthis._setupConfigure();\nthis._setupStyleProperties();\nthis._pushHost();\nthis._stampTemplate();\nthis._popHost();\nthis._marshalAnnotationReferences();\nthis._setupDebouncers();\nthis._marshalInstanceEffects();\nthis._marshalHostAttributes();\nthis._marshalBehaviors();\nthis._marshalAttributes();\nthis._tryReady();\n},\n_marshalBehavior: function (b) {\nthis._listenListeners(b.listeners);\n}\n});\n(function () {\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar propertyUtils = Polymer.StyleProperties;\nvar styleUtil = Polymer.StyleUtil;\nvar cssParse = Polymer.CssParse;\nvar styleDefaults = Polymer.StyleDefaults;\nvar styleTransformer = Polymer.StyleTransformer;\nPolymer({\nis: 'custom-style',\nextends: 'style',\nproperties: { include: String },\nready: function () {\nthis._tryApply();\n},\nattached: function () {\nthis._tryApply();\n},\n_tryApply: function () {\nif (!this._appliesToDocument) {\nif (this.parentNode && this.parentNode.localName !== 'dom-module') {\nthis._appliesToDocument = true;\nvar e = this.__appliedElement || this;\nstyleDefaults.addStyle(e);\nif (e.textContent || this.include) {\nthis._apply();\n} else {\nvar observer = new MutationObserver(function () {\nobserver.disconnect();\nthis._apply();\n}.bind(this));\nobserver.observe(e, { childList: true });\n}\n}\n}\n},\n_apply: function () {\nvar e = this.__appliedElement || this;\nif (this.include) {\ne.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;\n}\nif (e.textContent) {\nstyleUtil.forEachStyleRule(styleUtil.rulesForStyle(e), function (rule) {\nstyleTransformer.documentRule(rule);\n});\nthis._applyCustomProperties(e);\n}\n},\n_applyCustomProperties: function (element) {\nthis._computeStyleProperties();\nvar props = this._styleProperties;\nvar rules = styleUtil.rulesForStyle(element);\nelement.textContent = styleUtil.toCssText(rules, function (rule) {\nvar css = rule.cssText = rule.parsedCssText;\nif (rule.propertyInfo && rule.propertyInfo.cssText) {\ncss = cssParse.removeCustomPropAssignment(css);\nrule.cssText = propertyUtils.valueForProperties(css, props);\n}\n});\n}\n});\n}());\nPolymer.Templatizer = {\nproperties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },\n_instanceProps: Polymer.nob,\n_parentPropPrefix: '_parent_',\ntemplatize: function (template) {\nif (!template._content) {\ntemplate._content = template.content;\n}\nif (template._content._ctor) {\nthis.ctor = template._content._ctor;\nthis._prepParentProperties(this.ctor.prototype, template);\nreturn;\n}\nvar archetype = Object.create(Polymer.Base);\nthis._customPrepAnnotations(archetype, template);\narchetype._prepEffects();\nthis._customPrepEffects(archetype);\narchetype._prepBehaviors();\narchetype._prepBindings();\nthis._prepParentProperties(archetype, template);\narchetype._notifyPath = this._notifyPathImpl;\narchetype._scopeElementClass = this._scopeElementClassImpl;\narchetype.listen = this._listenImpl;\narchetype._showHideChildren = this._showHideChildrenImpl;\nvar _constructor = this._constructorImpl;\nvar ctor = function TemplateInstance(model, host) {\n_constructor.call(this, model, host);\n};\nctor.prototype = archetype;\narchetype.constructor = ctor;\ntemplate._content._ctor = ctor;\nthis.ctor = ctor;\n},\n_getRootDataHost: function () {\nreturn this.dataHost && this.dataHost._rootDataHost || this.dataHost;\n},\n_showHideChildrenImpl: function (hide) {\nvar c = this._children;\nfor (var i = 0; i < c.length; i++) {\nvar n = c[i];\nif (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\nif (n.nodeType === Node.TEXT_NODE) {\nif (hide) {\nn.__polymerTextContent__ = n.textContent;\nn.textContent = '';\n} else {\nn.textContent = n.__polymerTextContent__;\n}\n} else if (n.style) {\nif (hide) {\nn.__polymerDisplay__ = n.style.display;\nn.style.display = 'none';\n} else {\nn.style.display = n.__polymerDisplay__;\n}\n}\n}\nn.__hideTemplateChildren__ = hide;\n}\n},\n_debounceTemplate: function (fn) {\nPolymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));\n},\n_flushTemplates: function (debouncerExpired) {\nPolymer.dom.flush();\n},\n_customPrepEffects: function (archetype) {\nvar parentProps = archetype._parentProps;\nfor (var prop in parentProps) {\narchetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));\n}\nfor (var prop in this._instanceProps) {\narchetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));\n}\n},\n_customPrepAnnotations: function (archetype, template) {\narchetype._template = template;\nvar c = template._content;\nif (!c._notes) {\nvar rootDataHost = archetype._rootDataHost;\nif (rootDataHost) {\nPolymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);\n}\nc._notes = Polymer.Annotations.parseAnnotations(template);\nPolymer.Annotations.prepElement = null;\nthis._processAnnotations(c._notes);\n}\narchetype._notes = c._notes;\narchetype._parentProps = c._parentProps;\n},\n_prepParentProperties: function (archetype, template) {\nvar parentProps = this._parentProps = archetype._parentProps;\nif (this._forwardParentProp && parentProps) {\nvar proto = archetype._parentPropProto;\nvar prop;\nif (!proto) {\nfor (prop in this._instanceProps) {\ndelete parentProps[prop];\n}\nproto = archetype._parentPropProto = Object.create(null);\nif (template != this) {\nPolymer.Bind.prepareModel(proto);\n}\nfor (prop in parentProps) {\nvar parentProp = this._parentPropPrefix + prop;\nvar effects = [\n{\nkind: 'function',\neffect: this._createForwardPropEffector(prop)\n},\n{ kind: 'notify' }\n];\nPolymer.Bind._createAccessors(proto, parentProp, effects);\n}\n}\nif (template != this) {\nPolymer.Bind.prepareInstance(template);\ntemplate._forwardParentProp = this._forwardParentProp.bind(this);\n}\nthis._extendTemplate(template, proto);\n}\n},\n_createForwardPropEffector: function (prop) {\nreturn function (source, value) {\nthis._forwardParentProp(prop, value);\n};\n},\n_createHostPropEffector: function (prop) {\nvar prefix = this._parentPropPrefix;\nreturn function (source, value) {\nthis.dataHost[prefix + prop] = value;\n};\n},\n_createInstancePropEffector: function (prop) {\nreturn function (source, value, old, fromAbove) {\nif (!fromAbove) {\nthis.dataHost._forwardInstanceProp(this, prop, value);\n}\n};\n},\n_extendTemplate: function (template, proto) {\nObject.getOwnPropertyNames(proto).forEach(function (n) {\nvar val = template[n];\nvar pd = Object.getOwnPropertyDescriptor(proto, n);\nObject.defineProperty(template, n, pd);\nif (val !== undefined) {\ntemplate._propertySetter(n, val);\n}\n});\n},\n_showHideChildren: function (hidden) {\n},\n_forwardInstancePath: function (inst, path, value) {\n},\n_forwardInstanceProp: function (inst, prop, value) {\n},\n_notifyPathImpl: function (path, value) {\nvar dataHost = this.dataHost;\nvar dot = path.indexOf('.');\nvar root = dot < 0 ? path : path.slice(0, dot);\ndataHost._forwardInstancePath.call(dataHost, this, path, value);\nif (root in dataHost._parentProps) {\ndataHost.notifyPath(dataHost._parentPropPrefix + path, value);\n}\n},\n_pathEffector: function (path, value, fromAbove) {\nif (this._forwardParentPath) {\nif (path.indexOf(this._parentPropPrefix) === 0) {\nthis._forwardParentPath(path.substring(8), value);\n}\n}\nPolymer.Base._pathEffector.apply(this, arguments);\n},\n_constructorImpl: function (model, host) {\nthis._rootDataHost = host._getRootDataHost();\nthis._setupConfigure(model);\nthis._pushHost(host);\nthis.root = this.instanceTemplate(this._template);\nthis.root.__noContent = !this._notes._hasContent;\nthis.root.__styleScoped = true;\nthis._popHost();\nthis._marshalAnnotatedNodes();\nthis._marshalInstanceEffects();\nthis._marshalAnnotatedListeners();\nvar children = [];\nfor (var n = this.root.firstChild; n; n = n.nextSibling) {\nchildren.push(n);\nn._templateInstance = this;\n}\nthis._children = children;\nif (host.__hideTemplateChildren__) {\nthis._showHideChildren(true);\n}\nthis._tryReady();\n},\n_listenImpl: function (node, eventName, methodName) {\nvar model = this;\nvar host = this._rootDataHost;\nvar handler = host._createEventHandler(node, eventName, methodName);\nvar decorated = function (e) {\ne.model = model;\nhandler(e);\n};\nhost._listen(node, eventName, decorated);\n},\n_scopeElementClassImpl: function (node, value) {\nvar host = this._rootDataHost;\nif (host) {\nreturn host._scopeElementClass(node, value);\n}\n},\nstamp: function (model) {\nmodel = model || {};\nif (this._parentProps) {\nfor (var prop in this._parentProps) {\nmodel[prop] = this[this._parentPropPrefix + prop];\n}\n}\nreturn new this.ctor(model, this);\n},\nmodelForElement: function (el) {\nvar model;\nwhile (el) {\nif (model = el._templateInstance) {\nif (model.dataHost != this) {\nel = model.dataHost;\n} else {\nreturn model;\n}\n} else {\nel = el.parentNode;\n}\n}\n}\n};\nPolymer({\nis: 'dom-template',\nextends: 'template',\nbehaviors: [Polymer.Templatizer],\nready: function () {\nthis.templatize(this);\n}\n});\nPolymer._collections = new WeakMap();\nPolymer.Collection = function (userArray) {\nPolymer._collections.set(userArray, this);\nthis.userArray = userArray;\nthis.store = userArray.slice();\nthis.initMap();\n};\nPolymer.Collection.prototype = {\nconstructor: Polymer.Collection,\ninitMap: function () {\nvar omap = this.omap = new WeakMap();\nvar pmap = this.pmap = {};\nvar s = this.store;\nfor (var i = 0; i < s.length; i++) {\nvar item = s[i];\nif (item && typeof item == 'object') {\nomap.set(item, i);\n} else {\npmap[item] = i;\n}\n}\n},\nadd: function (item) {\nvar key = this.store.push(item) - 1;\nif (item && typeof item == 'object') {\nthis.omap.set(item, key);\n} else {\nthis.pmap[item] = key;\n}\nreturn key;\n},\nremoveKey: function (key) {\nthis._removeFromMap(this.store[key]);\ndelete this.store[key];\n},\n_removeFromMap: function (item) {\nif (item && typeof item == 'object') {\nthis.omap.delete(item);\n} else {\ndelete this.pmap[item];\n}\n},\nremove: function (item) {\nvar key = this.getKey(item);\nthis.removeKey(key);\nreturn key;\n},\ngetKey: function (item) {\nif (item && typeof item == 'object') {\nreturn this.omap.get(item);\n} else {\nreturn this.pmap[item];\n}\n},\ngetKeys: function () {\nreturn Object.keys(this.store);\n},\nsetItem: function (key, item) {\nvar old = this.store[key];\nif (old) {\nthis._removeFromMap(old);\n}\nif (item && typeof item == 'object') {\nthis.omap.set(item, key);\n} else {\nthis.pmap[item] = key;\n}\nthis.store[key] = item;\n},\ngetItem: function (key) {\nreturn this.store[key];\n},\ngetItems: function () {\nvar items = [], store = this.store;\nfor (var key in store) {\nitems.push(store[key]);\n}\nreturn items;\n},\n_applySplices: function (splices) {\nvar keyMap = {}, key, i;\nsplices.forEach(function (s) {\ns.addedKeys = [];\nfor (i = 0; i < s.removed.length; i++) {\nkey = this.getKey(s.removed[i]);\nkeyMap[key] = keyMap[key] ? null : -1;\n}\nfor (i = 0; i < s.addedCount; i++) {\nvar item = this.userArray[s.index + i];\nkey = this.getKey(item);\nkey = key === undefined ? this.add(item) : key;\nkeyMap[key] = keyMap[key] ? null : 1;\ns.addedKeys.push(key);\n}\n}, this);\nvar removed = [];\nvar added = [];\nfor (var key in keyMap) {\nif (keyMap[key] < 0) {\nthis.removeKey(key);\nremoved.push(key);\n}\nif (keyMap[key] > 0) {\nadded.push(key);\n}\n}\nreturn [{\nremoved: removed,\nadded: added\n}];\n}\n};\nPolymer.Collection.get = function (userArray) {\nreturn Polymer._collections.get(userArray) || new Polymer.Collection(userArray);\n};\nPolymer.Collection.applySplices = function (userArray, splices) {\nvar coll = Polymer._collections.get(userArray);\nreturn coll ? coll._applySplices(splices) : null;\n};\nPolymer({\nis: 'dom-repeat',\nextends: 'template',\nproperties: {\nitems: { type: Array },\nas: {\ntype: String,\nvalue: 'item'\n},\nindexAs: {\ntype: String,\nvalue: 'index'\n},\nsort: {\ntype: Function,\nobserver: '_sortChanged'\n},\nfilter: {\ntype: Function,\nobserver: '_filterChanged'\n},\nobserve: {\ntype: String,\nobserver: '_observeChanged'\n},\ndelay: Number\n},\nbehaviors: [Polymer.Templatizer],\nobservers: ['_itemsChanged(items.*)'],\ncreated: function () {\nthis._instances = [];\n},\ndetached: function () {\nfor (var i = 0; i < this._instances.length; i++) {\nthis._detachRow(i);\n}\n},\nattached: function () {\nvar parentNode = Polymer.dom(this).parentNode;\nfor (var i = 0; i < this._instances.length; i++) {\nPolymer.dom(parentNode).insertBefore(this._instances[i].root, this);\n}\n},\nready: function () {\nthis._instanceProps = { __key__: true };\nthis._instanceProps[this.as] = true;\nthis._instanceProps[this.indexAs] = true;\nif (!this.ctor) {\nthis.templatize(this);\n}\n},\n_sortChanged: function () {\nvar dataHost = this._getRootDataHost();\nvar sort = this.sort;\nthis._sortFn = sort && (typeof sort == 'function' ? sort : function () {\nreturn dataHost[sort].apply(dataHost, arguments);\n});\nthis._needFullRefresh = true;\nif (this.items) {\nthis._debounceTemplate(this._render);\n}\n},\n_filterChanged: function () {\nvar dataHost = this._getRootDataHost();\nvar filter = this.filter;\nthis._filterFn = filter && (typeof filter == 'function' ? filter : function () {\nreturn dataHost[filter].apply(dataHost, arguments);\n});\nthis._needFullRefresh = true;\nif (this.items) {\nthis._debounceTemplate(this._render);\n}\n},\n_observeChanged: function () {\nthis._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n},\n_itemsChanged: function (change) {\nif (change.path == 'items') {\nif (Array.isArray(this.items)) {\nthis.collection = Polymer.Collection.get(this.items);\n} else if (!this.items) {\nthis.collection = null;\n} else {\nthis._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));\n}\nthis._keySplices = [];\nthis._indexSplices = [];\nthis._needFullRefresh = true;\nthis._debounceTemplate(this._render);\n} else if (change.path == 'items.splices') {\nthis._keySplices = this._keySplices.concat(change.value.keySplices);\nthis._indexSplices = this._indexSplices.concat(change.value.indexSplices);\nthis._debounceTemplate(this._render);\n} else {\nvar subpath = change.path.slice(6);\nthis._forwardItemPath(subpath, change.value);\nthis._checkObservedPaths(subpath);\n}\n},\n_checkObservedPaths: function (path) {\nif (this._observePaths) {\npath = path.substring(path.indexOf('.') + 1);\nvar paths = this._observePaths;\nfor (var i = 0; i < paths.length; i++) {\nif (path.indexOf(paths[i]) === 0) {\nthis._needFullRefresh = true;\nif (this.delay) {\nthis.debounce('render', this._render, this.delay);\n} else {\nthis._debounceTemplate(this._render);\n}\nreturn;\n}\n}\n}\n},\nrender: function () {\nthis._needFullRefresh = true;\nthis._debounceTemplate(this._render);\nthis._flushTemplates();\n},\n_render: function () {\nvar c = this.collection;\nif (this._needFullRefresh) {\nthis._applyFullRefresh();\nthis._needFullRefresh = false;\n} else {\nif (this._sortFn) {\nthis._applySplicesUserSort(this._keySplices);\n} else {\nif (this._filterFn) {\nthis._applyFullRefresh();\n} else {\nthis._applySplicesArrayOrder(this._indexSplices);\n}\n}\n}\nthis._keySplices = [];\nthis._indexSplices = [];\nvar keyToIdx = this._keyToInstIdx = {};\nfor (var i = 0; i < this._instances.length; i++) {\nvar inst = this._instances[i];\nkeyToIdx[inst.__key__] = i;\ninst.__setProperty(this.indexAs, i, true);\n}\nthis.fire('dom-change');\n},\n_applyFullRefresh: function () {\nvar c = this.collection;\nvar keys;\nif (this._sortFn) {\nkeys = c ? c.getKeys() : [];\n} else {\nkeys = [];\nvar items = this.items;\nif (items) {\nfor (var i = 0; i < items.length; i++) {\nkeys.push(c.getKey(items[i]));\n}\n}\n}\nif (this._filterFn) {\nkeys = keys.filter(function (a) {\nreturn this._filterFn(c.getItem(a));\n}, this);\n}\nif (this._sortFn) {\nkeys.sort(function (a, b) {\nreturn this._sortFn(c.getItem(a), c.getItem(b));\n}.bind(this));\n}\nfor (var i = 0; i < keys.length; i++) {\nvar key = keys[i];\nvar inst = this._instances[i];\nif (inst) {\ninst.__setProperty('__key__', key, true);\ninst.__setProperty(this.as, c.getItem(key), true);\n} else {\nthis._instances.push(this._insertRow(i, key));\n}\n}\nfor (; i < this._instances.length; i++) {\nthis._detachRow(i);\n}\nthis._instances.splice(keys.length, this._instances.length - keys.length);\n},\n_keySort: function (a, b) {\nreturn this.collection.getKey(a) - this.collection.getKey(b);\n},\n_numericSort: function (a, b) {\nreturn a - b;\n},\n_applySplicesUserSort: function (splices) {\nvar c = this.collection;\nvar instances = this._instances;\nvar keyMap = {};\nvar pool = [];\nvar sortFn = this._sortFn || this._keySort.bind(this);\nsplices.forEach(function (s) {\nfor (var i = 0; i < s.removed.length; i++) {\nvar key = s.removed[i];\nkeyMap[key] = keyMap[key] ? null : -1;\n}\nfor (var i = 0; i < s.added.length; i++) {\nvar key = s.added[i];\nkeyMap[key] = keyMap[key] ? null : 1;\n}\n}, this);\nvar removedIdxs = [];\nvar addedKeys = [];\nfor (var key in keyMap) {\nif (keyMap[key] === -1) {\nremovedIdxs.push(this._keyToInstIdx[key]);\n}\nif (keyMap[key] === 1) {\naddedKeys.push(key);\n}\n}\nif (removedIdxs.length) {\nremovedIdxs.sort(this._numericSort);\nfor (var i = removedIdxs.length - 1; i >= 0; i--) {\nvar idx = removedIdxs[i];\nif (idx !== undefined) {\npool.push(this._detachRow(idx));\ninstances.splice(idx, 1);\n}\n}\n}\nif (addedKeys.length) {\nif (this._filterFn) {\naddedKeys = addedKeys.filter(function (a) {\nreturn this._filterFn(c.getItem(a));\n}, this);\n}\naddedKeys.sort(function (a, b) {\nreturn this._sortFn(c.getItem(a), c.getItem(b));\n}.bind(this));\nvar start = 0;\nfor (var i = 0; i < addedKeys.length; i++) {\nstart = this._insertRowUserSort(start, addedKeys[i], pool);\n}\n}\n},\n_insertRowUserSort: function (start, key, pool) {\nvar c = this.collection;\nvar item = c.getItem(key);\nvar end = this._instances.length - 1;\nvar idx = -1;\nvar sortFn = this._sortFn || this._keySort.bind(this);\nwhile (start <= end) {\nvar mid = start + end >> 1;\nvar midKey = this._instances[mid].__key__;\nvar cmp = sortFn(c.getItem(midKey), item);\nif (cmp < 0) {\nstart = mid + 1;\n} else if (cmp > 0) {\nend = mid - 1;\n} else {\nidx = mid;\nbreak;\n}\n}\nif (idx < 0) {\nidx = end + 1;\n}\nthis._instances.splice(idx, 0, this._insertRow(idx, key, pool));\nreturn idx;\n},\n_applySplicesArrayOrder: function (splices) {\nvar pool = [];\nvar c = this.collection;\nsplices.forEach(function (s) {\nfor (var i = 0; i < s.removed.length; i++) {\nvar inst = this._detachRow(s.index + i);\nif (!inst.isPlaceholder) {\npool.push(inst);\n}\n}\nthis._instances.splice(s.index, s.removed.length);\nfor (var i = 0; i < s.addedKeys.length; i++) {\nvar inst = {\nisPlaceholder: true,\nkey: s.addedKeys[i]\n};\nthis._instances.splice(s.index + i, 0, inst);\n}\n}, this);\nfor (var i = this._instances.length - 1; i >= 0; i--) {\nvar inst = this._instances[i];\nif (inst.isPlaceholder) {\nthis._instances[i] = this._insertRow(i, inst.key, pool, true);\n}\n}\n},\n_detachRow: function (idx) {\nvar inst = this._instances[idx];\nif (!inst.isPlaceholder) {\nvar parentNode = Polymer.dom(this).parentNode;\nfor (var i = 0; i < inst._children.length; i++) {\nvar el = inst._children[i];\nPolymer.dom(inst.root).appendChild(el);\n}\n}\nreturn inst;\n},\n_insertRow: function (idx, key, pool, replace) {\nvar inst;\nif (inst = pool && pool.pop()) {\ninst.__setProperty(this.as, this.collection.getItem(key), true);\ninst.__setProperty('__key__', key, true);\n} else {\ninst = this._generateRow(idx, key);\n}\nvar beforeRow = this._instances[replace ? idx + 1 : idx];\nvar beforeNode = beforeRow ? beforeRow._children[0] : this;\nvar parentNode = Polymer.dom(this).parentNode;\nPolymer.dom(parentNode).insertBefore(inst.root, beforeNode);\nreturn inst;\n},\n_generateRow: function (idx, key) {\nvar model = { __key__: key };\nmodel[this.as] = this.collection.getItem(key);\nmodel[this.indexAs] = idx;\nvar inst = this.stamp(model);\nreturn inst;\n},\n_showHideChildren: function (hidden) {\nfor (var i = 0; i < this._instances.length; i++) {\nthis._instances[i]._showHideChildren(hidden);\n}\n},\n_forwardInstanceProp: function (inst, prop, value) {\nif (prop == this.as) {\nvar idx;\nif (this._sortFn || this._filterFn) {\nidx = this.items.indexOf(this.collection.getItem(inst.__key__));\n} else {\nidx = inst[this.indexAs];\n}\nthis.set('items.' + idx, value);\n}\n},\n_forwardInstancePath: function (inst, path, value) {\nif (path.indexOf(this.as + '.') === 0) {\nthis.notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);\n}\n},\n_forwardParentProp: function (prop, value) {\nthis._instances.forEach(function (inst) {\ninst.__setProperty(prop, value, true);\n}, this);\n},\n_forwardParentPath: function (path, value) {\nthis._instances.forEach(function (inst) {\ninst.notifyPath(path, value, true);\n}, this);\n},\n_forwardItemPath: function (path, value) {\nif (this._keyToInstIdx) {\nvar dot = path.indexOf('.');\nvar key = path.substring(0, dot < 0 ? path.length : dot);\nvar idx = this._keyToInstIdx[key];\nvar inst = this._instances[idx];\nif (inst) {\nif (dot >= 0) {\npath = this.as + '.' + path.substring(dot + 1);\ninst.notifyPath(path, value, true);\n} else {\ninst.__setProperty(this.as, value, true);\n}\n}\n}\n},\nitemForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance[this.as];\n},\nkeyForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance.__key__;\n},\nindexForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance[this.indexAs];\n}\n});\nPolymer({\nis: 'array-selector',\nproperties: {\nitems: {\ntype: Array,\nobserver: 'clearSelection'\n},\nmulti: {\ntype: Boolean,\nvalue: false,\nobserver: 'clearSelection'\n},\nselected: {\ntype: Object,\nnotify: true\n},\nselectedItem: {\ntype: Object,\nnotify: true\n},\ntoggle: {\ntype: Boolean,\nvalue: false\n}\n},\nclearSelection: function () {\nif (Array.isArray(this.selected)) {\nfor (var i = 0; i < this.selected.length; i++) {\nthis.unlinkPaths('selected.' + i);\n}\n} else {\nthis.unlinkPaths('selected');\n}\nif (this.multi) {\nif (!this.selected || this.selected.length) {\nthis.selected = [];\nthis._selectedColl = Polymer.Collection.get(this.selected);\n}\n} else {\nthis.selected = null;\nthis._selectedColl = null;\n}\nthis.selectedItem = null;\n},\nisSelected: function (item) {\nif (this.multi) {\nreturn this._selectedColl.getKey(item) !== undefined;\n} else {\nreturn this.selected == item;\n}\n},\ndeselect: function (item) {\nif (this.multi) {\nif (this.isSelected(item)) {\nvar skey = this._selectedColl.getKey(item);\nthis.arrayDelete('selected', item);\nthis.unlinkPaths('selected.' + skey);\n}\n} else {\nthis.selected = null;\nthis.selectedItem = null;\nthis.unlinkPaths('selected');\nthis.unlinkPaths('selectedItem');\n}\n},\nselect: function (item) {\nvar icol = Polymer.Collection.get(this.items);\nvar key = icol.getKey(item);\nif (this.multi) {\nif (this.isSelected(item)) {\nif (this.toggle) {\nthis.deselect(item);\n}\n} else {\nthis.push('selected', item);\nskey = this._selectedColl.getKey(item);\nthis.linkPaths('selected.' + skey, 'items.' + key);\n}\n} else {\nif (this.toggle && item == this.selected) {\nthis.deselect();\n} else {\nthis.selected = item;\nthis.selectedItem = item;\nthis.linkPaths('selected', 'items.' + key);\nthis.linkPaths('selectedItem', 'items.' + key);\n}\n}\n}\n});\nPolymer({\nis: 'dom-if',\nextends: 'template',\nproperties: {\n'if': {\ntype: Boolean,\nvalue: false,\nobserver: '_queueRender'\n},\nrestamp: {\ntype: Boolean,\nvalue: false,\nobserver: '_queueRender'\n}\n},\nbehaviors: [Polymer.Templatizer],\n_queueRender: function () {\nthis._debounceTemplate(this._render);\n},\ndetached: function () {\nthis._teardownInstance();\n},\nattached: function () {\nif (this.if && this.ctor) {\nthis.async(this._ensureInstance);\n}\n},\nrender: function () {\nthis._flushTemplates();\n},\n_render: function () {\nif (this.if) {\nif (!this.ctor) {\nthis.templatize(this);\n}\nthis._ensureInstance();\nthis._showHideChildren();\n} else if (this.restamp) {\nthis._teardownInstance();\n}\nif (!this.restamp && this._instance) {\nthis._showHideChildren();\n}\nif (this.if != this._lastIf) {\nthis.fire('dom-change');\nthis._lastIf = this.if;\n}\n},\n_ensureInstance: function () {\nif (!this._instance) {\nthis._instance = this.stamp();\nvar root = this._instance.root;\nvar parent = Polymer.dom(Polymer.dom(this).parentNode);\nparent.insertBefore(root, this);\n}\n},\n_teardownInstance: function () {\nif (this._instance) {\nvar c = this._instance._children;\nif (c) {\nvar parent = Polymer.dom(Polymer.dom(c[0]).parentNode);\nc.forEach(function (n) {\nparent.removeChild(n);\n});\n}\nthis._instance = null;\n}\n},\n_showHideChildren: function () {\nvar hidden = this.__hideTemplateChildren__ || !this.if;\nif (this._instance) {\nthis._instance._showHideChildren(hidden);\n}\n},\n_forwardParentProp: function (prop, value) {\nif (this._instance) {\nthis._instance[prop] = value;\n}\n},\n_forwardParentPath: function (path, value) {\nif (this._instance) {\nthis._instance.notifyPath(path, value, true);\n}\n}\n});\nPolymer({\nis: 'dom-bind',\nextends: 'template',\ncreated: function () {\nPolymer.RenderStatus.whenReady(this._markImportsReady.bind(this));\n},\n_ensureReady: function () {\nif (!this._readied) {\nthis._readySelf();\n}\n},\n_markImportsReady: function () {\nthis._importsReady = true;\nthis._ensureReady();\n},\n_registerFeatures: function () {\nthis._prepConstructor();\n},\n_insertChildren: function () {\nvar parentDom = Polymer.dom(Polymer.dom(this).parentNode);\nparentDom.insertBefore(this.root, this);\n},\n_removeChildren: function () {\nif (this._children) {\nfor (var i = 0; i < this._children.length; i++) {\nthis.root.appendChild(this._children[i]);\n}\n}\n},\n_initFeatures: function () {\n},\n_scopeElementClass: function (element, selector) {\nif (this.dataHost) {\nreturn this.dataHost._scopeElementClass(element, selector);\n} else {\nreturn selector;\n}\n},\n_prepConfigure: function () {\nvar config = {};\nfor (var prop in this._propertyEffects) {\nconfig[prop] = this[prop];\n}\nthis._setupConfigure = this._setupConfigure.bind(this, config);\n},\nattached: function () {\nif (this._importsReady) {\nthis.render();\n}\n},\ndetached: function () {\nthis._removeChildren();\n},\nrender: function () {\nthis._ensureReady();\nif (!this._children) {\nthis._template = this;\nthis._prepAnnotations();\nthis._prepEffects();\nthis._prepBehaviors();\nthis._prepConfigure();\nthis._prepBindings();\nPolymer.Base._initFeatures.call(this);\nthis._children = Array.prototype.slice.call(this.root.childNodes);\n}\nthis._insertChildren();\nthis.fire('dom-change');\n}\n});</script>\n",
"static/deps/webcomponents.js": "/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.14\nwindow.WebComponents = window.WebComponents || {};\n\n(function(scope) {\n  var flags = scope.flags || {};\n  var file = \"webcomponents.js\";\n  var script = document.querySelector('script[src*=\"' + file + '\"]');\n  if (!flags.noOpts) {\n    location.search.slice(1).split(\"&\").forEach(function(option) {\n      var parts = option.split(\"=\");\n      var match;\n      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {\n        flags[match[1]] = parts[1] || true;\n      }\n    });\n    if (script) {\n      for (var i = 0, a; a = script.attributes[i]; i++) {\n        if (a.name !== \"src\") {\n          flags[a.name] = a.value || true;\n        }\n      }\n    }\n    if (flags.log && flags.log.split) {\n      var parts = flags.log.split(\",\");\n      flags.log = {};\n      parts.forEach(function(f) {\n        flags.log[f] = true;\n      });\n    } else {\n      flags.log = {};\n    }\n  }\n  flags.shadow = flags.shadow || flags.shadowdom || flags.polyfill;\n  if (flags.shadow === \"native\") {\n    flags.shadow = false;\n  } else {\n    flags.shadow = flags.shadow || !HTMLElement.prototype.createShadowRoot;\n  }\n  if (flags.register) {\n    window.CustomElements = window.CustomElements || {\n      flags: {}\n    };\n    window.CustomElements.flags.register = flags.register;\n  }\n  scope.flags = flags;\n})(WebComponents);\n\nif (WebComponents.flags.shadow) {\n  if (typeof WeakMap === \"undefined\") {\n    (function() {\n      var defineProperty = Object.defineProperty;\n      var counter = Date.now() % 1e9;\n      var WeakMap = function() {\n        this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\n      };\n      WeakMap.prototype = {\n        set: function(key, value) {\n          var entry = key[this.name];\n          if (entry && entry[0] === key) entry[1] = value; else defineProperty(key, this.name, {\n            value: [ key, value ],\n            writable: true\n          });\n          return this;\n        },\n        get: function(key) {\n          var entry;\n          return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n        },\n        \"delete\": function(key) {\n          var entry = key[this.name];\n          if (!entry || entry[0] !== key) return false;\n          entry[0] = entry[1] = undefined;\n          return true;\n        },\n        has: function(key) {\n          var entry = key[this.name];\n          if (!entry) return false;\n          return entry[0] === key;\n        }\n      };\n      window.WeakMap = WeakMap;\n    })();\n  }\n  window.ShadowDOMPolyfill = {};\n  (function(scope) {\n    \"use strict\";\n    var constructorTable = new WeakMap();\n    var nativePrototypeTable = new WeakMap();\n    var wrappers = Object.create(null);\n    function detectEval() {\n      if (typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime) {\n        return false;\n      }\n      if (navigator.getDeviceStorage) {\n        return false;\n      }\n      try {\n        var f = new Function(\"return true;\");\n        return f();\n      } catch (ex) {\n        return false;\n      }\n    }\n    var hasEval = detectEval();\n    function assert(b) {\n      if (!b) throw new Error(\"Assertion failed\");\n    }\n    var defineProperty = Object.defineProperty;\n    var getOwnPropertyNames = Object.getOwnPropertyNames;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    function mixin(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function mixinStatics(to, from) {\n      var names = getOwnPropertyNames(from);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        switch (name) {\n         case \"arguments\":\n         case \"caller\":\n         case \"length\":\n         case \"name\":\n         case \"prototype\":\n         case \"toString\":\n          continue;\n        }\n        defineProperty(to, name, getOwnPropertyDescriptor(from, name));\n      }\n      return to;\n    }\n    function oneOf(object, propertyNames) {\n      for (var i = 0; i < propertyNames.length; i++) {\n        if (propertyNames[i] in object) return propertyNames[i];\n      }\n    }\n    var nonEnumerableDataDescriptor = {\n      value: undefined,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    };\n    function defineNonEnumerableDataProperty(object, name, value) {\n      nonEnumerableDataDescriptor.value = value;\n      defineProperty(object, name, nonEnumerableDataDescriptor);\n    }\n    getOwnPropertyNames(window);\n    function getWrapperConstructor(node, opt_instance) {\n      var nativePrototype = node.__proto__ || Object.getPrototypeOf(node);\n      if (isFirefox) {\n        try {\n          getOwnPropertyNames(nativePrototype);\n        } catch (error) {\n          nativePrototype = nativePrototype.__proto__;\n        }\n      }\n      var wrapperConstructor = constructorTable.get(nativePrototype);\n      if (wrapperConstructor) return wrapperConstructor;\n      var parentWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(parentWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, opt_instance);\n      return GeneratedWrapper;\n    }\n    function addForwardingProperties(nativePrototype, wrapperPrototype) {\n      installProperty(nativePrototype, wrapperPrototype, true);\n    }\n    function registerInstanceProperties(wrapperPrototype, instanceObject) {\n      installProperty(instanceObject, wrapperPrototype, false);\n    }\n    var isFirefox = /Firefox/.test(navigator.userAgent);\n    var dummyDescriptor = {\n      get: function() {},\n      set: function(v) {},\n      configurable: true,\n      enumerable: true\n    };\n    function isEventHandlerName(name) {\n      return /^on[a-z]+$/.test(name);\n    }\n    function isIdentifierName(name) {\n      return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name);\n    }\n    function getGetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name) : function() {\n        return this.__impl4cf1e782hg__[name];\n      };\n    }\n    function getSetter(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"v\", \"this.__impl4cf1e782hg__.\" + name + \" = v\") : function(v) {\n        this.__impl4cf1e782hg__[name] = v;\n      };\n    }\n    function getMethod(name) {\n      return hasEval && isIdentifierName(name) ? new Function(\"return this.__impl4cf1e782hg__.\" + name + \".apply(this.__impl4cf1e782hg__, arguments)\") : function() {\n        return this.__impl4cf1e782hg__[name].apply(this.__impl4cf1e782hg__, arguments);\n      };\n    }\n    function getDescriptor(source, name) {\n      try {\n        return Object.getOwnPropertyDescriptor(source, name);\n      } catch (ex) {\n        return dummyDescriptor;\n      }\n    }\n    var isBrokenSafari = function() {\n      var descr = Object.getOwnPropertyDescriptor(Node.prototype, \"nodeType\");\n      return descr && !descr.get && !descr.set;\n    }();\n    function installProperty(source, target, allowMethod, opt_blacklist) {\n      var names = getOwnPropertyNames(source);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        if (name === \"polymerBlackList_\") continue;\n        if (name in target) continue;\n        if (source.polymerBlackList_ && source.polymerBlackList_[name]) continue;\n        if (isFirefox) {\n          source.__lookupGetter__(name);\n        }\n        var descriptor = getDescriptor(source, name);\n        var getter, setter;\n        if (typeof descriptor.value === \"function\") {\n          if (allowMethod) {\n            target[name] = getMethod(name);\n          }\n          continue;\n        }\n        var isEvent = isEventHandlerName(name);\n        if (isEvent) getter = scope.getEventHandlerGetter(name); else getter = getGetter(name);\n        if (descriptor.writable || descriptor.set || isBrokenSafari) {\n          if (isEvent) setter = scope.getEventHandlerSetter(name); else setter = getSetter(name);\n        }\n        var configurable = isBrokenSafari || descriptor.configurable;\n        defineProperty(target, name, {\n          get: getter,\n          set: setter,\n          configurable: configurable,\n          enumerable: descriptor.enumerable\n        });\n      }\n    }\n    function register(nativeConstructor, wrapperConstructor, opt_instance) {\n      if (nativeConstructor == null) {\n        return;\n      }\n      var nativePrototype = nativeConstructor.prototype;\n      registerInternal(nativePrototype, wrapperConstructor, opt_instance);\n      mixinStatics(wrapperConstructor, nativeConstructor);\n    }\n    function registerInternal(nativePrototype, wrapperConstructor, opt_instance) {\n      var wrapperPrototype = wrapperConstructor.prototype;\n      assert(constructorTable.get(nativePrototype) === undefined);\n      constructorTable.set(nativePrototype, wrapperConstructor);\n      nativePrototypeTable.set(wrapperPrototype, nativePrototype);\n      addForwardingProperties(nativePrototype, wrapperPrototype);\n      if (opt_instance) registerInstanceProperties(wrapperPrototype, opt_instance);\n      defineNonEnumerableDataProperty(wrapperPrototype, \"constructor\", wrapperConstructor);\n      wrapperConstructor.prototype = wrapperPrototype;\n    }\n    function isWrapperFor(wrapperConstructor, nativeConstructor) {\n      return constructorTable.get(nativeConstructor.prototype) === wrapperConstructor;\n    }\n    function registerObject(object) {\n      var nativePrototype = Object.getPrototypeOf(object);\n      var superWrapperConstructor = getWrapperConstructor(nativePrototype);\n      var GeneratedWrapper = createWrapperConstructor(superWrapperConstructor);\n      registerInternal(nativePrototype, GeneratedWrapper, object);\n      return GeneratedWrapper;\n    }\n    function createWrapperConstructor(superWrapperConstructor) {\n      function GeneratedWrapper(node) {\n        superWrapperConstructor.call(this, node);\n      }\n      var p = Object.create(superWrapperConstructor.prototype);\n      p.constructor = GeneratedWrapper;\n      GeneratedWrapper.prototype = p;\n      return GeneratedWrapper;\n    }\n    function isWrapper(object) {\n      return object && object.__impl4cf1e782hg__;\n    }\n    function isNative(object) {\n      return !isWrapper(object);\n    }\n    function wrap(impl) {\n      if (impl === null) return null;\n      assert(isNative(impl));\n      var wrapper = impl.__wrapper8e3dd93a60__;\n      if (wrapper != null) {\n        return wrapper;\n      }\n      return impl.__wrapper8e3dd93a60__ = new (getWrapperConstructor(impl, impl))(impl);\n    }\n    function unwrap(wrapper) {\n      if (wrapper === null) return null;\n      assert(isWrapper(wrapper));\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function unsafeUnwrap(wrapper) {\n      return wrapper.__impl4cf1e782hg__;\n    }\n    function setWrapper(impl, wrapper) {\n      wrapper.__impl4cf1e782hg__ = impl;\n      impl.__wrapper8e3dd93a60__ = wrapper;\n    }\n    function unwrapIfNeeded(object) {\n      return object && isWrapper(object) ? unwrap(object) : object;\n    }\n    function wrapIfNeeded(object) {\n      return object && !isWrapper(object) ? wrap(object) : object;\n    }\n    function rewrap(node, wrapper) {\n      if (wrapper === null) return;\n      assert(isNative(node));\n      assert(wrapper === undefined || isWrapper(wrapper));\n      node.__wrapper8e3dd93a60__ = wrapper;\n    }\n    var getterDescriptor = {\n      get: undefined,\n      configurable: true,\n      enumerable: true\n    };\n    function defineGetter(constructor, name, getter) {\n      getterDescriptor.get = getter;\n      defineProperty(constructor.prototype, name, getterDescriptor);\n    }\n    function defineWrapGetter(constructor, name) {\n      defineGetter(constructor, name, function() {\n        return wrap(this.__impl4cf1e782hg__[name]);\n      });\n    }\n    function forwardMethodsToWrapper(constructors, names) {\n      constructors.forEach(function(constructor) {\n        names.forEach(function(name) {\n          constructor.prototype[name] = function() {\n            var w = wrapIfNeeded(this);\n            return w[name].apply(w, arguments);\n          };\n        });\n      });\n    }\n    scope.assert = assert;\n    scope.constructorTable = constructorTable;\n    scope.defineGetter = defineGetter;\n    scope.defineWrapGetter = defineWrapGetter;\n    scope.forwardMethodsToWrapper = forwardMethodsToWrapper;\n    scope.isIdentifierName = isIdentifierName;\n    scope.isWrapper = isWrapper;\n    scope.isWrapperFor = isWrapperFor;\n    scope.mixin = mixin;\n    scope.nativePrototypeTable = nativePrototypeTable;\n    scope.oneOf = oneOf;\n    scope.registerObject = registerObject;\n    scope.registerWrapper = register;\n    scope.rewrap = rewrap;\n    scope.setWrapper = setWrapper;\n    scope.unsafeUnwrap = unsafeUnwrap;\n    scope.unwrap = unwrap;\n    scope.unwrapIfNeeded = unwrapIfNeeded;\n    scope.wrap = wrap;\n    scope.wrapIfNeeded = wrapIfNeeded;\n    scope.wrappers = wrappers;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function newSplice(index, removed, addedCount) {\n      return {\n        index: index,\n        removed: removed,\n        addedCount: addedCount\n      };\n    }\n    var EDIT_LEAVE = 0;\n    var EDIT_UPDATE = 1;\n    var EDIT_ADD = 2;\n    var EDIT_DELETE = 3;\n    function ArraySplice() {}\n    ArraySplice.prototype = {\n      calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var rowCount = oldEnd - oldStart + 1;\n        var columnCount = currentEnd - currentStart + 1;\n        var distances = new Array(rowCount);\n        for (var i = 0; i < rowCount; i++) {\n          distances[i] = new Array(columnCount);\n          distances[i][0] = i;\n        }\n        for (var j = 0; j < columnCount; j++) distances[0][j] = j;\n        for (var i = 1; i < rowCount; i++) {\n          for (var j = 1; j < columnCount; j++) {\n            if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1]; else {\n              var north = distances[i - 1][j] + 1;\n              var west = distances[i][j - 1] + 1;\n              distances[i][j] = north < west ? north : west;\n            }\n          }\n        }\n        return distances;\n      },\n      spliceOperationsFromEditDistances: function(distances) {\n        var i = distances.length - 1;\n        var j = distances[0].length - 1;\n        var current = distances[i][j];\n        var edits = [];\n        while (i > 0 || j > 0) {\n          if (i == 0) {\n            edits.push(EDIT_ADD);\n            j--;\n            continue;\n          }\n          if (j == 0) {\n            edits.push(EDIT_DELETE);\n            i--;\n            continue;\n          }\n          var northWest = distances[i - 1][j - 1];\n          var west = distances[i - 1][j];\n          var north = distances[i][j - 1];\n          var min;\n          if (west < north) min = west < northWest ? west : northWest; else min = north < northWest ? north : northWest;\n          if (min == northWest) {\n            if (northWest == current) {\n              edits.push(EDIT_LEAVE);\n            } else {\n              edits.push(EDIT_UPDATE);\n              current = northWest;\n            }\n            i--;\n            j--;\n          } else if (min == west) {\n            edits.push(EDIT_DELETE);\n            i--;\n            current = west;\n          } else {\n            edits.push(EDIT_ADD);\n            j--;\n            current = north;\n          }\n        }\n        edits.reverse();\n        return edits;\n      },\n      calcSplices: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n        var prefixCount = 0;\n        var suffixCount = 0;\n        var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n        if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);\n        if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n        currentStart += prefixCount;\n        oldStart += prefixCount;\n        currentEnd -= suffixCount;\n        oldEnd -= suffixCount;\n        if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n        if (currentStart == currentEnd) {\n          var splice = newSplice(currentStart, [], 0);\n          while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);\n          return [ splice ];\n        } else if (oldStart == oldEnd) return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n        var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n        var splice = undefined;\n        var splices = [];\n        var index = currentStart;\n        var oldIndex = oldStart;\n        for (var i = 0; i < ops.length; i++) {\n          switch (ops[i]) {\n           case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n            index++;\n            oldIndex++;\n            break;\n\n           case EDIT_UPDATE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n\n           case EDIT_ADD:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.addedCount++;\n            index++;\n            break;\n\n           case EDIT_DELETE:\n            if (!splice) splice = newSplice(index, [], 0);\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          }\n        }\n        if (splice) {\n          splices.push(splice);\n        }\n        return splices;\n      },\n      sharedPrefix: function(current, old, searchLength) {\n        for (var i = 0; i < searchLength; i++) if (!this.equals(current[i], old[i])) return i;\n        return searchLength;\n      },\n      sharedSuffix: function(current, old, searchLength) {\n        var index1 = current.length;\n        var index2 = old.length;\n        var count = 0;\n        while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;\n        return count;\n      },\n      calculateSplices: function(current, previous) {\n        return this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n      },\n      equals: function(currentValue, previousValue) {\n        return currentValue === previousValue;\n      }\n    };\n    scope.ArraySplice = ArraySplice;\n  })(window.ShadowDOMPolyfill);\n  (function(context) {\n    \"use strict\";\n    var OriginalMutationObserver = window.MutationObserver;\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function handle() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        (0, copies[i])();\n      }\n    }\n    if (OriginalMutationObserver) {\n      var counter = 1;\n      var observer = new OriginalMutationObserver(handle);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function() {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      timerFunc = window.setTimeout;\n    }\n    function setEndOfMicrotask(func) {\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(handle, 0);\n    }\n    context.setEndOfMicrotask = setEndOfMicrotask;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var setEndOfMicrotask = scope.setEndOfMicrotask;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    var registrationsTable = new WeakMap();\n    var globalMutationObservers = [];\n    var isScheduled = false;\n    function scheduleCallback(observer) {\n      if (observer.scheduled_) return;\n      observer.scheduled_ = true;\n      globalMutationObservers.push(observer);\n      if (isScheduled) return;\n      setEndOfMicrotask(notifyObservers);\n      isScheduled = true;\n    }\n    function notifyObservers() {\n      isScheduled = false;\n      while (globalMutationObservers.length) {\n        var notifyList = globalMutationObservers;\n        globalMutationObservers = [];\n        notifyList.sort(function(x, y) {\n          return x.uid_ - y.uid_;\n        });\n        for (var i = 0; i < notifyList.length; i++) {\n          var mo = notifyList[i];\n          mo.scheduled_ = false;\n          var queue = mo.takeRecords();\n          removeTransientObserversFor(mo);\n          if (queue.length) {\n            mo.callback_(queue, mo);\n          }\n        }\n      }\n    }\n    function MutationRecord(type, target) {\n      this.type = type;\n      this.target = target;\n      this.addedNodes = new wrappers.NodeList();\n      this.removedNodes = new wrappers.NodeList();\n      this.previousSibling = null;\n      this.nextSibling = null;\n      this.attributeName = null;\n      this.attributeNamespace = null;\n      this.oldValue = null;\n    }\n    function registerTransientObservers(ancestor, node) {\n      for (;ancestor; ancestor = ancestor.parentNode) {\n        var registrations = registrationsTable.get(ancestor);\n        if (!registrations) continue;\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.options.subtree) registration.addTransientObserver(node);\n        }\n      }\n    }\n    function removeTransientObserversFor(observer) {\n      for (var i = 0; i < observer.nodes_.length; i++) {\n        var node = observer.nodes_[i];\n        var registrations = registrationsTable.get(node);\n        if (!registrations) return;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          if (registration.observer === observer) registration.removeTransientObservers();\n        }\n      }\n    }\n    function enqueueMutation(target, type, data) {\n      var interestedObservers = Object.create(null);\n      var associatedStrings = Object.create(null);\n      for (var node = target; node; node = node.parentNode) {\n        var registrations = registrationsTable.get(node);\n        if (!registrations) continue;\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          if (type === \"attributes\" && !options.attributes) continue;\n          if (type === \"attributes\" && options.attributeFilter && (data.namespace !== null || options.attributeFilter.indexOf(data.name) === -1)) {\n            continue;\n          }\n          if (type === \"characterData\" && !options.characterData) continue;\n          if (type === \"childList\" && !options.childList) continue;\n          var observer = registration.observer;\n          interestedObservers[observer.uid_] = observer;\n          if (type === \"attributes\" && options.attributeOldValue || type === \"characterData\" && options.characterDataOldValue) {\n            associatedStrings[observer.uid_] = data.oldValue;\n          }\n        }\n      }\n      for (var uid in interestedObservers) {\n        var observer = interestedObservers[uid];\n        var record = new MutationRecord(type, target);\n        if (\"name\" in data && \"namespace\" in data) {\n          record.attributeName = data.name;\n          record.attributeNamespace = data.namespace;\n        }\n        if (data.addedNodes) record.addedNodes = data.addedNodes;\n        if (data.removedNodes) record.removedNodes = data.removedNodes;\n        if (data.previousSibling) record.previousSibling = data.previousSibling;\n        if (data.nextSibling) record.nextSibling = data.nextSibling;\n        if (associatedStrings[uid] !== undefined) record.oldValue = associatedStrings[uid];\n        scheduleCallback(observer);\n        observer.records_.push(record);\n      }\n    }\n    var slice = Array.prototype.slice;\n    function MutationObserverOptions(options) {\n      this.childList = !!options.childList;\n      this.subtree = !!options.subtree;\n      if (!(\"attributes\" in options) && (\"attributeOldValue\" in options || \"attributeFilter\" in options)) {\n        this.attributes = true;\n      } else {\n        this.attributes = !!options.attributes;\n      }\n      if (\"characterDataOldValue\" in options && !(\"characterData\" in options)) this.characterData = true; else this.characterData = !!options.characterData;\n      if (!this.attributes && (options.attributeOldValue || \"attributeFilter\" in options) || !this.characterData && options.characterDataOldValue) {\n        throw new TypeError();\n      }\n      this.characterData = !!options.characterData;\n      this.attributeOldValue = !!options.attributeOldValue;\n      this.characterDataOldValue = !!options.characterDataOldValue;\n      if (\"attributeFilter\" in options) {\n        if (options.attributeFilter == null || typeof options.attributeFilter !== \"object\") {\n          throw new TypeError();\n        }\n        this.attributeFilter = slice.call(options.attributeFilter);\n      } else {\n        this.attributeFilter = null;\n      }\n    }\n    var uidCounter = 0;\n    function MutationObserver(callback) {\n      this.callback_ = callback;\n      this.nodes_ = [];\n      this.records_ = [];\n      this.uid_ = ++uidCounter;\n      this.scheduled_ = false;\n    }\n    MutationObserver.prototype = {\n      constructor: MutationObserver,\n      observe: function(target, options) {\n        target = wrapIfNeeded(target);\n        var newOptions = new MutationObserverOptions(options);\n        var registration;\n        var registrations = registrationsTable.get(target);\n        if (!registrations) registrationsTable.set(target, registrations = []);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i].observer === this) {\n            registration = registrations[i];\n            registration.removeTransientObservers();\n            registration.options = newOptions;\n          }\n        }\n        if (!registration) {\n          registration = new Registration(this, target, newOptions);\n          registrations.push(registration);\n          this.nodes_.push(target);\n        }\n      },\n      disconnect: function() {\n        this.nodes_.forEach(function(node) {\n          var registrations = registrationsTable.get(node);\n          for (var i = 0; i < registrations.length; i++) {\n            var registration = registrations[i];\n            if (registration.observer === this) {\n              registrations.splice(i, 1);\n              break;\n            }\n          }\n        }, this);\n        this.records_ = [];\n      },\n      takeRecords: function() {\n        var copyOfRecords = this.records_;\n        this.records_ = [];\n        return copyOfRecords;\n      }\n    };\n    function Registration(observer, target, options) {\n      this.observer = observer;\n      this.target = target;\n      this.options = options;\n      this.transientObservedNodes = [];\n    }\n    Registration.prototype = {\n      addTransientObserver: function(node) {\n        if (node === this.target) return;\n        scheduleCallback(this.observer);\n        this.transientObservedNodes.push(node);\n        var registrations = registrationsTable.get(node);\n        if (!registrations) registrationsTable.set(node, registrations = []);\n        registrations.push(this);\n      },\n      removeTransientObservers: function() {\n        var transientObservedNodes = this.transientObservedNodes;\n        this.transientObservedNodes = [];\n        for (var i = 0; i < transientObservedNodes.length; i++) {\n          var node = transientObservedNodes[i];\n          var registrations = registrationsTable.get(node);\n          for (var j = 0; j < registrations.length; j++) {\n            if (registrations[j] === this) {\n              registrations.splice(j, 1);\n              break;\n            }\n          }\n        }\n      }\n    };\n    scope.enqueueMutation = enqueueMutation;\n    scope.registerTransientObservers = registerTransientObservers;\n    scope.wrappers.MutationObserver = MutationObserver;\n    scope.wrappers.MutationRecord = MutationRecord;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    function TreeScope(root, parent) {\n      this.root = root;\n      this.parent = parent;\n    }\n    TreeScope.prototype = {\n      get renderer() {\n        if (this.root instanceof scope.wrappers.ShadowRoot) {\n          return scope.getRendererForHost(this.root.host);\n        }\n        return null;\n      },\n      contains: function(treeScope) {\n        for (;treeScope; treeScope = treeScope.parent) {\n          if (treeScope === this) return true;\n        }\n        return false;\n      }\n    };\n    function setTreeScope(node, treeScope) {\n      if (node.treeScope_ !== treeScope) {\n        node.treeScope_ = treeScope;\n        for (var sr = node.shadowRoot; sr; sr = sr.olderShadowRoot) {\n          sr.treeScope_.parent = treeScope;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          setTreeScope(child, treeScope);\n        }\n      }\n    }\n    function getTreeScope(node) {\n      if (node instanceof scope.wrappers.Window) {\n        debugger;\n      }\n      if (node.treeScope_) return node.treeScope_;\n      var parent = node.parentNode;\n      var treeScope;\n      if (parent) treeScope = getTreeScope(parent); else treeScope = new TreeScope(node, null);\n      return node.treeScope_ = treeScope;\n    }\n    scope.TreeScope = TreeScope;\n    scope.getTreeScope = getTreeScope;\n    scope.setTreeScope = setTreeScope;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var wrappedFuns = new WeakMap();\n    var listenersTable = new WeakMap();\n    var handledEventsTable = new WeakMap();\n    var currentlyDispatchingEvents = new WeakMap();\n    var targetTable = new WeakMap();\n    var currentTargetTable = new WeakMap();\n    var relatedTargetTable = new WeakMap();\n    var eventPhaseTable = new WeakMap();\n    var stopPropagationTable = new WeakMap();\n    var stopImmediatePropagationTable = new WeakMap();\n    var eventHandlersTable = new WeakMap();\n    var eventPathTable = new WeakMap();\n    function isShadowRoot(node) {\n      return node instanceof wrappers.ShadowRoot;\n    }\n    function rootOfNode(node) {\n      return getTreeScope(node).root;\n    }\n    function getEventPath(node, event) {\n      var path = [];\n      var current = node;\n      path.push(current);\n      while (current) {\n        var destinationInsertionPoints = getDestinationInsertionPoints(current);\n        if (destinationInsertionPoints && destinationInsertionPoints.length > 0) {\n          for (var i = 0; i < destinationInsertionPoints.length; i++) {\n            var insertionPoint = destinationInsertionPoints[i];\n            if (isShadowInsertionPoint(insertionPoint)) {\n              var shadowRoot = rootOfNode(insertionPoint);\n              var olderShadowRoot = shadowRoot.olderShadowRoot;\n              if (olderShadowRoot) path.push(olderShadowRoot);\n            }\n            path.push(insertionPoint);\n          }\n          current = destinationInsertionPoints[destinationInsertionPoints.length - 1];\n        } else {\n          if (isShadowRoot(current)) {\n            if (inSameTree(node, current) && eventMustBeStopped(event)) {\n              break;\n            }\n            current = current.host;\n            path.push(current);\n          } else {\n            current = current.parentNode;\n            if (current) path.push(current);\n          }\n        }\n      }\n      return path;\n    }\n    function eventMustBeStopped(event) {\n      if (!event) return false;\n      switch (event.type) {\n       case \"abort\":\n       case \"error\":\n       case \"select\":\n       case \"change\":\n       case \"load\":\n       case \"reset\":\n       case \"resize\":\n       case \"scroll\":\n       case \"selectstart\":\n        return true;\n      }\n      return false;\n    }\n    function isShadowInsertionPoint(node) {\n      return node instanceof HTMLShadowElement;\n    }\n    function getDestinationInsertionPoints(node) {\n      return scope.getDestinationInsertionPoints(node);\n    }\n    function eventRetargetting(path, currentTarget) {\n      if (path.length === 0) return currentTarget;\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var originalTarget = path[0];\n      var originalTargetTree = getTreeScope(originalTarget);\n      var relativeTargetTree = lowestCommonInclusiveAncestor(currentTargetTree, originalTargetTree);\n      for (var i = 0; i < path.length; i++) {\n        var node = path[i];\n        if (getTreeScope(node) === relativeTargetTree) return node;\n      }\n      return path[path.length - 1];\n    }\n    function getTreeScopeAncestors(treeScope) {\n      var ancestors = [];\n      for (;treeScope; treeScope = treeScope.parent) {\n        ancestors.push(treeScope);\n      }\n      return ancestors;\n    }\n    function lowestCommonInclusiveAncestor(tsA, tsB) {\n      var ancestorsA = getTreeScopeAncestors(tsA);\n      var ancestorsB = getTreeScopeAncestors(tsB);\n      var result = null;\n      while (ancestorsA.length > 0 && ancestorsB.length > 0) {\n        var a = ancestorsA.pop();\n        var b = ancestorsB.pop();\n        if (a === b) result = a; else break;\n      }\n      return result;\n    }\n    function getTreeScopeRoot(ts) {\n      if (!ts.parent) return ts;\n      return getTreeScopeRoot(ts.parent);\n    }\n    function relatedTargetResolution(event, currentTarget, relatedTarget) {\n      if (currentTarget instanceof wrappers.Window) currentTarget = currentTarget.document;\n      var currentTargetTree = getTreeScope(currentTarget);\n      var relatedTargetTree = getTreeScope(relatedTarget);\n      var relatedTargetEventPath = getEventPath(relatedTarget, event);\n      var lowestCommonAncestorTree;\n      var lowestCommonAncestorTree = lowestCommonInclusiveAncestor(currentTargetTree, relatedTargetTree);\n      if (!lowestCommonAncestorTree) lowestCommonAncestorTree = relatedTargetTree.root;\n      for (var commonAncestorTree = lowestCommonAncestorTree; commonAncestorTree; commonAncestorTree = commonAncestorTree.parent) {\n        var adjustedRelatedTarget;\n        for (var i = 0; i < relatedTargetEventPath.length; i++) {\n          var node = relatedTargetEventPath[i];\n          if (getTreeScope(node) === commonAncestorTree) return node;\n        }\n      }\n      return null;\n    }\n    function inSameTree(a, b) {\n      return getTreeScope(a) === getTreeScope(b);\n    }\n    var NONE = 0;\n    var CAPTURING_PHASE = 1;\n    var AT_TARGET = 2;\n    var BUBBLING_PHASE = 3;\n    var pendingError;\n    function dispatchOriginalEvent(originalEvent) {\n      if (handledEventsTable.get(originalEvent)) return;\n      handledEventsTable.set(originalEvent, true);\n      dispatchEvent(wrap(originalEvent), wrap(originalEvent.target));\n      if (pendingError) {\n        var err = pendingError;\n        pendingError = null;\n        throw err;\n      }\n    }\n    function isLoadLikeEvent(event) {\n      switch (event.type) {\n       case \"load\":\n       case \"beforeunload\":\n       case \"unload\":\n        return true;\n      }\n      return false;\n    }\n    function dispatchEvent(event, originalWrapperTarget) {\n      if (currentlyDispatchingEvents.get(event)) throw new Error(\"InvalidStateError\");\n      currentlyDispatchingEvents.set(event, true);\n      scope.renderAllPending();\n      var eventPath;\n      var overrideTarget;\n      var win;\n      if (isLoadLikeEvent(event) && !event.bubbles) {\n        var doc = originalWrapperTarget;\n        if (doc instanceof wrappers.Document && (win = doc.defaultView)) {\n          overrideTarget = doc;\n          eventPath = [];\n        }\n      }\n      if (!eventPath) {\n        if (originalWrapperTarget instanceof wrappers.Window) {\n          win = originalWrapperTarget;\n          eventPath = [];\n        } else {\n          eventPath = getEventPath(originalWrapperTarget, event);\n          if (!isLoadLikeEvent(event)) {\n            var doc = eventPath[eventPath.length - 1];\n            if (doc instanceof wrappers.Document) win = doc.defaultView;\n          }\n        }\n      }\n      eventPathTable.set(event, eventPath);\n      if (dispatchCapturing(event, eventPath, win, overrideTarget)) {\n        if (dispatchAtTarget(event, eventPath, win, overrideTarget)) {\n          dispatchBubbling(event, eventPath, win, overrideTarget);\n        }\n      }\n      eventPhaseTable.set(event, NONE);\n      currentTargetTable.delete(event, null);\n      currentlyDispatchingEvents.delete(event);\n      return event.defaultPrevented;\n    }\n    function dispatchCapturing(event, eventPath, win, overrideTarget) {\n      var phase = CAPTURING_PHASE;\n      if (win) {\n        if (!invoke(win, event, phase, eventPath, overrideTarget)) return false;\n      }\n      for (var i = eventPath.length - 1; i > 0; i--) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return false;\n      }\n      return true;\n    }\n    function dispatchAtTarget(event, eventPath, win, overrideTarget) {\n      var phase = AT_TARGET;\n      var currentTarget = eventPath[0] || win;\n      return invoke(currentTarget, event, phase, eventPath, overrideTarget);\n    }\n    function dispatchBubbling(event, eventPath, win, overrideTarget) {\n      var phase = BUBBLING_PHASE;\n      for (var i = 1; i < eventPath.length; i++) {\n        if (!invoke(eventPath[i], event, phase, eventPath, overrideTarget)) return;\n      }\n      if (win && eventPath.length > 0) {\n        invoke(win, event, phase, eventPath, overrideTarget);\n      }\n    }\n    function invoke(currentTarget, event, phase, eventPath, overrideTarget) {\n      var listeners = listenersTable.get(currentTarget);\n      if (!listeners) return true;\n      var target = overrideTarget || eventRetargetting(eventPath, currentTarget);\n      if (target === currentTarget) {\n        if (phase === CAPTURING_PHASE) return true;\n        if (phase === BUBBLING_PHASE) phase = AT_TARGET;\n      } else if (phase === BUBBLING_PHASE && !event.bubbles) {\n        return true;\n      }\n      if (\"relatedTarget\" in event) {\n        var originalEvent = unwrap(event);\n        var unwrappedRelatedTarget = originalEvent.relatedTarget;\n        if (unwrappedRelatedTarget) {\n          if (unwrappedRelatedTarget instanceof Object && unwrappedRelatedTarget.addEventListener) {\n            var relatedTarget = wrap(unwrappedRelatedTarget);\n            var adjusted = relatedTargetResolution(event, currentTarget, relatedTarget);\n            if (adjusted === target) return true;\n          } else {\n            adjusted = null;\n          }\n          relatedTargetTable.set(event, adjusted);\n        }\n      }\n      eventPhaseTable.set(event, phase);\n      var type = event.type;\n      var anyRemoved = false;\n      targetTable.set(event, target);\n      currentTargetTable.set(event, currentTarget);\n      listeners.depth++;\n      for (var i = 0, len = listeners.length; i < len; i++) {\n        var listener = listeners[i];\n        if (listener.removed) {\n          anyRemoved = true;\n          continue;\n        }\n        if (listener.type !== type || !listener.capture && phase === CAPTURING_PHASE || listener.capture && phase === BUBBLING_PHASE) {\n          continue;\n        }\n        try {\n          if (typeof listener.handler === \"function\") listener.handler.call(currentTarget, event); else listener.handler.handleEvent(event);\n          if (stopImmediatePropagationTable.get(event)) return false;\n        } catch (ex) {\n          if (!pendingError) pendingError = ex;\n        }\n      }\n      listeners.depth--;\n      if (anyRemoved && listeners.depth === 0) {\n        var copy = listeners.slice();\n        listeners.length = 0;\n        for (var i = 0; i < copy.length; i++) {\n          if (!copy[i].removed) listeners.push(copy[i]);\n        }\n      }\n      return !stopPropagationTable.get(event);\n    }\n    function Listener(type, handler, capture) {\n      this.type = type;\n      this.handler = handler;\n      this.capture = Boolean(capture);\n    }\n    Listener.prototype = {\n      equals: function(that) {\n        return this.handler === that.handler && this.type === that.type && this.capture === that.capture;\n      },\n      get removed() {\n        return this.handler === null;\n      },\n      remove: function() {\n        this.handler = null;\n      }\n    };\n    var OriginalEvent = window.Event;\n    OriginalEvent.prototype.polymerBlackList_ = {\n      returnValue: true,\n      keyLocation: true\n    };\n    function Event(type, options) {\n      if (type instanceof OriginalEvent) {\n        var impl = type;\n        if (!OriginalBeforeUnloadEvent && impl.type === \"beforeunload\" && !(this instanceof BeforeUnloadEvent)) {\n          return new BeforeUnloadEvent(impl);\n        }\n        setWrapper(impl, this);\n      } else {\n        return wrap(constructEvent(OriginalEvent, \"Event\", type, options));\n      }\n    }\n    Event.prototype = {\n      get target() {\n        return targetTable.get(this);\n      },\n      get currentTarget() {\n        return currentTargetTable.get(this);\n      },\n      get eventPhase() {\n        return eventPhaseTable.get(this);\n      },\n      get path() {\n        var eventPath = eventPathTable.get(this);\n        if (!eventPath) return [];\n        return eventPath.slice();\n      },\n      stopPropagation: function() {\n        stopPropagationTable.set(this, true);\n      },\n      stopImmediatePropagation: function() {\n        stopPropagationTable.set(this, true);\n        stopImmediatePropagationTable.set(this, true);\n      }\n    };\n    registerWrapper(OriginalEvent, Event, document.createEvent(\"Event\"));\n    function unwrapOptions(options) {\n      if (!options || !options.relatedTarget) return options;\n      return Object.create(options, {\n        relatedTarget: {\n          value: unwrap(options.relatedTarget)\n        }\n      });\n    }\n    function registerGenericEvent(name, SuperEvent, prototype) {\n      var OriginalEvent = window[name];\n      var GenericEvent = function(type, options) {\n        if (type instanceof OriginalEvent) setWrapper(type, this); else return wrap(constructEvent(OriginalEvent, name, type, options));\n      };\n      GenericEvent.prototype = Object.create(SuperEvent.prototype);\n      if (prototype) mixin(GenericEvent.prototype, prototype);\n      if (OriginalEvent) {\n        try {\n          registerWrapper(OriginalEvent, GenericEvent, new OriginalEvent(\"temp\"));\n        } catch (ex) {\n          registerWrapper(OriginalEvent, GenericEvent, document.createEvent(name));\n        }\n      }\n      return GenericEvent;\n    }\n    var UIEvent = registerGenericEvent(\"UIEvent\", Event);\n    var CustomEvent = registerGenericEvent(\"CustomEvent\", Event);\n    var relatedTargetProto = {\n      get relatedTarget() {\n        var relatedTarget = relatedTargetTable.get(this);\n        if (relatedTarget !== undefined) return relatedTarget;\n        return wrap(unwrap(this).relatedTarget);\n      }\n    };\n    function getInitFunction(name, relatedTargetIndex) {\n      return function() {\n        arguments[relatedTargetIndex] = unwrap(arguments[relatedTargetIndex]);\n        var impl = unwrap(this);\n        impl[name].apply(impl, arguments);\n      };\n    }\n    var mouseEventProto = mixin({\n      initMouseEvent: getInitFunction(\"initMouseEvent\", 14)\n    }, relatedTargetProto);\n    var focusEventProto = mixin({\n      initFocusEvent: getInitFunction(\"initFocusEvent\", 5)\n    }, relatedTargetProto);\n    var MouseEvent = registerGenericEvent(\"MouseEvent\", UIEvent, mouseEventProto);\n    var FocusEvent = registerGenericEvent(\"FocusEvent\", UIEvent, focusEventProto);\n    var defaultInitDicts = Object.create(null);\n    var supportsEventConstructors = function() {\n      try {\n        new window.FocusEvent(\"focus\");\n      } catch (ex) {\n        return false;\n      }\n      return true;\n    }();\n    function constructEvent(OriginalEvent, name, type, options) {\n      if (supportsEventConstructors) return new OriginalEvent(type, unwrapOptions(options));\n      var event = unwrap(document.createEvent(name));\n      var defaultDict = defaultInitDicts[name];\n      var args = [ type ];\n      Object.keys(defaultDict).forEach(function(key) {\n        var v = options != null && key in options ? options[key] : defaultDict[key];\n        if (key === \"relatedTarget\") v = unwrap(v);\n        args.push(v);\n      });\n      event[\"init\" + name].apply(event, args);\n      return event;\n    }\n    if (!supportsEventConstructors) {\n      var configureEventConstructor = function(name, initDict, superName) {\n        if (superName) {\n          var superDict = defaultInitDicts[superName];\n          initDict = mixin(mixin({}, superDict), initDict);\n        }\n        defaultInitDicts[name] = initDict;\n      };\n      configureEventConstructor(\"Event\", {\n        bubbles: false,\n        cancelable: false\n      });\n      configureEventConstructor(\"CustomEvent\", {\n        detail: null\n      }, \"Event\");\n      configureEventConstructor(\"UIEvent\", {\n        view: null,\n        detail: 0\n      }, \"Event\");\n      configureEventConstructor(\"MouseEvent\", {\n        screenX: 0,\n        screenY: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        altKey: false,\n        shiftKey: false,\n        metaKey: false,\n        button: 0,\n        relatedTarget: null\n      }, \"UIEvent\");\n      configureEventConstructor(\"FocusEvent\", {\n        relatedTarget: null\n      }, \"UIEvent\");\n    }\n    var OriginalBeforeUnloadEvent = window.BeforeUnloadEvent;\n    function BeforeUnloadEvent(impl) {\n      Event.call(this, impl);\n    }\n    BeforeUnloadEvent.prototype = Object.create(Event.prototype);\n    mixin(BeforeUnloadEvent.prototype, {\n      get returnValue() {\n        return unsafeUnwrap(this).returnValue;\n      },\n      set returnValue(v) {\n        unsafeUnwrap(this).returnValue = v;\n      }\n    });\n    if (OriginalBeforeUnloadEvent) registerWrapper(OriginalBeforeUnloadEvent, BeforeUnloadEvent);\n    function isValidListener(fun) {\n      if (typeof fun === \"function\") return true;\n      return fun && fun.handleEvent;\n    }\n    function isMutationEvent(type) {\n      switch (type) {\n       case \"DOMAttrModified\":\n       case \"DOMAttributeNameChanged\":\n       case \"DOMCharacterDataModified\":\n       case \"DOMElementNameChanged\":\n       case \"DOMNodeInserted\":\n       case \"DOMNodeInsertedIntoDocument\":\n       case \"DOMNodeRemoved\":\n       case \"DOMNodeRemovedFromDocument\":\n       case \"DOMSubtreeModified\":\n        return true;\n      }\n      return false;\n    }\n    var OriginalEventTarget = window.EventTarget;\n    function EventTarget(impl) {\n      setWrapper(impl, this);\n    }\n    var methodNames = [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ];\n    [ Node, Window ].forEach(function(constructor) {\n      var p = constructor.prototype;\n      methodNames.forEach(function(name) {\n        Object.defineProperty(p, name + \"_\", {\n          value: p[name]\n        });\n      });\n    });\n    function getTargetToListenAt(wrapper) {\n      if (wrapper instanceof wrappers.ShadowRoot) wrapper = wrapper.host;\n      return unwrap(wrapper);\n    }\n    EventTarget.prototype = {\n      addEventListener: function(type, fun, capture) {\n        if (!isValidListener(fun) || isMutationEvent(type)) return;\n        var listener = new Listener(type, fun, capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) {\n          listeners = [];\n          listeners.depth = 0;\n          listenersTable.set(this, listeners);\n        } else {\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener.equals(listeners[i])) return;\n          }\n        }\n        listeners.push(listener);\n        var target = getTargetToListenAt(this);\n        target.addEventListener_(type, dispatchOriginalEvent, true);\n      },\n      removeEventListener: function(type, fun, capture) {\n        capture = Boolean(capture);\n        var listeners = listenersTable.get(this);\n        if (!listeners) return;\n        var count = 0, found = false;\n        for (var i = 0; i < listeners.length; i++) {\n          if (listeners[i].type === type && listeners[i].capture === capture) {\n            count++;\n            if (listeners[i].handler === fun) {\n              found = true;\n              listeners[i].remove();\n            }\n          }\n        }\n        if (found && count === 1) {\n          var target = getTargetToListenAt(this);\n          target.removeEventListener_(type, dispatchOriginalEvent, true);\n        }\n      },\n      dispatchEvent: function(event) {\n        var nativeEvent = unwrap(event);\n        var eventType = nativeEvent.type;\n        handledEventsTable.set(nativeEvent, false);\n        scope.renderAllPending();\n        var tempListener;\n        if (!hasListenerInAncestors(this, eventType)) {\n          tempListener = function() {};\n          this.addEventListener(eventType, tempListener, true);\n        }\n        try {\n          return unwrap(this).dispatchEvent_(nativeEvent);\n        } finally {\n          if (tempListener) this.removeEventListener(eventType, tempListener, true);\n        }\n      }\n    };\n    function hasListener(node, type) {\n      var listeners = listenersTable.get(node);\n      if (listeners) {\n        for (var i = 0; i < listeners.length; i++) {\n          if (!listeners[i].removed && listeners[i].type === type) return true;\n        }\n      }\n      return false;\n    }\n    function hasListenerInAncestors(target, type) {\n      for (var node = unwrap(target); node; node = node.parentNode) {\n        if (hasListener(wrap(node), type)) return true;\n      }\n      return false;\n    }\n    if (OriginalEventTarget) registerWrapper(OriginalEventTarget, EventTarget);\n    function wrapEventTargetMethods(constructors) {\n      forwardMethodsToWrapper(constructors, methodNames);\n    }\n    var originalElementFromPoint = document.elementFromPoint;\n    function elementFromPoint(self, document, x, y) {\n      scope.renderAllPending();\n      var element = wrap(originalElementFromPoint.call(unsafeUnwrap(document), x, y));\n      if (!element) return null;\n      var path = getEventPath(element, null);\n      var idx = path.lastIndexOf(self);\n      if (idx == -1) return null; else path = path.slice(0, idx);\n      return eventRetargetting(path, self);\n    }\n    function getEventHandlerGetter(name) {\n      return function() {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        return inlineEventHandlers && inlineEventHandlers[name] && inlineEventHandlers[name].value || null;\n      };\n    }\n    function getEventHandlerSetter(name) {\n      var eventType = name.slice(2);\n      return function(value) {\n        var inlineEventHandlers = eventHandlersTable.get(this);\n        if (!inlineEventHandlers) {\n          inlineEventHandlers = Object.create(null);\n          eventHandlersTable.set(this, inlineEventHandlers);\n        }\n        var old = inlineEventHandlers[name];\n        if (old) this.removeEventListener(eventType, old.wrapped, false);\n        if (typeof value === \"function\") {\n          var wrapped = function(e) {\n            var rv = value.call(this, e);\n            if (rv === false) e.preventDefault(); else if (name === \"onbeforeunload\" && typeof rv === \"string\") e.returnValue = rv;\n          };\n          this.addEventListener(eventType, wrapped, false);\n          inlineEventHandlers[name] = {\n            value: value,\n            wrapped: wrapped\n          };\n        }\n      };\n    }\n    scope.elementFromPoint = elementFromPoint;\n    scope.getEventHandlerGetter = getEventHandlerGetter;\n    scope.getEventHandlerSetter = getEventHandlerSetter;\n    scope.wrapEventTargetMethods = wrapEventTargetMethods;\n    scope.wrappers.BeforeUnloadEvent = BeforeUnloadEvent;\n    scope.wrappers.CustomEvent = CustomEvent;\n    scope.wrappers.Event = Event;\n    scope.wrappers.EventTarget = EventTarget;\n    scope.wrappers.FocusEvent = FocusEvent;\n    scope.wrappers.MouseEvent = MouseEvent;\n    scope.wrappers.UIEvent = UIEvent;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var UIEvent = scope.wrappers.UIEvent;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalTouchEvent = window.TouchEvent;\n    if (!OriginalTouchEvent) return;\n    var nativeEvent;\n    try {\n      nativeEvent = document.createEvent(\"TouchEvent\");\n    } catch (ex) {\n      return;\n    }\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function Touch(impl) {\n      setWrapper(impl, this);\n    }\n    Touch.prototype = {\n      get target() {\n        return wrap(unsafeUnwrap(this).target);\n      }\n    };\n    var descr = {\n      configurable: true,\n      enumerable: true,\n      get: null\n    };\n    [ \"clientX\", \"clientY\", \"screenX\", \"screenY\", \"pageX\", \"pageY\", \"identifier\", \"webkitRadiusX\", \"webkitRadiusY\", \"webkitRotationAngle\", \"webkitForce\" ].forEach(function(name) {\n      descr.get = function() {\n        return unsafeUnwrap(this)[name];\n      };\n      Object.defineProperty(Touch.prototype, name, descr);\n    });\n    function TouchList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    TouchList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    function wrapTouchList(nativeTouchList) {\n      var list = new TouchList();\n      for (var i = 0; i < nativeTouchList.length; i++) {\n        list[i] = new Touch(nativeTouchList[i]);\n      }\n      list.length = i;\n      return list;\n    }\n    function TouchEvent(impl) {\n      UIEvent.call(this, impl);\n    }\n    TouchEvent.prototype = Object.create(UIEvent.prototype);\n    mixin(TouchEvent.prototype, {\n      get touches() {\n        return wrapTouchList(unsafeUnwrap(this).touches);\n      },\n      get targetTouches() {\n        return wrapTouchList(unsafeUnwrap(this).targetTouches);\n      },\n      get changedTouches() {\n        return wrapTouchList(unsafeUnwrap(this).changedTouches);\n      },\n      initTouchEvent: function() {\n        throw new Error(\"Not implemented\");\n      }\n    });\n    registerWrapper(OriginalTouchEvent, TouchEvent, nativeEvent);\n    scope.wrappers.Touch = Touch;\n    scope.wrappers.TouchEvent = TouchEvent;\n    scope.wrappers.TouchList = TouchList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var nonEnumDescriptor = {\n      enumerable: false\n    };\n    function nonEnum(obj, prop) {\n      Object.defineProperty(obj, prop, nonEnumDescriptor);\n    }\n    function NodeList() {\n      this.length = 0;\n      nonEnum(this, \"length\");\n    }\n    NodeList.prototype = {\n      item: function(index) {\n        return this[index];\n      }\n    };\n    nonEnum(NodeList.prototype, \"item\");\n    function wrapNodeList(list) {\n      if (list == null) return list;\n      var wrapperList = new NodeList();\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrapperList[i] = wrap(list[i]);\n      }\n      wrapperList.length = length;\n      return wrapperList;\n    }\n    function addWrapNodeListMethod(wrapperConstructor, name) {\n      wrapperConstructor.prototype[name] = function() {\n        return wrapNodeList(unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    scope.wrappers.NodeList = NodeList;\n    scope.addWrapNodeListMethod = addWrapNodeListMethod;\n    scope.wrapNodeList = wrapNodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    scope.wrapHTMLCollection = scope.wrapNodeList;\n    scope.wrappers.HTMLCollection = scope.wrappers.NodeList;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var NodeList = scope.wrappers.NodeList;\n    var TreeScope = scope.TreeScope;\n    var assert = scope.assert;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var getTreeScope = scope.getTreeScope;\n    var isWrapper = scope.isWrapper;\n    var mixin = scope.mixin;\n    var registerTransientObservers = scope.registerTransientObservers;\n    var registerWrapper = scope.registerWrapper;\n    var setTreeScope = scope.setTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var wrapIfNeeded = scope.wrapIfNeeded;\n    var wrappers = scope.wrappers;\n    function assertIsNodeWrapper(node) {\n      assert(node instanceof Node);\n    }\n    function createOneElementNodeList(node) {\n      var nodes = new NodeList();\n      nodes[0] = node;\n      nodes.length = 1;\n      return nodes;\n    }\n    var surpressMutations = false;\n    function enqueueRemovalForInsertedNodes(node, parent, nodes) {\n      enqueueMutation(parent, \"childList\", {\n        removedNodes: nodes,\n        previousSibling: node.previousSibling,\n        nextSibling: node.nextSibling\n      });\n    }\n    function enqueueRemovalForInsertedDocumentFragment(df, nodes) {\n      enqueueMutation(df, \"childList\", {\n        removedNodes: nodes\n      });\n    }\n    function collectNodes(node, parentNode, previousNode, nextNode) {\n      if (node instanceof DocumentFragment) {\n        var nodes = collectNodesForDocumentFragment(node);\n        surpressMutations = true;\n        for (var i = nodes.length - 1; i >= 0; i--) {\n          node.removeChild(nodes[i]);\n          nodes[i].parentNode_ = parentNode;\n        }\n        surpressMutations = false;\n        for (var i = 0; i < nodes.length; i++) {\n          nodes[i].previousSibling_ = nodes[i - 1] || previousNode;\n          nodes[i].nextSibling_ = nodes[i + 1] || nextNode;\n        }\n        if (previousNode) previousNode.nextSibling_ = nodes[0];\n        if (nextNode) nextNode.previousSibling_ = nodes[nodes.length - 1];\n        return nodes;\n      }\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) {\n        oldParent.removeChild(node);\n      }\n      node.parentNode_ = parentNode;\n      node.previousSibling_ = previousNode;\n      node.nextSibling_ = nextNode;\n      if (previousNode) previousNode.nextSibling_ = node;\n      if (nextNode) nextNode.previousSibling_ = node;\n      return nodes;\n    }\n    function collectNodesNative(node) {\n      if (node instanceof DocumentFragment) return collectNodesForDocumentFragment(node);\n      var nodes = createOneElementNodeList(node);\n      var oldParent = node.parentNode;\n      if (oldParent) enqueueRemovalForInsertedNodes(node, oldParent, nodes);\n      return nodes;\n    }\n    function collectNodesForDocumentFragment(node) {\n      var nodes = new NodeList();\n      var i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        nodes[i++] = child;\n      }\n      nodes.length = i;\n      enqueueRemovalForInsertedDocumentFragment(node, nodes);\n      return nodes;\n    }\n    function snapshotNodeList(nodeList) {\n      return nodeList;\n    }\n    function nodeWasAdded(node, treeScope) {\n      setTreeScope(node, treeScope);\n      node.nodeIsInserted_();\n    }\n    function nodesWereAdded(nodes, parent) {\n      var treeScope = getTreeScope(parent);\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasAdded(nodes[i], treeScope);\n      }\n    }\n    function nodeWasRemoved(node) {\n      setTreeScope(node, new TreeScope(node, null));\n    }\n    function nodesWereRemoved(nodes) {\n      for (var i = 0; i < nodes.length; i++) {\n        nodeWasRemoved(nodes[i]);\n      }\n    }\n    function ensureSameOwnerDocument(parent, child) {\n      var ownerDoc = parent.nodeType === Node.DOCUMENT_NODE ? parent : parent.ownerDocument;\n      if (ownerDoc !== child.ownerDocument) ownerDoc.adoptNode(child);\n    }\n    function adoptNodesIfNeeded(owner, nodes) {\n      if (!nodes.length) return;\n      var ownerDoc = owner.ownerDocument;\n      if (ownerDoc === nodes[0].ownerDocument) return;\n      for (var i = 0; i < nodes.length; i++) {\n        scope.adoptNodeNoRemove(nodes[i], ownerDoc);\n      }\n    }\n    function unwrapNodesForInsertion(owner, nodes) {\n      adoptNodesIfNeeded(owner, nodes);\n      var length = nodes.length;\n      if (length === 1) return unwrap(nodes[0]);\n      var df = unwrap(owner.ownerDocument.createDocumentFragment());\n      for (var i = 0; i < length; i++) {\n        df.appendChild(unwrap(nodes[i]));\n      }\n      return df;\n    }\n    function clearChildNodes(wrapper) {\n      if (wrapper.firstChild_ !== undefined) {\n        var child = wrapper.firstChild_;\n        while (child) {\n          var tmp = child;\n          child = child.nextSibling_;\n          tmp.parentNode_ = tmp.previousSibling_ = tmp.nextSibling_ = undefined;\n        }\n      }\n      wrapper.firstChild_ = wrapper.lastChild_ = undefined;\n    }\n    function removeAllChildNodes(wrapper) {\n      if (wrapper.invalidateShadowRenderer()) {\n        var childWrapper = wrapper.firstChild;\n        while (childWrapper) {\n          assert(childWrapper.parentNode === wrapper);\n          var nextSibling = childWrapper.nextSibling;\n          var childNode = unwrap(childWrapper);\n          var parentNode = childNode.parentNode;\n          if (parentNode) originalRemoveChild.call(parentNode, childNode);\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = null;\n          childWrapper = nextSibling;\n        }\n        wrapper.firstChild_ = wrapper.lastChild_ = null;\n      } else {\n        var node = unwrap(wrapper);\n        var child = node.firstChild;\n        var nextSibling;\n        while (child) {\n          nextSibling = child.nextSibling;\n          originalRemoveChild.call(node, child);\n          child = nextSibling;\n        }\n      }\n    }\n    function invalidateParent(node) {\n      var p = node.parentNode;\n      return p && p.invalidateShadowRenderer();\n    }\n    function cleanupNodes(nodes) {\n      for (var i = 0, n; i < nodes.length; i++) {\n        n = nodes[i];\n        n.parentNode.removeChild(n);\n      }\n    }\n    var originalImportNode = document.importNode;\n    var originalCloneNode = window.Node.prototype.cloneNode;\n    function cloneNode(node, deep, opt_doc) {\n      var clone;\n      if (opt_doc) clone = wrap(originalImportNode.call(opt_doc, unsafeUnwrap(node), false)); else clone = wrap(originalCloneNode.call(unsafeUnwrap(node), false));\n      if (deep) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          clone.appendChild(cloneNode(child, true, opt_doc));\n        }\n        if (node instanceof wrappers.HTMLTemplateElement) {\n          var cloneContent = clone.content;\n          for (var child = node.content.firstChild; child; child = child.nextSibling) {\n            cloneContent.appendChild(cloneNode(child, true, opt_doc));\n          }\n        }\n      }\n      return clone;\n    }\n    function contains(self, child) {\n      if (!child || getTreeScope(self) !== getTreeScope(child)) return false;\n      for (var node = child; node; node = node.parentNode) {\n        if (node === self) return true;\n      }\n      return false;\n    }\n    var OriginalNode = window.Node;\n    function Node(original) {\n      assert(original instanceof OriginalNode);\n      EventTarget.call(this, original);\n      this.parentNode_ = undefined;\n      this.firstChild_ = undefined;\n      this.lastChild_ = undefined;\n      this.nextSibling_ = undefined;\n      this.previousSibling_ = undefined;\n      this.treeScope_ = undefined;\n    }\n    var OriginalDocumentFragment = window.DocumentFragment;\n    var originalAppendChild = OriginalNode.prototype.appendChild;\n    var originalCompareDocumentPosition = OriginalNode.prototype.compareDocumentPosition;\n    var originalIsEqualNode = OriginalNode.prototype.isEqualNode;\n    var originalInsertBefore = OriginalNode.prototype.insertBefore;\n    var originalRemoveChild = OriginalNode.prototype.removeChild;\n    var originalReplaceChild = OriginalNode.prototype.replaceChild;\n    var isIEOrEdge = /Trident|Edge/.test(navigator.userAgent);\n    var removeChildOriginalHelper = isIEOrEdge ? function(parent, child) {\n      try {\n        originalRemoveChild.call(parent, child);\n      } catch (ex) {\n        if (!(parent instanceof OriginalDocumentFragment)) throw ex;\n      }\n    } : function(parent, child) {\n      originalRemoveChild.call(parent, child);\n    };\n    Node.prototype = Object.create(EventTarget.prototype);\n    mixin(Node.prototype, {\n      appendChild: function(childWrapper) {\n        return this.insertBefore(childWrapper, null);\n      },\n      insertBefore: function(childWrapper, refWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        var refNode;\n        if (refWrapper) {\n          if (isWrapper(refWrapper)) {\n            refNode = unwrap(refWrapper);\n          } else {\n            refNode = refWrapper;\n            refWrapper = wrap(refNode);\n          }\n        } else {\n          refWrapper = null;\n          refNode = null;\n        }\n        refWrapper && assert(refWrapper.parentNode === this);\n        var nodes;\n        var previousNode = refWrapper ? refWrapper.previousSibling : this.lastChild;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(childWrapper);\n        if (useNative) nodes = collectNodesNative(childWrapper); else nodes = collectNodes(childWrapper, this, previousNode, refWrapper);\n        if (useNative) {\n          ensureSameOwnerDocument(this, childWrapper);\n          clearChildNodes(this);\n          originalInsertBefore.call(unsafeUnwrap(this), unwrap(childWrapper), refNode);\n        } else {\n          if (!previousNode) this.firstChild_ = nodes[0];\n          if (!refWrapper) {\n            this.lastChild_ = nodes[nodes.length - 1];\n            if (this.firstChild_ === undefined) this.firstChild_ = this.firstChild;\n          }\n          var parentNode = refNode ? refNode.parentNode : unsafeUnwrap(this);\n          if (parentNode) {\n            originalInsertBefore.call(parentNode, unwrapNodesForInsertion(this, nodes), refNode);\n          } else {\n            adoptNodesIfNeeded(this, nodes);\n          }\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          nextSibling: refWrapper,\n          previousSibling: previousNode\n        });\n        nodesWereAdded(nodes, this);\n        return childWrapper;\n      },\n      removeChild: function(childWrapper) {\n        assertIsNodeWrapper(childWrapper);\n        if (childWrapper.parentNode !== this) {\n          var found = false;\n          var childNodes = this.childNodes;\n          for (var ieChild = this.firstChild; ieChild; ieChild = ieChild.nextSibling) {\n            if (ieChild === childWrapper) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            throw new Error(\"NotFoundError\");\n          }\n        }\n        var childNode = unwrap(childWrapper);\n        var childWrapperNextSibling = childWrapper.nextSibling;\n        var childWrapperPreviousSibling = childWrapper.previousSibling;\n        if (this.invalidateShadowRenderer()) {\n          var thisFirstChild = this.firstChild;\n          var thisLastChild = this.lastChild;\n          var parentNode = childNode.parentNode;\n          if (parentNode) removeChildOriginalHelper(parentNode, childNode);\n          if (thisFirstChild === childWrapper) this.firstChild_ = childWrapperNextSibling;\n          if (thisLastChild === childWrapper) this.lastChild_ = childWrapperPreviousSibling;\n          if (childWrapperPreviousSibling) childWrapperPreviousSibling.nextSibling_ = childWrapperNextSibling;\n          if (childWrapperNextSibling) {\n            childWrapperNextSibling.previousSibling_ = childWrapperPreviousSibling;\n          }\n          childWrapper.previousSibling_ = childWrapper.nextSibling_ = childWrapper.parentNode_ = undefined;\n        } else {\n          clearChildNodes(this);\n          removeChildOriginalHelper(unsafeUnwrap(this), childNode);\n        }\n        if (!surpressMutations) {\n          enqueueMutation(this, \"childList\", {\n            removedNodes: createOneElementNodeList(childWrapper),\n            nextSibling: childWrapperNextSibling,\n            previousSibling: childWrapperPreviousSibling\n          });\n        }\n        registerTransientObservers(this, childWrapper);\n        return childWrapper;\n      },\n      replaceChild: function(newChildWrapper, oldChildWrapper) {\n        assertIsNodeWrapper(newChildWrapper);\n        var oldChildNode;\n        if (isWrapper(oldChildWrapper)) {\n          oldChildNode = unwrap(oldChildWrapper);\n        } else {\n          oldChildNode = oldChildWrapper;\n          oldChildWrapper = wrap(oldChildNode);\n        }\n        if (oldChildWrapper.parentNode !== this) {\n          throw new Error(\"NotFoundError\");\n        }\n        var nextNode = oldChildWrapper.nextSibling;\n        var previousNode = oldChildWrapper.previousSibling;\n        var nodes;\n        var useNative = !this.invalidateShadowRenderer() && !invalidateParent(newChildWrapper);\n        if (useNative) {\n          nodes = collectNodesNative(newChildWrapper);\n        } else {\n          if (nextNode === newChildWrapper) nextNode = newChildWrapper.nextSibling;\n          nodes = collectNodes(newChildWrapper, this, previousNode, nextNode);\n        }\n        if (!useNative) {\n          if (this.firstChild === oldChildWrapper) this.firstChild_ = nodes[0];\n          if (this.lastChild === oldChildWrapper) this.lastChild_ = nodes[nodes.length - 1];\n          oldChildWrapper.previousSibling_ = oldChildWrapper.nextSibling_ = oldChildWrapper.parentNode_ = undefined;\n          if (oldChildNode.parentNode) {\n            originalReplaceChild.call(oldChildNode.parentNode, unwrapNodesForInsertion(this, nodes), oldChildNode);\n          }\n        } else {\n          ensureSameOwnerDocument(this, newChildWrapper);\n          clearChildNodes(this);\n          originalReplaceChild.call(unsafeUnwrap(this), unwrap(newChildWrapper), oldChildNode);\n        }\n        enqueueMutation(this, \"childList\", {\n          addedNodes: nodes,\n          removedNodes: createOneElementNodeList(oldChildWrapper),\n          nextSibling: nextNode,\n          previousSibling: previousNode\n        });\n        nodeWasRemoved(oldChildWrapper);\n        nodesWereAdded(nodes, this);\n        return oldChildWrapper;\n      },\n      nodeIsInserted_: function() {\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          child.nodeIsInserted_();\n        }\n      },\n      hasChildNodes: function() {\n        return this.firstChild !== null;\n      },\n      get parentNode() {\n        return this.parentNode_ !== undefined ? this.parentNode_ : wrap(unsafeUnwrap(this).parentNode);\n      },\n      get firstChild() {\n        return this.firstChild_ !== undefined ? this.firstChild_ : wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return this.lastChild_ !== undefined ? this.lastChild_ : wrap(unsafeUnwrap(this).lastChild);\n      },\n      get nextSibling() {\n        return this.nextSibling_ !== undefined ? this.nextSibling_ : wrap(unsafeUnwrap(this).nextSibling);\n      },\n      get previousSibling() {\n        return this.previousSibling_ !== undefined ? this.previousSibling_ : wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get parentElement() {\n        var p = this.parentNode;\n        while (p && p.nodeType !== Node.ELEMENT_NODE) {\n          p = p.parentNode;\n        }\n        return p;\n      },\n      get textContent() {\n        var s = \"\";\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType != Node.COMMENT_NODE) {\n            s += child.textContent;\n          }\n        }\n        return s;\n      },\n      set textContent(textContent) {\n        if (textContent == null) textContent = \"\";\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          removeAllChildNodes(this);\n          if (textContent !== \"\") {\n            var textNode = unsafeUnwrap(this).ownerDocument.createTextNode(textContent);\n            this.appendChild(textNode);\n          }\n        } else {\n          clearChildNodes(this);\n          unsafeUnwrap(this).textContent = textContent;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get childNodes() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstChild; child; child = child.nextSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      cloneNode: function(deep) {\n        return cloneNode(this, deep);\n      },\n      contains: function(child) {\n        return contains(this, wrapIfNeeded(child));\n      },\n      compareDocumentPosition: function(otherNode) {\n        return originalCompareDocumentPosition.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      isEqualNode: function(otherNode) {\n        return originalIsEqualNode.call(unsafeUnwrap(this), unwrapIfNeeded(otherNode));\n      },\n      normalize: function() {\n        var nodes = snapshotNodeList(this.childNodes);\n        var remNodes = [];\n        var s = \"\";\n        var modNode;\n        for (var i = 0, n; i < nodes.length; i++) {\n          n = nodes[i];\n          if (n.nodeType === Node.TEXT_NODE) {\n            if (!modNode && !n.data.length) this.removeChild(n); else if (!modNode) modNode = n; else {\n              s += n.data;\n              remNodes.push(n);\n            }\n          } else {\n            if (modNode && remNodes.length) {\n              modNode.data += s;\n              cleanupNodes(remNodes);\n            }\n            remNodes = [];\n            s = \"\";\n            modNode = null;\n            if (n.childNodes.length) n.normalize();\n          }\n        }\n        if (modNode && remNodes.length) {\n          modNode.data += s;\n          cleanupNodes(remNodes);\n        }\n      }\n    });\n    defineWrapGetter(Node, \"ownerDocument\");\n    registerWrapper(OriginalNode, Node, document.createDocumentFragment());\n    delete Node.prototype.querySelector;\n    delete Node.prototype.querySelectorAll;\n    Node.prototype = mixin(Object.create(EventTarget.prototype), Node.prototype);\n    scope.cloneNode = cloneNode;\n    scope.nodeWasAdded = nodeWasAdded;\n    scope.nodeWasRemoved = nodeWasRemoved;\n    scope.nodesWereAdded = nodesWereAdded;\n    scope.nodesWereRemoved = nodesWereRemoved;\n    scope.originalInsertBefore = originalInsertBefore;\n    scope.originalRemoveChild = originalRemoveChild;\n    scope.snapshotNodeList = snapshotNodeList;\n    scope.wrappers.Node = Node;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLCollection = scope.wrappers.HTMLCollection;\n    var NodeList = scope.wrappers.NodeList;\n    var getTreeScope = scope.getTreeScope;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var originalDocumentQuerySelector = document.querySelector;\n    var originalElementQuerySelector = document.documentElement.querySelector;\n    var originalDocumentQuerySelectorAll = document.querySelectorAll;\n    var originalElementQuerySelectorAll = document.documentElement.querySelectorAll;\n    var originalDocumentGetElementsByTagName = document.getElementsByTagName;\n    var originalElementGetElementsByTagName = document.documentElement.getElementsByTagName;\n    var originalDocumentGetElementsByTagNameNS = document.getElementsByTagNameNS;\n    var originalElementGetElementsByTagNameNS = document.documentElement.getElementsByTagNameNS;\n    var OriginalElement = window.Element;\n    var OriginalDocument = window.HTMLDocument || window.Document;\n    function filterNodeList(list, index, result, deep) {\n      var wrappedItem = null;\n      var root = null;\n      for (var i = 0, length = list.length; i < length; i++) {\n        wrappedItem = wrap(list[i]);\n        if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            continue;\n          }\n        }\n        result[index++] = wrappedItem;\n      }\n      return index;\n    }\n    function shimSelector(selector) {\n      return String(selector).replace(/\\/deep\\/|::shadow|>>>/g, \" \");\n    }\n    function shimMatchesSelector(selector) {\n      return String(selector).replace(/:host\\(([^\\s]+)\\)/g, \"$1\").replace(/([^\\s]):host/g, \"$1\").replace(\":host\", \"*\").replace(/\\^|\\/shadow\\/|\\/shadow-deep\\/|::shadow|\\/deep\\/|::content|>>>/g, \" \");\n    }\n    function findOne(node, selector) {\n      var m, el = node.firstElementChild;\n      while (el) {\n        if (el.matches(selector)) return el;\n        m = findOne(el, selector);\n        if (m) return m;\n        el = el.nextElementSibling;\n      }\n      return null;\n    }\n    function matchesSelector(el, selector) {\n      return el.matches(selector);\n    }\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function matchesTagName(el, localName, localNameLowerCase) {\n      var ln = el.localName;\n      return ln === localName || ln === localNameLowerCase && el.namespaceURI === XHTML_NS;\n    }\n    function matchesEveryThing() {\n      return true;\n    }\n    function matchesLocalNameOnly(el, ns, localName) {\n      return el.localName === localName;\n    }\n    function matchesNameSpace(el, ns) {\n      return el.namespaceURI === ns;\n    }\n    function matchesLocalNameNS(el, ns, localName) {\n      return el.namespaceURI === ns && el.localName === localName;\n    }\n    function findElements(node, index, result, p, arg0, arg1) {\n      var el = node.firstElementChild;\n      while (el) {\n        if (p(el, arg0, arg1)) result[index++] = el;\n        index = findElements(el, index, result, p, arg0, arg1);\n        el = el.nextElementSibling;\n      }\n      return index;\n    }\n    function querySelectorAllFiltered(p, index, result, selector, deep) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, selector, null);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementQuerySelectorAll.call(target, selector);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentQuerySelectorAll.call(target, selector);\n      } else {\n        return findElements(this, index, result, p, selector, null);\n      }\n      return filterNodeList(list, index, result, deep);\n    }\n    var SelectorsInterface = {\n      querySelector: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var target = unsafeUnwrap(this);\n        var wrappedItem;\n        var root = getTreeScope(this).root;\n        if (root instanceof scope.wrappers.ShadowRoot) {\n          return findOne(this, selector);\n        } else if (target instanceof OriginalElement) {\n          wrappedItem = wrap(originalElementQuerySelector.call(target, selector));\n        } else if (target instanceof OriginalDocument) {\n          wrappedItem = wrap(originalDocumentQuerySelector.call(target, selector));\n        } else {\n          return findOne(this, selector);\n        }\n        if (!wrappedItem) {\n          return wrappedItem;\n        } else if (!deep && (root = getTreeScope(wrappedItem).root)) {\n          if (root instanceof scope.wrappers.ShadowRoot) {\n            return findOne(this, selector);\n          }\n        }\n        return wrappedItem;\n      },\n      querySelectorAll: function(selector) {\n        var shimmed = shimSelector(selector);\n        var deep = shimmed !== selector;\n        selector = shimmed;\n        var result = new NodeList();\n        result.length = querySelectorAllFiltered.call(this, matchesSelector, 0, result, selector, deep);\n        return result;\n      }\n    };\n    var MatchesInterface = {\n      matches: function(selector) {\n        selector = shimMatchesSelector(selector);\n        return scope.originalMatches.call(unsafeUnwrap(this), selector);\n      }\n    };\n    function getElementsByTagNameFiltered(p, index, result, localName, lowercase) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, localName, lowercase);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagName.call(target, localName, lowercase);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagName.call(target, localName, lowercase);\n      } else {\n        return findElements(this, index, result, p, localName, lowercase);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    function getElementsByTagNameNSFiltered(p, index, result, ns, localName) {\n      var target = unsafeUnwrap(this);\n      var list;\n      var root = getTreeScope(this).root;\n      if (root instanceof scope.wrappers.ShadowRoot) {\n        return findElements(this, index, result, p, ns, localName);\n      } else if (target instanceof OriginalElement) {\n        list = originalElementGetElementsByTagNameNS.call(target, ns, localName);\n      } else if (target instanceof OriginalDocument) {\n        list = originalDocumentGetElementsByTagNameNS.call(target, ns, localName);\n      } else {\n        return findElements(this, index, result, p, ns, localName);\n      }\n      return filterNodeList(list, index, result, false);\n    }\n    var GetElementsByInterface = {\n      getElementsByTagName: function(localName) {\n        var result = new HTMLCollection();\n        var match = localName === \"*\" ? matchesEveryThing : matchesTagName;\n        result.length = getElementsByTagNameFiltered.call(this, match, 0, result, localName, localName.toLowerCase());\n        return result;\n      },\n      getElementsByClassName: function(className) {\n        return this.querySelectorAll(\".\" + className);\n      },\n      getElementsByTagNameNS: function(ns, localName) {\n        var result = new HTMLCollection();\n        var match = null;\n        if (ns === \"*\") {\n          match = localName === \"*\" ? matchesEveryThing : matchesLocalNameOnly;\n        } else {\n          match = localName === \"*\" ? matchesNameSpace : matchesLocalNameNS;\n        }\n        result.length = getElementsByTagNameNSFiltered.call(this, match, 0, result, ns || null, localName);\n        return result;\n      }\n    };\n    scope.GetElementsByInterface = GetElementsByInterface;\n    scope.SelectorsInterface = SelectorsInterface;\n    scope.MatchesInterface = MatchesInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var NodeList = scope.wrappers.NodeList;\n    function forwardElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.nextSibling;\n      }\n      return node;\n    }\n    function backwardsElement(node) {\n      while (node && node.nodeType !== Node.ELEMENT_NODE) {\n        node = node.previousSibling;\n      }\n      return node;\n    }\n    var ParentNodeInterface = {\n      get firstElementChild() {\n        return forwardElement(this.firstChild);\n      },\n      get lastElementChild() {\n        return backwardsElement(this.lastChild);\n      },\n      get childElementCount() {\n        var count = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          count++;\n        }\n        return count;\n      },\n      get children() {\n        var wrapperList = new NodeList();\n        var i = 0;\n        for (var child = this.firstElementChild; child; child = child.nextElementSibling) {\n          wrapperList[i++] = child;\n        }\n        wrapperList.length = i;\n        return wrapperList;\n      },\n      remove: function() {\n        var p = this.parentNode;\n        if (p) p.removeChild(this);\n      }\n    };\n    var ChildNodeInterface = {\n      get nextElementSibling() {\n        return forwardElement(this.nextSibling);\n      },\n      get previousElementSibling() {\n        return backwardsElement(this.previousSibling);\n      }\n    };\n    var NonElementParentNodeInterface = {\n      getElementById: function(id) {\n        if (/[ \\t\\n\\r\\f]/.test(id)) return null;\n        return this.querySelector('[id=\"' + id + '\"]');\n      }\n    };\n    scope.ChildNodeInterface = ChildNodeInterface;\n    scope.NonElementParentNodeInterface = NonElementParentNodeInterface;\n    scope.ParentNodeInterface = ParentNodeInterface;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var Node = scope.wrappers.Node;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var OriginalCharacterData = window.CharacterData;\n    function CharacterData(node) {\n      Node.call(this, node);\n    }\n    CharacterData.prototype = Object.create(Node.prototype);\n    mixin(CharacterData.prototype, {\n      get nodeValue() {\n        return this.data;\n      },\n      set nodeValue(data) {\n        this.data = data;\n      },\n      get textContent() {\n        return this.data;\n      },\n      set textContent(value) {\n        this.data = value;\n      },\n      get data() {\n        return unsafeUnwrap(this).data;\n      },\n      set data(value) {\n        var oldValue = unsafeUnwrap(this).data;\n        enqueueMutation(this, \"characterData\", {\n          oldValue: oldValue\n        });\n        unsafeUnwrap(this).data = value;\n      }\n    });\n    mixin(CharacterData.prototype, ChildNodeInterface);\n    registerWrapper(OriginalCharacterData, CharacterData, document.createTextNode(\"\"));\n    scope.wrappers.CharacterData = CharacterData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var CharacterData = scope.wrappers.CharacterData;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    function toUInt32(x) {\n      return x >>> 0;\n    }\n    var OriginalText = window.Text;\n    function Text(node) {\n      CharacterData.call(this, node);\n    }\n    Text.prototype = Object.create(CharacterData.prototype);\n    mixin(Text.prototype, {\n      splitText: function(offset) {\n        offset = toUInt32(offset);\n        var s = this.data;\n        if (offset > s.length) throw new Error(\"IndexSizeError\");\n        var head = s.slice(0, offset);\n        var tail = s.slice(offset);\n        this.data = head;\n        var newTextNode = this.ownerDocument.createTextNode(tail);\n        if (this.parentNode) this.parentNode.insertBefore(newTextNode, this.nextSibling);\n        return newTextNode;\n      }\n    });\n    registerWrapper(OriginalText, Text, document.createTextNode(\"\"));\n    scope.wrappers.Text = Text;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    if (!window.DOMTokenList) {\n      console.warn(\"Missing DOMTokenList prototype, please include a \" + \"compatible classList polyfill such as http://goo.gl/uTcepH.\");\n      return;\n    }\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var enqueueMutation = scope.enqueueMutation;\n    function getClass(el) {\n      return unsafeUnwrap(el).getAttribute(\"class\");\n    }\n    function enqueueClassAttributeChange(el, oldValue) {\n      enqueueMutation(el, \"attributes\", {\n        name: \"class\",\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    function invalidateClass(el) {\n      scope.invalidateRendererBasedOnAttribute(el, \"class\");\n    }\n    function changeClass(tokenList, method, args) {\n      var ownerElement = tokenList.ownerElement_;\n      if (ownerElement == null) {\n        return method.apply(tokenList, args);\n      }\n      var oldValue = getClass(ownerElement);\n      var retv = method.apply(tokenList, args);\n      if (getClass(ownerElement) !== oldValue) {\n        enqueueClassAttributeChange(ownerElement, oldValue);\n        invalidateClass(ownerElement);\n      }\n      return retv;\n    }\n    var oldAdd = DOMTokenList.prototype.add;\n    DOMTokenList.prototype.add = function() {\n      changeClass(this, oldAdd, arguments);\n    };\n    var oldRemove = DOMTokenList.prototype.remove;\n    DOMTokenList.prototype.remove = function() {\n      changeClass(this, oldRemove, arguments);\n    };\n    var oldToggle = DOMTokenList.prototype.toggle;\n    DOMTokenList.prototype.toggle = function() {\n      return changeClass(this, oldToggle, arguments);\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var ChildNodeInterface = scope.ChildNodeInterface;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var MatchesInterface = scope.MatchesInterface;\n    var addWrapNodeListMethod = scope.addWrapNodeListMethod;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrappers = scope.wrappers;\n    var OriginalElement = window.Element;\n    var matchesNames = [ \"matches\", \"mozMatchesSelector\", \"msMatchesSelector\", \"webkitMatchesSelector\" ].filter(function(name) {\n      return OriginalElement.prototype[name];\n    });\n    var matchesName = matchesNames[0];\n    var originalMatches = OriginalElement.prototype[matchesName];\n    function invalidateRendererBasedOnAttribute(element, name) {\n      var p = element.parentNode;\n      if (!p || !p.shadowRoot) return;\n      var renderer = scope.getRendererForHost(p);\n      if (renderer.dependsOnAttribute(name)) renderer.invalidate();\n    }\n    function enqueAttributeChange(element, name, oldValue) {\n      enqueueMutation(element, \"attributes\", {\n        name: name,\n        namespace: null,\n        oldValue: oldValue\n      });\n    }\n    var classListTable = new WeakMap();\n    function Element(node) {\n      Node.call(this, node);\n    }\n    Element.prototype = Object.create(Node.prototype);\n    mixin(Element.prototype, {\n      createShadowRoot: function() {\n        var newShadowRoot = new wrappers.ShadowRoot(this);\n        unsafeUnwrap(this).polymerShadowRoot_ = newShadowRoot;\n        var renderer = scope.getRendererForHost(this);\n        renderer.invalidate();\n        return newShadowRoot;\n      },\n      get shadowRoot() {\n        return unsafeUnwrap(this).polymerShadowRoot_ || null;\n      },\n      setAttribute: function(name, value) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).setAttribute(name, value);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      removeAttribute: function(name) {\n        var oldValue = unsafeUnwrap(this).getAttribute(name);\n        unsafeUnwrap(this).removeAttribute(name);\n        enqueAttributeChange(this, name, oldValue);\n        invalidateRendererBasedOnAttribute(this, name);\n      },\n      get classList() {\n        var list = classListTable.get(this);\n        if (!list) {\n          list = unsafeUnwrap(this).classList;\n          if (!list) return;\n          list.ownerElement_ = this;\n          classListTable.set(this, list);\n        }\n        return list;\n      },\n      get className() {\n        return unsafeUnwrap(this).className;\n      },\n      set className(v) {\n        this.setAttribute(\"class\", v);\n      },\n      get id() {\n        return unsafeUnwrap(this).id;\n      },\n      set id(v) {\n        this.setAttribute(\"id\", v);\n      }\n    });\n    matchesNames.forEach(function(name) {\n      if (name !== \"matches\") {\n        Element.prototype[name] = function(selector) {\n          return this.matches(selector);\n        };\n      }\n    });\n    if (OriginalElement.prototype.webkitCreateShadowRoot) {\n      Element.prototype.webkitCreateShadowRoot = Element.prototype.createShadowRoot;\n    }\n    mixin(Element.prototype, ChildNodeInterface);\n    mixin(Element.prototype, GetElementsByInterface);\n    mixin(Element.prototype, ParentNodeInterface);\n    mixin(Element.prototype, SelectorsInterface);\n    mixin(Element.prototype, MatchesInterface);\n    registerWrapper(OriginalElement, Element, document.createElementNS(null, \"x\"));\n    scope.invalidateRendererBasedOnAttribute = invalidateRendererBasedOnAttribute;\n    scope.matchesNames = matchesNames;\n    scope.originalMatches = originalMatches;\n    scope.wrappers.Element = Element;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var defineGetter = scope.defineGetter;\n    var enqueueMutation = scope.enqueueMutation;\n    var mixin = scope.mixin;\n    var nodesWereAdded = scope.nodesWereAdded;\n    var nodesWereRemoved = scope.nodesWereRemoved;\n    var registerWrapper = scope.registerWrapper;\n    var snapshotNodeList = scope.snapshotNodeList;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrappers = scope.wrappers;\n    var escapeAttrRegExp = /[&\\u00A0\"]/g;\n    var escapeDataRegExp = /[&\\u00A0<>]/g;\n    function escapeReplace(c) {\n      switch (c) {\n       case \"&\":\n        return \"&amp;\";\n\n       case \"<\":\n        return \"&lt;\";\n\n       case \">\":\n        return \"&gt;\";\n\n       case '\"':\n        return \"&quot;\";\n\n       case \"\u00a0\":\n        return \"&nbsp;\";\n      }\n    }\n    function escapeAttr(s) {\n      return s.replace(escapeAttrRegExp, escapeReplace);\n    }\n    function escapeData(s) {\n      return s.replace(escapeDataRegExp, escapeReplace);\n    }\n    function makeSet(arr) {\n      var set = {};\n      for (var i = 0; i < arr.length; i++) {\n        set[arr[i]] = true;\n      }\n      return set;\n    }\n    var voidElements = makeSet([ \"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\" ]);\n    var plaintextParents = makeSet([ \"style\", \"script\", \"xmp\", \"iframe\", \"noembed\", \"noframes\", \"plaintext\", \"noscript\" ]);\n    var XHTML_NS = \"http://www.w3.org/1999/xhtml\";\n    function needsSelfClosingSlash(node) {\n      if (node.namespaceURI !== XHTML_NS) return true;\n      var doctype = node.ownerDocument.doctype;\n      return doctype && doctype.publicId && doctype.systemId;\n    }\n    function getOuterHTML(node, parentNode) {\n      switch (node.nodeType) {\n       case Node.ELEMENT_NODE:\n        var tagName = node.tagName.toLowerCase();\n        var s = \"<\" + tagName;\n        var attrs = node.attributes;\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += \" \" + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n        if (voidElements[tagName]) {\n          if (needsSelfClosingSlash(node)) s += \"/\";\n          return s + \">\";\n        }\n        return s + \">\" + getInnerHTML(node) + \"</\" + tagName + \">\";\n\n       case Node.TEXT_NODE:\n        var data = node.data;\n        if (parentNode && plaintextParents[parentNode.localName]) return data;\n        return escapeData(data);\n\n       case Node.COMMENT_NODE:\n        return \"<!--\" + node.data + \"-->\";\n\n       default:\n        console.error(node);\n        throw new Error(\"not implemented\");\n      }\n    }\n    function getInnerHTML(node) {\n      if (node instanceof wrappers.HTMLTemplateElement) node = node.content;\n      var s = \"\";\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        s += getOuterHTML(child, node);\n      }\n      return s;\n    }\n    function setInnerHTML(node, value, opt_tagName) {\n      var tagName = opt_tagName || \"div\";\n      node.textContent = \"\";\n      var tempElement = unwrap(node.ownerDocument.createElement(tagName));\n      tempElement.innerHTML = value;\n      var firstChild;\n      while (firstChild = tempElement.firstChild) {\n        node.appendChild(wrap(firstChild));\n      }\n    }\n    var oldIe = /MSIE/.test(navigator.userAgent);\n    var OriginalHTMLElement = window.HTMLElement;\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLElement(node) {\n      Element.call(this, node);\n    }\n    HTMLElement.prototype = Object.create(Element.prototype);\n    mixin(HTMLElement.prototype, {\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        if (oldIe && plaintextParents[this.localName]) {\n          this.textContent = value;\n          return;\n        }\n        var removedNodes = snapshotNodeList(this.childNodes);\n        if (this.invalidateShadowRenderer()) {\n          if (this instanceof wrappers.HTMLTemplateElement) setInnerHTML(this.content, value); else setInnerHTML(this, value, this.tagName);\n        } else if (!OriginalHTMLTemplateElement && this instanceof wrappers.HTMLTemplateElement) {\n          setInnerHTML(this.content, value);\n        } else {\n          unsafeUnwrap(this).innerHTML = value;\n        }\n        var addedNodes = snapshotNodeList(this.childNodes);\n        enqueueMutation(this, \"childList\", {\n          addedNodes: addedNodes,\n          removedNodes: removedNodes\n        });\n        nodesWereRemoved(removedNodes);\n        nodesWereAdded(addedNodes, this);\n      },\n      get outerHTML() {\n        return getOuterHTML(this, this.parentNode);\n      },\n      set outerHTML(value) {\n        var p = this.parentNode;\n        if (p) {\n          p.invalidateShadowRenderer();\n          var df = frag(p, value);\n          p.replaceChild(df, this);\n        }\n      },\n      insertAdjacentHTML: function(position, text) {\n        var contextElement, refNode;\n        switch (String(position).toLowerCase()) {\n         case \"beforebegin\":\n          contextElement = this.parentNode;\n          refNode = this;\n          break;\n\n         case \"afterend\":\n          contextElement = this.parentNode;\n          refNode = this.nextSibling;\n          break;\n\n         case \"afterbegin\":\n          contextElement = this;\n          refNode = this.firstChild;\n          break;\n\n         case \"beforeend\":\n          contextElement = this;\n          refNode = null;\n          break;\n\n         default:\n          return;\n        }\n        var df = frag(contextElement, text);\n        contextElement.insertBefore(df, refNode);\n      },\n      get hidden() {\n        return this.hasAttribute(\"hidden\");\n      },\n      set hidden(v) {\n        if (v) {\n          this.setAttribute(\"hidden\", \"\");\n        } else {\n          this.removeAttribute(\"hidden\");\n        }\n      }\n    });\n    function frag(contextElement, html) {\n      var p = unwrap(contextElement.cloneNode(false));\n      p.innerHTML = html;\n      var df = unwrap(document.createDocumentFragment());\n      var c;\n      while (c = p.firstChild) {\n        df.appendChild(c);\n      }\n      return wrap(df);\n    }\n    function getter(name) {\n      return function() {\n        scope.renderAllPending();\n        return unsafeUnwrap(this)[name];\n      };\n    }\n    function getterRequiresRendering(name) {\n      defineGetter(HTMLElement, name, getter(name));\n    }\n    [ \"clientHeight\", \"clientLeft\", \"clientTop\", \"clientWidth\", \"offsetHeight\", \"offsetLeft\", \"offsetTop\", \"offsetWidth\", \"scrollHeight\", \"scrollWidth\" ].forEach(getterRequiresRendering);\n    function getterAndSetterRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        get: getter(name),\n        set: function(v) {\n          scope.renderAllPending();\n          unsafeUnwrap(this)[name] = v;\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"scrollLeft\", \"scrollTop\" ].forEach(getterAndSetterRequiresRendering);\n    function methodRequiresRendering(name) {\n      Object.defineProperty(HTMLElement.prototype, name, {\n        value: function() {\n          scope.renderAllPending();\n          return unsafeUnwrap(this)[name].apply(unsafeUnwrap(this), arguments);\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n    [ \"getBoundingClientRect\", \"getClientRects\", \"scrollIntoView\" ].forEach(methodRequiresRendering);\n    registerWrapper(OriginalHTMLElement, HTMLElement, document.createElement(\"b\"));\n    scope.wrappers.HTMLElement = HTMLElement;\n    scope.getInnerHTML = getInnerHTML;\n    scope.setInnerHTML = setInnerHTML;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLCanvasElement = window.HTMLCanvasElement;\n    function HTMLCanvasElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLCanvasElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLCanvasElement.prototype, {\n      getContext: function() {\n        var context = unsafeUnwrap(this).getContext.apply(unsafeUnwrap(this), arguments);\n        return context && wrap(context);\n      }\n    });\n    registerWrapper(OriginalHTMLCanvasElement, HTMLCanvasElement, document.createElement(\"canvas\"));\n    scope.wrappers.HTMLCanvasElement = HTMLCanvasElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLContentElement = window.HTMLContentElement;\n    function HTMLContentElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLContentElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLContentElement.prototype, {\n      constructor: HTMLContentElement,\n      get select() {\n        return this.getAttribute(\"select\");\n      },\n      set select(value) {\n        this.setAttribute(\"select\", value);\n      },\n      setAttribute: function(n, v) {\n        HTMLElement.prototype.setAttribute.call(this, n, v);\n        if (String(n).toLowerCase() === \"select\") this.invalidateShadowRenderer(true);\n      }\n    });\n    if (OriginalHTMLContentElement) registerWrapper(OriginalHTMLContentElement, HTMLContentElement);\n    scope.wrappers.HTMLContentElement = HTMLContentElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var OriginalHTMLFormElement = window.HTMLFormElement;\n    function HTMLFormElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLFormElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLFormElement.prototype, {\n      get elements() {\n        return wrapHTMLCollection(unwrap(this).elements);\n      }\n    });\n    registerWrapper(OriginalHTMLFormElement, HTMLFormElement, document.createElement(\"form\"));\n    scope.wrappers.HTMLFormElement = HTMLFormElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLImageElement = window.HTMLImageElement;\n    function HTMLImageElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLImageElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLImageElement, HTMLImageElement, document.createElement(\"img\"));\n    function Image(width, height) {\n      if (!(this instanceof Image)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"img\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (width !== undefined) node.width = width;\n      if (height !== undefined) node.height = height;\n    }\n    Image.prototype = HTMLImageElement.prototype;\n    scope.wrappers.HTMLImageElement = HTMLImageElement;\n    scope.wrappers.Image = Image;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var NodeList = scope.wrappers.NodeList;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLShadowElement = window.HTMLShadowElement;\n    function HTMLShadowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLShadowElement.prototype = Object.create(HTMLElement.prototype);\n    HTMLShadowElement.prototype.constructor = HTMLShadowElement;\n    if (OriginalHTMLShadowElement) registerWrapper(OriginalHTMLShadowElement, HTMLShadowElement);\n    scope.wrappers.HTMLShadowElement = HTMLShadowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var contentTable = new WeakMap();\n    var templateContentsOwnerTable = new WeakMap();\n    function getTemplateContentsOwner(doc) {\n      if (!doc.defaultView) return doc;\n      var d = templateContentsOwnerTable.get(doc);\n      if (!d) {\n        d = doc.implementation.createHTMLDocument(\"\");\n        while (d.lastChild) {\n          d.removeChild(d.lastChild);\n        }\n        templateContentsOwnerTable.set(doc, d);\n      }\n      return d;\n    }\n    function extractContent(templateElement) {\n      var doc = getTemplateContentsOwner(templateElement.ownerDocument);\n      var df = unwrap(doc.createDocumentFragment());\n      var child;\n      while (child = templateElement.firstChild) {\n        df.appendChild(child);\n      }\n      return df;\n    }\n    var OriginalHTMLTemplateElement = window.HTMLTemplateElement;\n    function HTMLTemplateElement(node) {\n      HTMLElement.call(this, node);\n      if (!OriginalHTMLTemplateElement) {\n        var content = extractContent(node);\n        contentTable.set(this, wrap(content));\n      }\n    }\n    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTemplateElement.prototype, {\n      constructor: HTMLTemplateElement,\n      get content() {\n        if (OriginalHTMLTemplateElement) return wrap(unsafeUnwrap(this).content);\n        return contentTable.get(this);\n      }\n    });\n    if (OriginalHTMLTemplateElement) registerWrapper(OriginalHTMLTemplateElement, HTMLTemplateElement);\n    scope.wrappers.HTMLTemplateElement = HTMLTemplateElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLMediaElement = window.HTMLMediaElement;\n    if (!OriginalHTMLMediaElement) return;\n    function HTMLMediaElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLMediaElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLMediaElement, HTMLMediaElement, document.createElement(\"audio\"));\n    scope.wrappers.HTMLMediaElement = HTMLMediaElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLMediaElement = scope.wrappers.HTMLMediaElement;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var rewrap = scope.rewrap;\n    var OriginalHTMLAudioElement = window.HTMLAudioElement;\n    if (!OriginalHTMLAudioElement) return;\n    function HTMLAudioElement(node) {\n      HTMLMediaElement.call(this, node);\n    }\n    HTMLAudioElement.prototype = Object.create(HTMLMediaElement.prototype);\n    registerWrapper(OriginalHTMLAudioElement, HTMLAudioElement, document.createElement(\"audio\"));\n    function Audio(src) {\n      if (!(this instanceof Audio)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"audio\"));\n      HTMLMediaElement.call(this, node);\n      rewrap(node, this);\n      node.setAttribute(\"preload\", \"auto\");\n      if (src !== undefined) node.setAttribute(\"src\", src);\n    }\n    Audio.prototype = HTMLAudioElement.prototype;\n    scope.wrappers.HTMLAudioElement = HTMLAudioElement;\n    scope.wrappers.Audio = Audio;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var rewrap = scope.rewrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLOptionElement = window.HTMLOptionElement;\n    function trimText(s) {\n      return s.replace(/\\s+/g, \" \").trim();\n    }\n    function HTMLOptionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLOptionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLOptionElement.prototype, {\n      get text() {\n        return trimText(this.textContent);\n      },\n      set text(value) {\n        this.textContent = trimText(String(value));\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLOptionElement, HTMLOptionElement, document.createElement(\"option\"));\n    function Option(text, value, defaultSelected, selected) {\n      if (!(this instanceof Option)) {\n        throw new TypeError(\"DOM object constructor cannot be called as a function.\");\n      }\n      var node = unwrap(document.createElement(\"option\"));\n      HTMLElement.call(this, node);\n      rewrap(node, this);\n      if (text !== undefined) node.text = text;\n      if (value !== undefined) node.setAttribute(\"value\", value);\n      if (defaultSelected === true) node.setAttribute(\"selected\", \"\");\n      node.selected = selected === true;\n    }\n    Option.prototype = HTMLOptionElement.prototype;\n    scope.wrappers.HTMLOptionElement = HTMLOptionElement;\n    scope.wrappers.Option = Option;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLSelectElement = window.HTMLSelectElement;\n    function HTMLSelectElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLSelectElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLSelectElement.prototype, {\n      add: function(element, before) {\n        if (typeof before === \"object\") before = unwrap(before);\n        unwrap(this).add(unwrap(element), before);\n      },\n      remove: function(indexOrNode) {\n        if (indexOrNode === undefined) {\n          HTMLElement.prototype.remove.call(this);\n          return;\n        }\n        if (typeof indexOrNode === \"object\") indexOrNode = unwrap(indexOrNode);\n        unwrap(this).remove(indexOrNode);\n      },\n      get form() {\n        return wrap(unwrap(this).form);\n      }\n    });\n    registerWrapper(OriginalHTMLSelectElement, HTMLSelectElement, document.createElement(\"select\"));\n    scope.wrappers.HTMLSelectElement = HTMLSelectElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var OriginalHTMLTableElement = window.HTMLTableElement;\n    function HTMLTableElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableElement.prototype, {\n      get caption() {\n        return wrap(unwrap(this).caption);\n      },\n      createCaption: function() {\n        return wrap(unwrap(this).createCaption());\n      },\n      get tHead() {\n        return wrap(unwrap(this).tHead);\n      },\n      createTHead: function() {\n        return wrap(unwrap(this).createTHead());\n      },\n      createTFoot: function() {\n        return wrap(unwrap(this).createTFoot());\n      },\n      get tFoot() {\n        return wrap(unwrap(this).tFoot);\n      },\n      get tBodies() {\n        return wrapHTMLCollection(unwrap(this).tBodies);\n      },\n      createTBody: function() {\n        return wrap(unwrap(this).createTBody());\n      },\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableElement, HTMLTableElement, document.createElement(\"table\"));\n    scope.wrappers.HTMLTableElement = HTMLTableElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableSectionElement = window.HTMLTableSectionElement;\n    function HTMLTableSectionElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableSectionElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableSectionElement.prototype, {\n      constructor: HTMLTableSectionElement,\n      get rows() {\n        return wrapHTMLCollection(unwrap(this).rows);\n      },\n      insertRow: function(index) {\n        return wrap(unwrap(this).insertRow(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableSectionElement, HTMLTableSectionElement, document.createElement(\"thead\"));\n    scope.wrappers.HTMLTableSectionElement = HTMLTableSectionElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var wrapHTMLCollection = scope.wrapHTMLCollection;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalHTMLTableRowElement = window.HTMLTableRowElement;\n    function HTMLTableRowElement(node) {\n      HTMLElement.call(this, node);\n    }\n    HTMLTableRowElement.prototype = Object.create(HTMLElement.prototype);\n    mixin(HTMLTableRowElement.prototype, {\n      get cells() {\n        return wrapHTMLCollection(unwrap(this).cells);\n      },\n      insertCell: function(index) {\n        return wrap(unwrap(this).insertCell(index));\n      }\n    });\n    registerWrapper(OriginalHTMLTableRowElement, HTMLTableRowElement, document.createElement(\"tr\"));\n    scope.wrappers.HTMLTableRowElement = HTMLTableRowElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var HTMLTemplateElement = scope.wrappers.HTMLTemplateElement;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalHTMLUnknownElement = window.HTMLUnknownElement;\n    function HTMLUnknownElement(node) {\n      switch (node.localName) {\n       case \"content\":\n        return new HTMLContentElement(node);\n\n       case \"shadow\":\n        return new HTMLShadowElement(node);\n\n       case \"template\":\n        return new HTMLTemplateElement(node);\n      }\n      HTMLElement.call(this, node);\n    }\n    HTMLUnknownElement.prototype = Object.create(HTMLElement.prototype);\n    registerWrapper(OriginalHTMLUnknownElement, HTMLUnknownElement);\n    scope.wrappers.HTMLUnknownElement = HTMLUnknownElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var registerWrapper = scope.registerWrapper;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var mixin = scope.mixin;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var OriginalSVGElement = window.SVGElement;\n    var svgTitleElement = document.createElementNS(SVG_NS, \"title\");\n    if (!(\"classList\" in svgTitleElement)) {\n      var descr = Object.getOwnPropertyDescriptor(Element.prototype, \"classList\");\n      Object.defineProperty(HTMLElement.prototype, \"classList\", descr);\n      delete Element.prototype.classList;\n    }\n    function SVGElement(node) {\n      Element.call(this, node);\n    }\n    SVGElement.prototype = Object.create(Element.prototype);\n    mixin(SVGElement.prototype, {\n      get ownerSVGElement() {\n        return wrap(unsafeUnwrap(this).ownerSVGElement);\n      }\n    });\n    registerWrapper(OriginalSVGElement, SVGElement, document.createElementNS(SVG_NS, \"title\"));\n    scope.wrappers.SVGElement = SVGElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGUseElement = window.SVGUseElement;\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var gWrapper = wrap(document.createElementNS(SVG_NS, \"g\"));\n    var useElement = document.createElementNS(SVG_NS, \"use\");\n    var SVGGElement = gWrapper.constructor;\n    var parentInterfacePrototype = Object.getPrototypeOf(SVGGElement.prototype);\n    var parentInterface = parentInterfacePrototype.constructor;\n    function SVGUseElement(impl) {\n      parentInterface.call(this, impl);\n    }\n    SVGUseElement.prototype = Object.create(parentInterfacePrototype);\n    if (\"instanceRoot\" in useElement) {\n      mixin(SVGUseElement.prototype, {\n        get instanceRoot() {\n          return wrap(unwrap(this).instanceRoot);\n        },\n        get animatedInstanceRoot() {\n          return wrap(unwrap(this).animatedInstanceRoot);\n        }\n      });\n    }\n    registerWrapper(OriginalSVGUseElement, SVGUseElement, useElement);\n    scope.wrappers.SVGUseElement = SVGUseElement;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var wrap = scope.wrap;\n    var OriginalSVGElementInstance = window.SVGElementInstance;\n    if (!OriginalSVGElementInstance) return;\n    function SVGElementInstance(impl) {\n      EventTarget.call(this, impl);\n    }\n    SVGElementInstance.prototype = Object.create(EventTarget.prototype);\n    mixin(SVGElementInstance.prototype, {\n      get correspondingElement() {\n        return wrap(unsafeUnwrap(this).correspondingElement);\n      },\n      get correspondingUseElement() {\n        return wrap(unsafeUnwrap(this).correspondingUseElement);\n      },\n      get parentNode() {\n        return wrap(unsafeUnwrap(this).parentNode);\n      },\n      get childNodes() {\n        throw new Error(\"Not implemented\");\n      },\n      get firstChild() {\n        return wrap(unsafeUnwrap(this).firstChild);\n      },\n      get lastChild() {\n        return wrap(unsafeUnwrap(this).lastChild);\n      },\n      get previousSibling() {\n        return wrap(unsafeUnwrap(this).previousSibling);\n      },\n      get nextSibling() {\n        return wrap(unsafeUnwrap(this).nextSibling);\n      }\n    });\n    registerWrapper(OriginalSVGElementInstance, SVGElementInstance);\n    scope.wrappers.SVGElementInstance = SVGElementInstance;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalCanvasRenderingContext2D = window.CanvasRenderingContext2D;\n    function CanvasRenderingContext2D(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(CanvasRenderingContext2D.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      drawImage: function() {\n        arguments[0] = unwrapIfNeeded(arguments[0]);\n        unsafeUnwrap(this).drawImage.apply(unsafeUnwrap(this), arguments);\n      },\n      createPattern: function() {\n        arguments[0] = unwrap(arguments[0]);\n        return unsafeUnwrap(this).createPattern.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    registerWrapper(OriginalCanvasRenderingContext2D, CanvasRenderingContext2D, document.createElement(\"canvas\").getContext(\"2d\"));\n    scope.wrappers.CanvasRenderingContext2D = CanvasRenderingContext2D;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWebGLRenderingContext = window.WebGLRenderingContext;\n    if (!OriginalWebGLRenderingContext) return;\n    function WebGLRenderingContext(impl) {\n      setWrapper(impl, this);\n    }\n    mixin(WebGLRenderingContext.prototype, {\n      get canvas() {\n        return wrap(unsafeUnwrap(this).canvas);\n      },\n      texImage2D: function() {\n        arguments[5] = unwrapIfNeeded(arguments[5]);\n        unsafeUnwrap(this).texImage2D.apply(unsafeUnwrap(this), arguments);\n      },\n      texSubImage2D: function() {\n        arguments[6] = unwrapIfNeeded(arguments[6]);\n        unsafeUnwrap(this).texSubImage2D.apply(unsafeUnwrap(this), arguments);\n      }\n    });\n    var instanceProperties = /WebKit/.test(navigator.userAgent) ? {\n      drawingBufferHeight: null,\n      drawingBufferWidth: null\n    } : {};\n    registerWrapper(OriginalWebGLRenderingContext, WebGLRenderingContext, instanceProperties);\n    scope.wrappers.WebGLRenderingContext = WebGLRenderingContext;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Node = scope.wrappers.Node;\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var mixin = scope.mixin;\n    var registerObject = scope.registerObject;\n    var registerWrapper = scope.registerWrapper;\n    var OriginalDocumentFragment = window.DocumentFragment;\n    function DocumentFragment(node) {\n      Node.call(this, node);\n    }\n    DocumentFragment.prototype = Object.create(Node.prototype);\n    mixin(DocumentFragment.prototype, ParentNodeInterface);\n    mixin(DocumentFragment.prototype, SelectorsInterface);\n    mixin(DocumentFragment.prototype, GetElementsByInterface);\n    mixin(DocumentFragment.prototype, NonElementParentNodeInterface);\n    registerWrapper(OriginalDocumentFragment, DocumentFragment, document.createDocumentFragment());\n    scope.wrappers.DocumentFragment = DocumentFragment;\n    var Comment = registerObject(document.createComment(\"\"));\n    scope.wrappers.Comment = Comment;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var DocumentFragment = scope.wrappers.DocumentFragment;\n    var TreeScope = scope.TreeScope;\n    var elementFromPoint = scope.elementFromPoint;\n    var getInnerHTML = scope.getInnerHTML;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var rewrap = scope.rewrap;\n    var setInnerHTML = scope.setInnerHTML;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var shadowHostTable = new WeakMap();\n    var nextOlderShadowTreeTable = new WeakMap();\n    function ShadowRoot(hostWrapper) {\n      var node = unwrap(unsafeUnwrap(hostWrapper).ownerDocument.createDocumentFragment());\n      DocumentFragment.call(this, node);\n      rewrap(node, this);\n      var oldShadowRoot = hostWrapper.shadowRoot;\n      nextOlderShadowTreeTable.set(this, oldShadowRoot);\n      this.treeScope_ = new TreeScope(this, getTreeScope(oldShadowRoot || hostWrapper));\n      shadowHostTable.set(this, hostWrapper);\n    }\n    ShadowRoot.prototype = Object.create(DocumentFragment.prototype);\n    mixin(ShadowRoot.prototype, {\n      constructor: ShadowRoot,\n      get innerHTML() {\n        return getInnerHTML(this);\n      },\n      set innerHTML(value) {\n        setInnerHTML(this, value);\n        this.invalidateShadowRenderer();\n      },\n      get olderShadowRoot() {\n        return nextOlderShadowTreeTable.get(this) || null;\n      },\n      get host() {\n        return shadowHostTable.get(this) || null;\n      },\n      invalidateShadowRenderer: function() {\n        return shadowHostTable.get(this).invalidateShadowRenderer();\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this.ownerDocument, x, y);\n      }\n    });\n    scope.wrappers.ShadowRoot = ShadowRoot;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var getTreeScope = scope.getTreeScope;\n    var OriginalRange = window.Range;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    function getHost(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) {\n        return root.host;\n      }\n      return null;\n    }\n    function hostNodeToShadowNode(refNode, offset) {\n      if (refNode.shadowRoot) {\n        offset = Math.min(refNode.childNodes.length - 1, offset);\n        var child = refNode.childNodes[offset];\n        if (child) {\n          var insertionPoint = scope.getDestinationInsertionPoints(child);\n          if (insertionPoint.length > 0) {\n            var parentNode = insertionPoint[0].parentNode;\n            if (parentNode.nodeType == Node.ELEMENT_NODE) {\n              refNode = parentNode;\n            }\n          }\n        }\n      }\n      return refNode;\n    }\n    function shadowNodeToHostNode(node) {\n      node = wrap(node);\n      return getHost(node) || node;\n    }\n    function Range(impl) {\n      setWrapper(impl, this);\n    }\n    Range.prototype = {\n      get startContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).startContainer);\n      },\n      get endContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).endContainer);\n      },\n      get commonAncestorContainer() {\n        return shadowNodeToHostNode(unsafeUnwrap(this).commonAncestorContainer);\n      },\n      setStart: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setStart(unwrapIfNeeded(refNode), offset);\n      },\n      setEnd: function(refNode, offset) {\n        refNode = hostNodeToShadowNode(refNode, offset);\n        unsafeUnwrap(this).setEnd(unwrapIfNeeded(refNode), offset);\n      },\n      setStartBefore: function(refNode) {\n        unsafeUnwrap(this).setStartBefore(unwrapIfNeeded(refNode));\n      },\n      setStartAfter: function(refNode) {\n        unsafeUnwrap(this).setStartAfter(unwrapIfNeeded(refNode));\n      },\n      setEndBefore: function(refNode) {\n        unsafeUnwrap(this).setEndBefore(unwrapIfNeeded(refNode));\n      },\n      setEndAfter: function(refNode) {\n        unsafeUnwrap(this).setEndAfter(unwrapIfNeeded(refNode));\n      },\n      selectNode: function(refNode) {\n        unsafeUnwrap(this).selectNode(unwrapIfNeeded(refNode));\n      },\n      selectNodeContents: function(refNode) {\n        unsafeUnwrap(this).selectNodeContents(unwrapIfNeeded(refNode));\n      },\n      compareBoundaryPoints: function(how, sourceRange) {\n        return unsafeUnwrap(this).compareBoundaryPoints(how, unwrap(sourceRange));\n      },\n      extractContents: function() {\n        return wrap(unsafeUnwrap(this).extractContents());\n      },\n      cloneContents: function() {\n        return wrap(unsafeUnwrap(this).cloneContents());\n      },\n      insertNode: function(node) {\n        unsafeUnwrap(this).insertNode(unwrapIfNeeded(node));\n      },\n      surroundContents: function(newParent) {\n        unsafeUnwrap(this).surroundContents(unwrapIfNeeded(newParent));\n      },\n      cloneRange: function() {\n        return wrap(unsafeUnwrap(this).cloneRange());\n      },\n      isPointInRange: function(node, offset) {\n        return unsafeUnwrap(this).isPointInRange(unwrapIfNeeded(node), offset);\n      },\n      comparePoint: function(node, offset) {\n        return unsafeUnwrap(this).comparePoint(unwrapIfNeeded(node), offset);\n      },\n      intersectsNode: function(node) {\n        return unsafeUnwrap(this).intersectsNode(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalRange.prototype.createContextualFragment) {\n      Range.prototype.createContextualFragment = function(html) {\n        return wrap(unsafeUnwrap(this).createContextualFragment(html));\n      };\n    }\n    registerWrapper(window.Range, Range, document.createRange());\n    scope.wrappers.Range = Range;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var Element = scope.wrappers.Element;\n    var HTMLContentElement = scope.wrappers.HTMLContentElement;\n    var HTMLShadowElement = scope.wrappers.HTMLShadowElement;\n    var Node = scope.wrappers.Node;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var assert = scope.assert;\n    var getTreeScope = scope.getTreeScope;\n    var mixin = scope.mixin;\n    var oneOf = scope.oneOf;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var ArraySplice = scope.ArraySplice;\n    function updateWrapperUpAndSideways(wrapper) {\n      wrapper.previousSibling_ = wrapper.previousSibling;\n      wrapper.nextSibling_ = wrapper.nextSibling;\n      wrapper.parentNode_ = wrapper.parentNode;\n    }\n    function updateWrapperDown(wrapper) {\n      wrapper.firstChild_ = wrapper.firstChild;\n      wrapper.lastChild_ = wrapper.lastChild;\n    }\n    function updateAllChildNodes(parentNodeWrapper) {\n      assert(parentNodeWrapper instanceof Node);\n      for (var childWrapper = parentNodeWrapper.firstChild; childWrapper; childWrapper = childWrapper.nextSibling) {\n        updateWrapperUpAndSideways(childWrapper);\n      }\n      updateWrapperDown(parentNodeWrapper);\n    }\n    function insertBefore(parentNodeWrapper, newChildWrapper, refChildWrapper) {\n      var parentNode = unwrap(parentNodeWrapper);\n      var newChild = unwrap(newChildWrapper);\n      var refChild = refChildWrapper ? unwrap(refChildWrapper) : null;\n      remove(newChildWrapper);\n      updateWrapperUpAndSideways(newChildWrapper);\n      if (!refChildWrapper) {\n        parentNodeWrapper.lastChild_ = parentNodeWrapper.lastChild;\n        if (parentNodeWrapper.lastChild === parentNodeWrapper.firstChild) parentNodeWrapper.firstChild_ = parentNodeWrapper.firstChild;\n        var lastChildWrapper = wrap(parentNode.lastChild);\n        if (lastChildWrapper) lastChildWrapper.nextSibling_ = lastChildWrapper.nextSibling;\n      } else {\n        if (parentNodeWrapper.firstChild === refChildWrapper) parentNodeWrapper.firstChild_ = refChildWrapper;\n        refChildWrapper.previousSibling_ = refChildWrapper.previousSibling;\n      }\n      scope.originalInsertBefore.call(parentNode, newChild, refChild);\n    }\n    function remove(nodeWrapper) {\n      var node = unwrap(nodeWrapper);\n      var parentNode = node.parentNode;\n      if (!parentNode) return;\n      var parentNodeWrapper = wrap(parentNode);\n      updateWrapperUpAndSideways(nodeWrapper);\n      if (nodeWrapper.previousSibling) nodeWrapper.previousSibling.nextSibling_ = nodeWrapper;\n      if (nodeWrapper.nextSibling) nodeWrapper.nextSibling.previousSibling_ = nodeWrapper;\n      if (parentNodeWrapper.lastChild === nodeWrapper) parentNodeWrapper.lastChild_ = nodeWrapper;\n      if (parentNodeWrapper.firstChild === nodeWrapper) parentNodeWrapper.firstChild_ = nodeWrapper;\n      scope.originalRemoveChild.call(parentNode, node);\n    }\n    var distributedNodesTable = new WeakMap();\n    var destinationInsertionPointsTable = new WeakMap();\n    var rendererForHostTable = new WeakMap();\n    function resetDistributedNodes(insertionPoint) {\n      distributedNodesTable.set(insertionPoint, []);\n    }\n    function getDistributedNodes(insertionPoint) {\n      var rv = distributedNodesTable.get(insertionPoint);\n      if (!rv) distributedNodesTable.set(insertionPoint, rv = []);\n      return rv;\n    }\n    function getChildNodesSnapshot(node) {\n      var result = [], i = 0;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        result[i++] = child;\n      }\n      return result;\n    }\n    var request = oneOf(window, [ \"requestAnimationFrame\", \"mozRequestAnimationFrame\", \"webkitRequestAnimationFrame\", \"setTimeout\" ]);\n    var pendingDirtyRenderers = [];\n    var renderTimer;\n    function renderAllPending() {\n      for (var i = 0; i < pendingDirtyRenderers.length; i++) {\n        var renderer = pendingDirtyRenderers[i];\n        var parentRenderer = renderer.parentRenderer;\n        if (parentRenderer && parentRenderer.dirty) continue;\n        renderer.render();\n      }\n      pendingDirtyRenderers = [];\n    }\n    function handleRequestAnimationFrame() {\n      renderTimer = null;\n      renderAllPending();\n    }\n    function getRendererForHost(host) {\n      var renderer = rendererForHostTable.get(host);\n      if (!renderer) {\n        renderer = new ShadowRenderer(host);\n        rendererForHostTable.set(host, renderer);\n      }\n      return renderer;\n    }\n    function getShadowRootAncestor(node) {\n      var root = getTreeScope(node).root;\n      if (root instanceof ShadowRoot) return root;\n      return null;\n    }\n    function getRendererForShadowRoot(shadowRoot) {\n      return getRendererForHost(shadowRoot.host);\n    }\n    var spliceDiff = new ArraySplice();\n    spliceDiff.equals = function(renderNode, rawNode) {\n      return unwrap(renderNode.node) === rawNode;\n    };\n    function RenderNode(node) {\n      this.skip = false;\n      this.node = node;\n      this.childNodes = [];\n    }\n    RenderNode.prototype = {\n      append: function(node) {\n        var rv = new RenderNode(node);\n        this.childNodes.push(rv);\n        return rv;\n      },\n      sync: function(opt_added) {\n        if (this.skip) return;\n        var nodeWrapper = this.node;\n        var newChildren = this.childNodes;\n        var oldChildren = getChildNodesSnapshot(unwrap(nodeWrapper));\n        var added = opt_added || new WeakMap();\n        var splices = spliceDiff.calculateSplices(newChildren, oldChildren);\n        var newIndex = 0, oldIndex = 0;\n        var lastIndex = 0;\n        for (var i = 0; i < splices.length; i++) {\n          var splice = splices[i];\n          for (;lastIndex < splice.index; lastIndex++) {\n            oldIndex++;\n            newChildren[newIndex++].sync(added);\n          }\n          var removedCount = splice.removed.length;\n          for (var j = 0; j < removedCount; j++) {\n            var wrapper = wrap(oldChildren[oldIndex++]);\n            if (!added.get(wrapper)) remove(wrapper);\n          }\n          var addedCount = splice.addedCount;\n          var refNode = oldChildren[oldIndex] && wrap(oldChildren[oldIndex]);\n          for (var j = 0; j < addedCount; j++) {\n            var newChildRenderNode = newChildren[newIndex++];\n            var newChildWrapper = newChildRenderNode.node;\n            insertBefore(nodeWrapper, newChildWrapper, refNode);\n            added.set(newChildWrapper, true);\n            newChildRenderNode.sync(added);\n          }\n          lastIndex += addedCount;\n        }\n        for (var i = lastIndex; i < newChildren.length; i++) {\n          newChildren[i].sync(added);\n        }\n      }\n    };\n    function ShadowRenderer(host) {\n      this.host = host;\n      this.dirty = false;\n      this.invalidateAttributes();\n      this.associateNode(host);\n    }\n    ShadowRenderer.prototype = {\n      render: function(opt_renderNode) {\n        if (!this.dirty) return;\n        this.invalidateAttributes();\n        var host = this.host;\n        this.distribution(host);\n        var renderNode = opt_renderNode || new RenderNode(host);\n        this.buildRenderTree(renderNode, host);\n        var topMostRenderer = !opt_renderNode;\n        if (topMostRenderer) renderNode.sync();\n        this.dirty = false;\n      },\n      get parentRenderer() {\n        return getTreeScope(this.host).renderer;\n      },\n      invalidate: function() {\n        if (!this.dirty) {\n          this.dirty = true;\n          var parentRenderer = this.parentRenderer;\n          if (parentRenderer) parentRenderer.invalidate();\n          pendingDirtyRenderers.push(this);\n          if (renderTimer) return;\n          renderTimer = window[request](handleRequestAnimationFrame, 0);\n        }\n      },\n      distribution: function(root) {\n        this.resetAllSubtrees(root);\n        this.distributionResolution(root);\n      },\n      resetAll: function(node) {\n        if (isInsertionPoint(node)) resetDistributedNodes(node); else resetDestinationInsertionPoints(node);\n        this.resetAllSubtrees(node);\n      },\n      resetAllSubtrees: function(node) {\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.resetAll(child);\n        }\n        if (node.shadowRoot) this.resetAll(node.shadowRoot);\n        if (node.olderShadowRoot) this.resetAll(node.olderShadowRoot);\n      },\n      distributionResolution: function(node) {\n        if (isShadowHost(node)) {\n          var shadowHost = node;\n          var pool = poolPopulation(shadowHost);\n          var shadowTrees = getShadowTrees(shadowHost);\n          for (var i = 0; i < shadowTrees.length; i++) {\n            this.poolDistribution(shadowTrees[i], pool);\n          }\n          for (var i = shadowTrees.length - 1; i >= 0; i--) {\n            var shadowTree = shadowTrees[i];\n            var shadow = getShadowInsertionPoint(shadowTree);\n            if (shadow) {\n              var olderShadowRoot = shadowTree.olderShadowRoot;\n              if (olderShadowRoot) {\n                pool = poolPopulation(olderShadowRoot);\n              }\n              for (var j = 0; j < pool.length; j++) {\n                destributeNodeInto(pool[j], shadow);\n              }\n            }\n            this.distributionResolution(shadowTree);\n          }\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.distributionResolution(child);\n        }\n      },\n      poolDistribution: function(node, pool) {\n        if (node instanceof HTMLShadowElement) return;\n        if (node instanceof HTMLContentElement) {\n          var content = node;\n          this.updateDependentAttributes(content.getAttribute(\"select\"));\n          var anyDistributed = false;\n          for (var i = 0; i < pool.length; i++) {\n            var node = pool[i];\n            if (!node) continue;\n            if (matches(node, content)) {\n              destributeNodeInto(node, content);\n              pool[i] = undefined;\n              anyDistributed = true;\n            }\n          }\n          if (!anyDistributed) {\n            for (var child = content.firstChild; child; child = child.nextSibling) {\n              destributeNodeInto(child, content);\n            }\n          }\n          return;\n        }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          this.poolDistribution(child, pool);\n        }\n      },\n      buildRenderTree: function(renderNode, node) {\n        var children = this.compose(node);\n        for (var i = 0; i < children.length; i++) {\n          var child = children[i];\n          var childRenderNode = renderNode.append(child);\n          this.buildRenderTree(childRenderNode, child);\n        }\n        if (isShadowHost(node)) {\n          var renderer = getRendererForHost(node);\n          renderer.dirty = false;\n        }\n      },\n      compose: function(node) {\n        var children = [];\n        var p = node.shadowRoot || node;\n        for (var child = p.firstChild; child; child = child.nextSibling) {\n          if (isInsertionPoint(child)) {\n            this.associateNode(p);\n            var distributedNodes = getDistributedNodes(child);\n            for (var j = 0; j < distributedNodes.length; j++) {\n              var distributedNode = distributedNodes[j];\n              if (isFinalDestination(child, distributedNode)) children.push(distributedNode);\n            }\n          } else {\n            children.push(child);\n          }\n        }\n        return children;\n      },\n      invalidateAttributes: function() {\n        this.attributes = Object.create(null);\n      },\n      updateDependentAttributes: function(selector) {\n        if (!selector) return;\n        var attributes = this.attributes;\n        if (/\\.\\w+/.test(selector)) attributes[\"class\"] = true;\n        if (/#\\w+/.test(selector)) attributes[\"id\"] = true;\n        selector.replace(/\\[\\s*([^\\s=\\|~\\]]+)/g, function(_, name) {\n          attributes[name] = true;\n        });\n      },\n      dependsOnAttribute: function(name) {\n        return this.attributes[name];\n      },\n      associateNode: function(node) {\n        unsafeUnwrap(node).polymerShadowRenderer_ = this;\n      }\n    };\n    function poolPopulation(node) {\n      var pool = [];\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (isInsertionPoint(child)) {\n          pool.push.apply(pool, getDistributedNodes(child));\n        } else {\n          pool.push(child);\n        }\n      }\n      return pool;\n    }\n    function getShadowInsertionPoint(node) {\n      if (node instanceof HTMLShadowElement) return node;\n      if (node instanceof HTMLContentElement) return null;\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        var res = getShadowInsertionPoint(child);\n        if (res) return res;\n      }\n      return null;\n    }\n    function destributeNodeInto(child, insertionPoint) {\n      getDistributedNodes(insertionPoint).push(child);\n      var points = destinationInsertionPointsTable.get(child);\n      if (!points) destinationInsertionPointsTable.set(child, [ insertionPoint ]); else points.push(insertionPoint);\n    }\n    function getDestinationInsertionPoints(node) {\n      return destinationInsertionPointsTable.get(node);\n    }\n    function resetDestinationInsertionPoints(node) {\n      destinationInsertionPointsTable.set(node, undefined);\n    }\n    var selectorStartCharRe = /^(:not\\()?[*.#[a-zA-Z_|]/;\n    function matches(node, contentElement) {\n      var select = contentElement.getAttribute(\"select\");\n      if (!select) return true;\n      select = select.trim();\n      if (!select) return true;\n      if (!(node instanceof Element)) return false;\n      if (!selectorStartCharRe.test(select)) return false;\n      try {\n        return node.matches(select);\n      } catch (ex) {\n        return false;\n      }\n    }\n    function isFinalDestination(insertionPoint, node) {\n      var points = getDestinationInsertionPoints(node);\n      return points && points[points.length - 1] === insertionPoint;\n    }\n    function isInsertionPoint(node) {\n      return node instanceof HTMLContentElement || node instanceof HTMLShadowElement;\n    }\n    function isShadowHost(shadowHost) {\n      return shadowHost.shadowRoot;\n    }\n    function getShadowTrees(host) {\n      var trees = [];\n      for (var tree = host.shadowRoot; tree; tree = tree.olderShadowRoot) {\n        trees.push(tree);\n      }\n      return trees;\n    }\n    function render(host) {\n      new ShadowRenderer(host).render();\n    }\n    Node.prototype.invalidateShadowRenderer = function(force) {\n      var renderer = unsafeUnwrap(this).polymerShadowRenderer_;\n      if (renderer) {\n        renderer.invalidate();\n        return true;\n      }\n      return false;\n    };\n    HTMLContentElement.prototype.getDistributedNodes = HTMLShadowElement.prototype.getDistributedNodes = function() {\n      renderAllPending();\n      return getDistributedNodes(this);\n    };\n    Element.prototype.getDestinationInsertionPoints = function() {\n      renderAllPending();\n      return getDestinationInsertionPoints(this) || [];\n    };\n    HTMLContentElement.prototype.nodeIsInserted_ = HTMLShadowElement.prototype.nodeIsInserted_ = function() {\n      this.invalidateShadowRenderer();\n      var shadowRoot = getShadowRootAncestor(this);\n      var renderer;\n      if (shadowRoot) renderer = getRendererForShadowRoot(shadowRoot);\n      unsafeUnwrap(this).polymerShadowRenderer_ = renderer;\n      if (renderer) renderer.invalidate();\n    };\n    scope.getRendererForHost = getRendererForHost;\n    scope.getShadowTrees = getShadowTrees;\n    scope.renderAllPending = renderAllPending;\n    scope.getDestinationInsertionPoints = getDestinationInsertionPoints;\n    scope.visual = {\n      insertBefore: insertBefore,\n      remove: remove\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var HTMLElement = scope.wrappers.HTMLElement;\n    var assert = scope.assert;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var elementsWithFormProperty = [ \"HTMLButtonElement\", \"HTMLFieldSetElement\", \"HTMLInputElement\", \"HTMLKeygenElement\", \"HTMLLabelElement\", \"HTMLLegendElement\", \"HTMLObjectElement\", \"HTMLOutputElement\", \"HTMLTextAreaElement\" ];\n    function createWrapperConstructor(name) {\n      if (!window[name]) return;\n      assert(!scope.wrappers[name]);\n      var GeneratedWrapper = function(node) {\n        HTMLElement.call(this, node);\n      };\n      GeneratedWrapper.prototype = Object.create(HTMLElement.prototype);\n      mixin(GeneratedWrapper.prototype, {\n        get form() {\n          return wrap(unwrap(this).form);\n        }\n      });\n      registerWrapper(window[name], GeneratedWrapper, document.createElement(name.slice(4, -7)));\n      scope.wrappers[name] = GeneratedWrapper;\n    }\n    elementsWithFormProperty.forEach(createWrapperConstructor);\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalSelection = window.Selection;\n    function Selection(impl) {\n      setWrapper(impl, this);\n    }\n    Selection.prototype = {\n      get anchorNode() {\n        return wrap(unsafeUnwrap(this).anchorNode);\n      },\n      get focusNode() {\n        return wrap(unsafeUnwrap(this).focusNode);\n      },\n      addRange: function(range) {\n        unsafeUnwrap(this).addRange(unwrapIfNeeded(range));\n      },\n      collapse: function(node, index) {\n        unsafeUnwrap(this).collapse(unwrapIfNeeded(node), index);\n      },\n      containsNode: function(node, allowPartial) {\n        return unsafeUnwrap(this).containsNode(unwrapIfNeeded(node), allowPartial);\n      },\n      getRangeAt: function(index) {\n        return wrap(unsafeUnwrap(this).getRangeAt(index));\n      },\n      removeRange: function(range) {\n        unsafeUnwrap(this).removeRange(unwrap(range));\n      },\n      selectAllChildren: function(node) {\n        unsafeUnwrap(this).selectAllChildren(unwrapIfNeeded(node));\n      },\n      toString: function() {\n        return unsafeUnwrap(this).toString();\n      }\n    };\n    if (OriginalSelection.prototype.extend) {\n      Selection.prototype.extend = function(node, offset) {\n        unsafeUnwrap(this).extend(unwrapIfNeeded(node), offset);\n      };\n    }\n    registerWrapper(window.Selection, Selection, window.getSelection());\n    scope.wrappers.Selection = Selection;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalTreeWalker = window.TreeWalker;\n    function TreeWalker(impl) {\n      setWrapper(impl, this);\n    }\n    TreeWalker.prototype = {\n      get root() {\n        return wrap(unsafeUnwrap(this).root);\n      },\n      get currentNode() {\n        return wrap(unsafeUnwrap(this).currentNode);\n      },\n      set currentNode(node) {\n        unsafeUnwrap(this).currentNode = unwrapIfNeeded(node);\n      },\n      get filter() {\n        return unsafeUnwrap(this).filter;\n      },\n      parentNode: function() {\n        return wrap(unsafeUnwrap(this).parentNode());\n      },\n      firstChild: function() {\n        return wrap(unsafeUnwrap(this).firstChild());\n      },\n      lastChild: function() {\n        return wrap(unsafeUnwrap(this).lastChild());\n      },\n      previousSibling: function() {\n        return wrap(unsafeUnwrap(this).previousSibling());\n      },\n      previousNode: function() {\n        return wrap(unsafeUnwrap(this).previousNode());\n      },\n      nextNode: function() {\n        return wrap(unsafeUnwrap(this).nextNode());\n      }\n    };\n    registerWrapper(OriginalTreeWalker, TreeWalker);\n    scope.wrappers.TreeWalker = TreeWalker;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var GetElementsByInterface = scope.GetElementsByInterface;\n    var Node = scope.wrappers.Node;\n    var ParentNodeInterface = scope.ParentNodeInterface;\n    var NonElementParentNodeInterface = scope.NonElementParentNodeInterface;\n    var Selection = scope.wrappers.Selection;\n    var SelectorsInterface = scope.SelectorsInterface;\n    var ShadowRoot = scope.wrappers.ShadowRoot;\n    var TreeScope = scope.TreeScope;\n    var cloneNode = scope.cloneNode;\n    var defineWrapGetter = scope.defineWrapGetter;\n    var elementFromPoint = scope.elementFromPoint;\n    var forwardMethodsToWrapper = scope.forwardMethodsToWrapper;\n    var matchesNames = scope.matchesNames;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var rewrap = scope.rewrap;\n    var setWrapper = scope.setWrapper;\n    var unsafeUnwrap = scope.unsafeUnwrap;\n    var unwrap = scope.unwrap;\n    var wrap = scope.wrap;\n    var wrapEventTargetMethods = scope.wrapEventTargetMethods;\n    var wrapNodeList = scope.wrapNodeList;\n    var implementationTable = new WeakMap();\n    function Document(node) {\n      Node.call(this, node);\n      this.treeScope_ = new TreeScope(this, null);\n    }\n    Document.prototype = Object.create(Node.prototype);\n    defineWrapGetter(Document, \"documentElement\");\n    defineWrapGetter(Document, \"body\");\n    defineWrapGetter(Document, \"head\");\n    function wrapMethod(name) {\n      var original = document[name];\n      Document.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    [ \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\" ].forEach(wrapMethod);\n    var originalAdoptNode = document.adoptNode;\n    function adoptNodeNoRemove(node, doc) {\n      originalAdoptNode.call(unsafeUnwrap(doc), unwrap(node));\n      adoptSubtree(node, doc);\n    }\n    function adoptSubtree(node, doc) {\n      if (node.shadowRoot) doc.adoptNode(node.shadowRoot);\n      if (node instanceof ShadowRoot) adoptOlderShadowRoots(node, doc);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        adoptSubtree(child, doc);\n      }\n    }\n    function adoptOlderShadowRoots(shadowRoot, doc) {\n      var oldShadowRoot = shadowRoot.olderShadowRoot;\n      if (oldShadowRoot) doc.adoptNode(oldShadowRoot);\n    }\n    var originalGetSelection = document.getSelection;\n    mixin(Document.prototype, {\n      adoptNode: function(node) {\n        if (node.parentNode) node.parentNode.removeChild(node);\n        adoptNodeNoRemove(node, this);\n        return node;\n      },\n      elementFromPoint: function(x, y) {\n        return elementFromPoint(this, this, x, y);\n      },\n      importNode: function(node, deep) {\n        return cloneNode(node, deep, unsafeUnwrap(this));\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      getElementsByName: function(name) {\n        return SelectorsInterface.querySelectorAll.call(this, \"[name=\" + JSON.stringify(String(name)) + \"]\");\n      }\n    });\n    var originalCreateTreeWalker = document.createTreeWalker;\n    var TreeWalkerWrapper = scope.wrappers.TreeWalker;\n    Document.prototype.createTreeWalker = function(root, whatToShow, filter, expandEntityReferences) {\n      var newFilter = null;\n      if (filter) {\n        if (filter.acceptNode && typeof filter.acceptNode === \"function\") {\n          newFilter = {\n            acceptNode: function(node) {\n              return filter.acceptNode(wrap(node));\n            }\n          };\n        } else if (typeof filter === \"function\") {\n          newFilter = function(node) {\n            return filter(wrap(node));\n          };\n        }\n      }\n      return new TreeWalkerWrapper(originalCreateTreeWalker.call(unwrap(this), unwrap(root), whatToShow, newFilter, expandEntityReferences));\n    };\n    if (document.registerElement) {\n      var originalRegisterElement = document.registerElement;\n      Document.prototype.registerElement = function(tagName, object) {\n        var prototype, extendsOption;\n        if (object !== undefined) {\n          prototype = object.prototype;\n          extendsOption = object.extends;\n        }\n        if (!prototype) prototype = Object.create(HTMLElement.prototype);\n        if (scope.nativePrototypeTable.get(prototype)) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var proto = Object.getPrototypeOf(prototype);\n        var nativePrototype;\n        var prototypes = [];\n        while (proto) {\n          nativePrototype = scope.nativePrototypeTable.get(proto);\n          if (nativePrototype) break;\n          prototypes.push(proto);\n          proto = Object.getPrototypeOf(proto);\n        }\n        if (!nativePrototype) {\n          throw new Error(\"NotSupportedError\");\n        }\n        var newPrototype = Object.create(nativePrototype);\n        for (var i = prototypes.length - 1; i >= 0; i--) {\n          newPrototype = Object.create(newPrototype);\n        }\n        [ \"createdCallback\", \"attachedCallback\", \"detachedCallback\", \"attributeChangedCallback\" ].forEach(function(name) {\n          var f = prototype[name];\n          if (!f) return;\n          newPrototype[name] = function() {\n            if (!(wrap(this) instanceof CustomElementConstructor)) {\n              rewrap(this);\n            }\n            f.apply(wrap(this), arguments);\n          };\n        });\n        var p = {\n          prototype: newPrototype\n        };\n        if (extendsOption) p.extends = extendsOption;\n        function CustomElementConstructor(node) {\n          if (!node) {\n            if (extendsOption) {\n              return document.createElement(extendsOption, tagName);\n            } else {\n              return document.createElement(tagName);\n            }\n          }\n          setWrapper(node, this);\n        }\n        CustomElementConstructor.prototype = prototype;\n        CustomElementConstructor.prototype.constructor = CustomElementConstructor;\n        scope.constructorTable.set(newPrototype, CustomElementConstructor);\n        scope.nativePrototypeTable.set(prototype, newPrototype);\n        var nativeConstructor = originalRegisterElement.call(unwrap(this), tagName, p);\n        return CustomElementConstructor;\n      };\n      forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"registerElement\" ]);\n    }\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement, window.HTMLHtmlElement ], [ \"appendChild\", \"compareDocumentPosition\", \"contains\", \"getElementsByClassName\", \"getElementsByTagName\", \"getElementsByTagNameNS\", \"insertBefore\", \"querySelector\", \"querySelectorAll\", \"removeChild\", \"replaceChild\" ]);\n    forwardMethodsToWrapper([ window.HTMLBodyElement, window.HTMLHeadElement, window.HTMLHtmlElement ], matchesNames);\n    forwardMethodsToWrapper([ window.HTMLDocument || window.Document ], [ \"adoptNode\", \"importNode\", \"contains\", \"createComment\", \"createDocumentFragment\", \"createElement\", \"createElementNS\", \"createEvent\", \"createEventNS\", \"createRange\", \"createTextNode\", \"createTreeWalker\", \"elementFromPoint\", \"getElementById\", \"getElementsByName\", \"getSelection\" ]);\n    mixin(Document.prototype, GetElementsByInterface);\n    mixin(Document.prototype, ParentNodeInterface);\n    mixin(Document.prototype, SelectorsInterface);\n    mixin(Document.prototype, NonElementParentNodeInterface);\n    mixin(Document.prototype, {\n      get implementation() {\n        var implementation = implementationTable.get(this);\n        if (implementation) return implementation;\n        implementation = new DOMImplementation(unwrap(this).implementation);\n        implementationTable.set(this, implementation);\n        return implementation;\n      },\n      get defaultView() {\n        return wrap(unwrap(this).defaultView);\n      }\n    });\n    registerWrapper(window.Document, Document, document.implementation.createHTMLDocument(\"\"));\n    if (window.HTMLDocument) registerWrapper(window.HTMLDocument, Document);\n    wrapEventTargetMethods([ window.HTMLBodyElement, window.HTMLDocument || window.Document, window.HTMLHeadElement ]);\n    function DOMImplementation(impl) {\n      setWrapper(impl, this);\n    }\n    var originalCreateDocument = document.implementation.createDocument;\n    DOMImplementation.prototype.createDocument = function() {\n      arguments[2] = unwrap(arguments[2]);\n      return wrap(originalCreateDocument.apply(unsafeUnwrap(this), arguments));\n    };\n    function wrapImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return wrap(original.apply(unsafeUnwrap(this), arguments));\n      };\n    }\n    function forwardImplMethod(constructor, name) {\n      var original = document.implementation[name];\n      constructor.prototype[name] = function() {\n        return original.apply(unsafeUnwrap(this), arguments);\n      };\n    }\n    wrapImplMethod(DOMImplementation, \"createDocumentType\");\n    wrapImplMethod(DOMImplementation, \"createHTMLDocument\");\n    forwardImplMethod(DOMImplementation, \"hasFeature\");\n    registerWrapper(window.DOMImplementation, DOMImplementation);\n    forwardMethodsToWrapper([ window.DOMImplementation ], [ \"createDocument\", \"createDocumentType\", \"createHTMLDocument\", \"hasFeature\" ]);\n    scope.adoptNodeNoRemove = adoptNodeNoRemove;\n    scope.wrappers.DOMImplementation = DOMImplementation;\n    scope.wrappers.Document = Document;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var EventTarget = scope.wrappers.EventTarget;\n    var Selection = scope.wrappers.Selection;\n    var mixin = scope.mixin;\n    var registerWrapper = scope.registerWrapper;\n    var renderAllPending = scope.renderAllPending;\n    var unwrap = scope.unwrap;\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var wrap = scope.wrap;\n    var OriginalWindow = window.Window;\n    var originalGetComputedStyle = window.getComputedStyle;\n    var originalGetDefaultComputedStyle = window.getDefaultComputedStyle;\n    var originalGetSelection = window.getSelection;\n    function Window(impl) {\n      EventTarget.call(this, impl);\n    }\n    Window.prototype = Object.create(EventTarget.prototype);\n    OriginalWindow.prototype.getComputedStyle = function(el, pseudo) {\n      return wrap(this || window).getComputedStyle(unwrapIfNeeded(el), pseudo);\n    };\n    if (originalGetDefaultComputedStyle) {\n      OriginalWindow.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        return wrap(this || window).getDefaultComputedStyle(unwrapIfNeeded(el), pseudo);\n      };\n    }\n    OriginalWindow.prototype.getSelection = function() {\n      return wrap(this || window).getSelection();\n    };\n    delete window.getComputedStyle;\n    delete window.getDefaultComputedStyle;\n    delete window.getSelection;\n    [ \"addEventListener\", \"removeEventListener\", \"dispatchEvent\" ].forEach(function(name) {\n      OriginalWindow.prototype[name] = function() {\n        var w = wrap(this || window);\n        return w[name].apply(w, arguments);\n      };\n      delete window[name];\n    });\n    mixin(Window.prototype, {\n      getComputedStyle: function(el, pseudo) {\n        renderAllPending();\n        return originalGetComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      },\n      getSelection: function() {\n        renderAllPending();\n        return new Selection(originalGetSelection.call(unwrap(this)));\n      },\n      get document() {\n        return wrap(unwrap(this).document);\n      }\n    });\n    if (originalGetDefaultComputedStyle) {\n      Window.prototype.getDefaultComputedStyle = function(el, pseudo) {\n        renderAllPending();\n        return originalGetDefaultComputedStyle.call(unwrap(this), unwrapIfNeeded(el), pseudo);\n      };\n    }\n    registerWrapper(OriginalWindow, Window, window);\n    scope.wrappers.Window = Window;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrap = scope.unwrap;\n    var OriginalDataTransfer = window.DataTransfer || window.Clipboard;\n    var OriginalDataTransferSetDragImage = OriginalDataTransfer.prototype.setDragImage;\n    if (OriginalDataTransferSetDragImage) {\n      OriginalDataTransfer.prototype.setDragImage = function(image, x, y) {\n        OriginalDataTransferSetDragImage.call(this, unwrap(image), x, y);\n      };\n    }\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var registerWrapper = scope.registerWrapper;\n    var setWrapper = scope.setWrapper;\n    var unwrap = scope.unwrap;\n    var OriginalFormData = window.FormData;\n    if (!OriginalFormData) return;\n    function FormData(formElement) {\n      var impl;\n      if (formElement instanceof OriginalFormData) {\n        impl = formElement;\n      } else {\n        impl = new OriginalFormData(formElement && unwrap(formElement));\n      }\n      setWrapper(impl, this);\n    }\n    registerWrapper(OriginalFormData, FormData, new OriginalFormData());\n    scope.wrappers.FormData = FormData;\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var unwrapIfNeeded = scope.unwrapIfNeeded;\n    var originalSend = XMLHttpRequest.prototype.send;\n    XMLHttpRequest.prototype.send = function(obj) {\n      return originalSend.call(this, unwrapIfNeeded(obj));\n    };\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    \"use strict\";\n    var isWrapperFor = scope.isWrapperFor;\n    var elements = {\n      a: \"HTMLAnchorElement\",\n      area: \"HTMLAreaElement\",\n      audio: \"HTMLAudioElement\",\n      base: \"HTMLBaseElement\",\n      body: \"HTMLBodyElement\",\n      br: \"HTMLBRElement\",\n      button: \"HTMLButtonElement\",\n      canvas: \"HTMLCanvasElement\",\n      caption: \"HTMLTableCaptionElement\",\n      col: \"HTMLTableColElement\",\n      content: \"HTMLContentElement\",\n      data: \"HTMLDataElement\",\n      datalist: \"HTMLDataListElement\",\n      del: \"HTMLModElement\",\n      dir: \"HTMLDirectoryElement\",\n      div: \"HTMLDivElement\",\n      dl: \"HTMLDListElement\",\n      embed: \"HTMLEmbedElement\",\n      fieldset: \"HTMLFieldSetElement\",\n      font: \"HTMLFontElement\",\n      form: \"HTMLFormElement\",\n      frame: \"HTMLFrameElement\",\n      frameset: \"HTMLFrameSetElement\",\n      h1: \"HTMLHeadingElement\",\n      head: \"HTMLHeadElement\",\n      hr: \"HTMLHRElement\",\n      html: \"HTMLHtmlElement\",\n      iframe: \"HTMLIFrameElement\",\n      img: \"HTMLImageElement\",\n      input: \"HTMLInputElement\",\n      keygen: \"HTMLKeygenElement\",\n      label: \"HTMLLabelElement\",\n      legend: \"HTMLLegendElement\",\n      li: \"HTMLLIElement\",\n      link: \"HTMLLinkElement\",\n      map: \"HTMLMapElement\",\n      marquee: \"HTMLMarqueeElement\",\n      menu: \"HTMLMenuElement\",\n      menuitem: \"HTMLMenuItemElement\",\n      meta: \"HTMLMetaElement\",\n      meter: \"HTMLMeterElement\",\n      object: \"HTMLObjectElement\",\n      ol: \"HTMLOListElement\",\n      optgroup: \"HTMLOptGroupElement\",\n      option: \"HTMLOptionElement\",\n      output: \"HTMLOutputElement\",\n      p: \"HTMLParagraphElement\",\n      param: \"HTMLParamElement\",\n      pre: \"HTMLPreElement\",\n      progress: \"HTMLProgressElement\",\n      q: \"HTMLQuoteElement\",\n      script: \"HTMLScriptElement\",\n      select: \"HTMLSelectElement\",\n      shadow: \"HTMLShadowElement\",\n      source: \"HTMLSourceElement\",\n      span: \"HTMLSpanElement\",\n      style: \"HTMLStyleElement\",\n      table: \"HTMLTableElement\",\n      tbody: \"HTMLTableSectionElement\",\n      template: \"HTMLTemplateElement\",\n      textarea: \"HTMLTextAreaElement\",\n      thead: \"HTMLTableSectionElement\",\n      time: \"HTMLTimeElement\",\n      title: \"HTMLTitleElement\",\n      tr: \"HTMLTableRowElement\",\n      track: \"HTMLTrackElement\",\n      ul: \"HTMLUListElement\",\n      video: \"HTMLVideoElement\"\n    };\n    function overrideConstructor(tagName) {\n      var nativeConstructorName = elements[tagName];\n      var nativeConstructor = window[nativeConstructorName];\n      if (!nativeConstructor) return;\n      var element = document.createElement(tagName);\n      var wrapperConstructor = element.constructor;\n      window[nativeConstructorName] = wrapperConstructor;\n    }\n    Object.keys(elements).forEach(overrideConstructor);\n    Object.getOwnPropertyNames(scope.wrappers).forEach(function(name) {\n      window[name] = scope.wrappers[name];\n    });\n  })(window.ShadowDOMPolyfill);\n  (function(scope) {\n    var ShadowCSS = {\n      strictStyling: false,\n      registry: {},\n      shimStyling: function(root, name, extendsName) {\n        var scopeStyles = this.prepareRoot(root, name, extendsName);\n        var typeExtension = this.isTypeExtension(extendsName);\n        var scopeSelector = this.makeScopeSelector(name, typeExtension);\n        var cssText = stylesToCssText(scopeStyles, true);\n        cssText = this.scopeCssText(cssText, scopeSelector);\n        if (root) {\n          root.shimmedStyle = cssText;\n        }\n        this.addCssToDocument(cssText, name);\n      },\n      shimStyle: function(style, selector) {\n        return this.shimCssText(style.textContent, selector);\n      },\n      shimCssText: function(cssText, selector) {\n        cssText = this.insertDirectives(cssText);\n        return this.scopeCssText(cssText, selector);\n      },\n      makeScopeSelector: function(name, typeExtension) {\n        if (name) {\n          return typeExtension ? \"[is=\" + name + \"]\" : name;\n        }\n        return \"\";\n      },\n      isTypeExtension: function(extendsName) {\n        return extendsName && extendsName.indexOf(\"-\") < 0;\n      },\n      prepareRoot: function(root, name, extendsName) {\n        var def = this.registerRoot(root, name, extendsName);\n        this.replaceTextInStyles(def.rootStyles, this.insertDirectives);\n        this.removeStyles(root, def.rootStyles);\n        if (this.strictStyling) {\n          this.applyScopeToContent(root, name);\n        }\n        return def.scopeStyles;\n      },\n      removeStyles: function(root, styles) {\n        for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\n          s.parentNode.removeChild(s);\n        }\n      },\n      registerRoot: function(root, name, extendsName) {\n        var def = this.registry[name] = {\n          root: root,\n          name: name,\n          extendsName: extendsName\n        };\n        var styles = this.findStyles(root);\n        def.rootStyles = styles;\n        def.scopeStyles = def.rootStyles;\n        var extendee = this.registry[def.extendsName];\n        if (extendee) {\n          def.scopeStyles = extendee.scopeStyles.concat(def.scopeStyles);\n        }\n        return def;\n      },\n      findStyles: function(root) {\n        if (!root) {\n          return [];\n        }\n        var styles = root.querySelectorAll(\"style\");\n        return Array.prototype.filter.call(styles, function(s) {\n          return !s.hasAttribute(NO_SHIM_ATTRIBUTE);\n        });\n      },\n      applyScopeToContent: function(root, name) {\n        if (root) {\n          Array.prototype.forEach.call(root.querySelectorAll(\"*\"), function(node) {\n            node.setAttribute(name, \"\");\n          });\n          Array.prototype.forEach.call(root.querySelectorAll(\"template\"), function(template) {\n            this.applyScopeToContent(template.content, name);\n          }, this);\n        }\n      },\n      insertDirectives: function(cssText) {\n        cssText = this.insertPolyfillDirectivesInCssText(cssText);\n        return this.insertPolyfillRulesInCssText(cssText);\n      },\n      insertPolyfillDirectivesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentNextSelectorRe, function(match, p1) {\n          return p1.slice(0, -2) + \"{\";\n        });\n        return cssText.replace(cssContentNextSelectorRe, function(match, p1) {\n          return p1 + \" {\";\n        });\n      },\n      insertPolyfillRulesInCssText: function(cssText) {\n        cssText = cssText.replace(cssCommentRuleRe, function(match, p1) {\n          return p1.slice(0, -1);\n        });\n        return cssText.replace(cssContentRuleRe, function(match, p1, p2, p3) {\n          var rule = match.replace(p1, \"\").replace(p2, \"\");\n          return p3 + rule;\n        });\n      },\n      scopeCssText: function(cssText, scopeSelector) {\n        var unscoped = this.extractUnscopedRulesFromCssText(cssText);\n        cssText = this.insertPolyfillHostInCssText(cssText);\n        cssText = this.convertColonHost(cssText);\n        cssText = this.convertColonHostContext(cssText);\n        cssText = this.convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n          var self = this, cssText;\n          withCssRules(cssText, function(rules) {\n            cssText = self.scopeRules(rules, scopeSelector);\n          });\n        }\n        cssText = cssText + \"\\n\" + unscoped;\n        return cssText.trim();\n      },\n      extractUnscopedRulesFromCssText: function(cssText) {\n        var r = \"\", m;\n        while (m = cssCommentUnscopedRuleRe.exec(cssText)) {\n          r += m[1].slice(0, -1) + \"\\n\\n\";\n        }\n        while (m = cssContentUnscopedRuleRe.exec(cssText)) {\n          r += m[0].replace(m[2], \"\").replace(m[1], m[3]) + \"\\n\\n\";\n        }\n        return r;\n      },\n      convertColonHost: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostRe, this.colonHostPartReplacer);\n      },\n      convertColonHostContext: function(cssText) {\n        return this.convertColonRule(cssText, cssColonHostContextRe, this.colonHostContextPartReplacer);\n      },\n      convertColonRule: function(cssText, regExp, partReplacer) {\n        return cssText.replace(regExp, function(m, p1, p2, p3) {\n          p1 = polyfillHostNoCombinator;\n          if (p2) {\n            var parts = p2.split(\",\"), r = [];\n            for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\n              p = p.trim();\n              r.push(partReplacer(p1, p, p3));\n            }\n            return r.join(\",\");\n          } else {\n            return p1 + p3;\n          }\n        });\n      },\n      colonHostContextPartReplacer: function(host, part, suffix) {\n        if (part.match(polyfillHost)) {\n          return this.colonHostPartReplacer(host, part, suffix);\n        } else {\n          return host + part + suffix + \", \" + part + \" \" + host + suffix;\n        }\n      },\n      colonHostPartReplacer: function(host, part, suffix) {\n        return host + part.replace(polyfillHost, \"\") + suffix;\n      },\n      convertShadowDOMSelectors: function(cssText) {\n        for (var i = 0; i < shadowDOMSelectorsRe.length; i++) {\n          cssText = cssText.replace(shadowDOMSelectorsRe[i], \" \");\n        }\n        return cssText;\n      },\n      scopeRules: function(cssRules, scopeSelector) {\n        var cssText = \"\";\n        if (cssRules) {\n          Array.prototype.forEach.call(cssRules, function(rule) {\n            if (rule.selectorText && (rule.style && rule.style.cssText !== undefined)) {\n              cssText += this.scopeSelector(rule.selectorText, scopeSelector, this.strictStyling) + \" {\\n\t\";\n              cssText += this.propertiesFromRule(rule) + \"\\n}\\n\\n\";\n            } else if (rule.type === CSSRule.MEDIA_RULE) {\n              cssText += \"@media \" + rule.media.mediaText + \" {\\n\";\n              cssText += this.scopeRules(rule.cssRules, scopeSelector);\n              cssText += \"\\n}\\n\\n\";\n            } else {\n              try {\n                if (rule.cssText) {\n                  cssText += rule.cssText + \"\\n\\n\";\n                }\n              } catch (x) {\n                if (rule.type === CSSRule.KEYFRAMES_RULE && rule.cssRules) {\n                  cssText += this.ieSafeCssTextFromKeyFrameRule(rule);\n                }\n              }\n            }\n          }, this);\n        }\n        return cssText;\n      },\n      ieSafeCssTextFromKeyFrameRule: function(rule) {\n        var cssText = \"@keyframes \" + rule.name + \" {\";\n        Array.prototype.forEach.call(rule.cssRules, function(rule) {\n          cssText += \" \" + rule.keyText + \" {\" + rule.style.cssText + \"}\";\n        });\n        cssText += \" }\";\n        return cssText;\n      },\n      scopeSelector: function(selector, scopeSelector, strict) {\n        var r = [], parts = selector.split(\",\");\n        parts.forEach(function(p) {\n          p = p.trim();\n          if (this.selectorNeedsScoping(p, scopeSelector)) {\n            p = strict && !p.match(polyfillHostNoCombinator) ? this.applyStrictSelectorScope(p, scopeSelector) : this.applySelectorScope(p, scopeSelector);\n          }\n          r.push(p);\n        }, this);\n        return r.join(\", \");\n      },\n      selectorNeedsScoping: function(selector, scopeSelector) {\n        if (Array.isArray(scopeSelector)) {\n          return true;\n        }\n        var re = this.makeScopeMatcher(scopeSelector);\n        return !selector.match(re);\n      },\n      makeScopeMatcher: function(scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[/g, \"\\\\[\").replace(/\\]/g, \"\\\\]\");\n        return new RegExp(\"^(\" + scopeSelector + \")\" + selectorReSuffix, \"m\");\n      },\n      applySelectorScope: function(selector, selectorScope) {\n        return Array.isArray(selectorScope) ? this.applySelectorScopeList(selector, selectorScope) : this.applySimpleSelectorScope(selector, selectorScope);\n      },\n      applySelectorScopeList: function(selector, scopeSelectorList) {\n        var r = [];\n        for (var i = 0, s; s = scopeSelectorList[i]; i++) {\n          r.push(this.applySimpleSelectorScope(selector, s));\n        }\n        return r.join(\", \");\n      },\n      applySimpleSelectorScope: function(selector, scopeSelector) {\n        if (selector.match(polyfillHostRe)) {\n          selector = selector.replace(polyfillHostNoCombinator, scopeSelector);\n          return selector.replace(polyfillHostRe, scopeSelector + \" \");\n        } else {\n          return scopeSelector + \" \" + selector;\n        }\n      },\n      applyStrictSelectorScope: function(selector, scopeSelector) {\n        scopeSelector = scopeSelector.replace(/\\[is=([^\\]]*)\\]/g, \"$1\");\n        var splits = [ \" \", \">\", \"+\", \"~\" ], scoped = selector, attrName = \"[\" + scopeSelector + \"]\";\n        splits.forEach(function(sep) {\n          var parts = scoped.split(sep);\n          scoped = parts.map(function(p) {\n            var t = p.trim().replace(polyfillHostRe, \"\");\n            if (t && splits.indexOf(t) < 0 && t.indexOf(attrName) < 0) {\n              p = t.replace(/([^:]*)(:*)(.*)/, \"$1\" + attrName + \"$2$3\");\n            }\n            return p;\n          }).join(sep);\n        });\n        return scoped;\n      },\n      insertPolyfillHostInCssText: function(selector) {\n        return selector.replace(colonHostContextRe, polyfillHostContext).replace(colonHostRe, polyfillHost);\n      },\n      propertiesFromRule: function(rule) {\n        var cssText = rule.style.cssText;\n        if (rule.style.content && !rule.style.content.match(/['\"]+|attr/)) {\n          cssText = cssText.replace(/content:[^;]*;/g, \"content: '\" + rule.style.content + \"';\");\n        }\n        var style = rule.style;\n        for (var i in style) {\n          if (style[i] === \"initial\") {\n            cssText += i + \": initial; \";\n          }\n        }\n        return cssText;\n      },\n      replaceTextInStyles: function(styles, action) {\n        if (styles && action) {\n          if (!(styles instanceof Array)) {\n            styles = [ styles ];\n          }\n          Array.prototype.forEach.call(styles, function(s) {\n            s.textContent = action.call(this, s.textContent);\n          }, this);\n        }\n      },\n      addCssToDocument: function(cssText, name) {\n        if (cssText.match(\"@import\")) {\n          addOwnSheet(cssText, name);\n        } else {\n          addCssToDocument(cssText);\n        }\n      }\n    };\n    var selectorRe = /([^{]*)({[\\s\\S]*?})/gim, cssCommentRe = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim, cssCommentNextSelectorRe = /\\/\\*\\s*@polyfill ([^*]*\\*+([^\\/*][^*]*\\*+)*\\/)([^{]*?){/gim, cssContentNextSelectorRe = /polyfill-next-selector[^}]*content\\:[\\s]*?['\"](.*?)['\"][;\\s]*}([^{]*?){/gim, cssCommentRuleRe = /\\/\\*\\s@polyfill-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentRuleRe = /(polyfill-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssCommentUnscopedRuleRe = /\\/\\*\\s@polyfill-unscoped-rule([^*]*\\*+([^\\/*][^*]*\\*+)*)\\//gim, cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content\\:[\\s]*['\"](.*?)['\"])[;\\s]*[^}]*}/gim, cssPseudoRe = /::(x-[^\\s{,(]*)/gim, cssPartRe = /::part\\(([^)]*)\\)/gim, polyfillHost = \"-shadowcsshost\", polyfillHostContext = \"-shadowcsscontext\", parenSuffix = \")(?:\\\\((\" + \"(?:\\\\([^)(]*\\\\)|[^)(]*)+?\" + \")\\\\))?([^,{]*)\";\n    var cssColonHostRe = new RegExp(\"(\" + polyfillHost + parenSuffix, \"gim\"), cssColonHostContextRe = new RegExp(\"(\" + polyfillHostContext + parenSuffix, \"gim\"), selectorReSuffix = \"([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$\", colonHostRe = /\\:host/gim, colonHostContextRe = /\\:host-context/gim, polyfillHostNoCombinator = polyfillHost + \"-no-combinator\", polyfillHostRe = new RegExp(polyfillHost, \"gim\"), polyfillHostContextRe = new RegExp(polyfillHostContext, \"gim\"), shadowDOMSelectorsRe = [ />>>/g, /::shadow/g, /::content/g, /\\/deep\\//g, /\\/shadow\\//g, /\\/shadow-deep\\//g, /\\^\\^/g, /\\^/g ];\n    function stylesToCssText(styles, preserveComments) {\n      var cssText = \"\";\n      Array.prototype.forEach.call(styles, function(s) {\n        cssText += s.textContent + \"\\n\\n\";\n      });\n      if (!preserveComments) {\n        cssText = cssText.replace(cssCommentRe, \"\");\n      }\n      return cssText;\n    }\n    function cssTextToStyle(cssText) {\n      var style = document.createElement(\"style\");\n      style.textContent = cssText;\n      return style;\n    }\n    function cssToRules(cssText) {\n      var style = cssTextToStyle(cssText);\n      document.head.appendChild(style);\n      var rules = [];\n      if (style.sheet) {\n        try {\n          rules = style.sheet.cssRules;\n        } catch (e) {}\n      } else {\n        console.warn(\"sheet not found\", style);\n      }\n      style.parentNode.removeChild(style);\n      return rules;\n    }\n    var frame = document.createElement(\"iframe\");\n    frame.style.display = \"none\";\n    function initFrame() {\n      frame.initialized = true;\n      document.body.appendChild(frame);\n      var doc = frame.contentDocument;\n      var base = doc.createElement(\"base\");\n      base.href = document.baseURI;\n      doc.head.appendChild(base);\n    }\n    function inFrame(fn) {\n      if (!frame.initialized) {\n        initFrame();\n      }\n      document.body.appendChild(frame);\n      fn(frame.contentDocument);\n      document.body.removeChild(frame);\n    }\n    var isChrome = navigator.userAgent.match(\"Chrome\");\n    function withCssRules(cssText, callback) {\n      if (!callback) {\n        return;\n      }\n      var rules;\n      if (cssText.match(\"@import\") && isChrome) {\n        var style = cssTextToStyle(cssText);\n        inFrame(function(doc) {\n          doc.head.appendChild(style.impl);\n          rules = Array.prototype.slice.call(style.sheet.cssRules, 0);\n          callback(rules);\n        });\n      } else {\n        rules = cssToRules(cssText);\n        callback(rules);\n      }\n    }\n    function rulesToCss(cssRules) {\n      for (var i = 0, css = []; i < cssRules.length; i++) {\n        css.push(cssRules[i].cssText);\n      }\n      return css.join(\"\\n\\n\");\n    }\n    function addCssToDocument(cssText) {\n      if (cssText) {\n        getSheet().appendChild(document.createTextNode(cssText));\n      }\n    }\n    function addOwnSheet(cssText, name) {\n      var style = cssTextToStyle(cssText);\n      style.setAttribute(name, \"\");\n      style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n      document.head.appendChild(style);\n    }\n    var SHIM_ATTRIBUTE = \"shim-shadowdom\";\n    var SHIMMED_ATTRIBUTE = \"shim-shadowdom-css\";\n    var NO_SHIM_ATTRIBUTE = \"no-shim\";\n    var sheet;\n    function getSheet() {\n      if (!sheet) {\n        sheet = document.createElement(\"style\");\n        sheet.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n        sheet[SHIMMED_ATTRIBUTE] = true;\n      }\n      return sheet;\n    }\n    if (window.ShadowDOMPolyfill) {\n      addCssToDocument(\"style { display: none !important; }\\n\");\n      var doc = ShadowDOMPolyfill.wrap(document);\n      var head = doc.querySelector(\"head\");\n      head.insertBefore(getSheet(), head.childNodes[0]);\n      document.addEventListener(\"DOMContentLoaded\", function() {\n        var urlResolver = scope.urlResolver;\n        if (window.HTMLImports && !HTMLImports.useNative) {\n          var SHIM_SHEET_SELECTOR = \"link[rel=stylesheet]\" + \"[\" + SHIM_ATTRIBUTE + \"]\";\n          var SHIM_STYLE_SELECTOR = \"style[\" + SHIM_ATTRIBUTE + \"]\";\n          HTMLImports.importer.documentPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.importer.importsPreloadSelectors += \",\" + SHIM_SHEET_SELECTOR;\n          HTMLImports.parser.documentSelectors = [ HTMLImports.parser.documentSelectors, SHIM_SHEET_SELECTOR, SHIM_STYLE_SELECTOR ].join(\",\");\n          var originalParseGeneric = HTMLImports.parser.parseGeneric;\n          HTMLImports.parser.parseGeneric = function(elt) {\n            if (elt[SHIMMED_ATTRIBUTE]) {\n              return;\n            }\n            var style = elt.__importElement || elt;\n            if (!style.hasAttribute(SHIM_ATTRIBUTE)) {\n              originalParseGeneric.call(this, elt);\n              return;\n            }\n            if (elt.__resource) {\n              style = elt.ownerDocument.createElement(\"style\");\n              style.textContent = elt.__resource;\n            }\n            HTMLImports.path.resolveUrlsInStyle(style, elt.href);\n            style.textContent = ShadowCSS.shimStyle(style);\n            style.removeAttribute(SHIM_ATTRIBUTE, \"\");\n            style.setAttribute(SHIMMED_ATTRIBUTE, \"\");\n            style[SHIMMED_ATTRIBUTE] = true;\n            if (style.parentNode !== head) {\n              if (elt.parentNode === head) {\n                head.replaceChild(style, elt);\n              } else {\n                this.addElementToDocument(style);\n              }\n            }\n            style.__importParsed = true;\n            this.markParsingComplete(elt);\n            this.parseNext();\n          };\n          var hasResource = HTMLImports.parser.hasResource;\n          HTMLImports.parser.hasResource = function(node) {\n            if (node.localName === \"link\" && node.rel === \"stylesheet\" && node.hasAttribute(SHIM_ATTRIBUTE)) {\n              return node.__resource;\n            } else {\n              return hasResource.call(this, node);\n            }\n          };\n        }\n      });\n    }\n    scope.ShadowCSS = ShadowCSS;\n  })(window.WebComponents);\n}\n\n(function(scope) {\n  if (window.ShadowDOMPolyfill) {\n    window.wrap = ShadowDOMPolyfill.wrapIfNeeded;\n    window.unwrap = ShadowDOMPolyfill.unwrapIfNeeded;\n  } else {\n    window.wrap = window.unwrap = function(n) {\n      return n;\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  \"use strict\";\n  var hasWorkingUrl = false;\n  if (!scope.forceJURL) {\n    try {\n      var u = new URL(\"b\", \"http://a\");\n      u.pathname = \"c%20d\";\n      hasWorkingUrl = u.href === \"http://a/c%20d\";\n    } catch (e) {}\n  }\n  if (hasWorkingUrl) return;\n  var relative = Object.create(null);\n  relative[\"ftp\"] = 21;\n  relative[\"file\"] = 0;\n  relative[\"gopher\"] = 70;\n  relative[\"http\"] = 80;\n  relative[\"https\"] = 443;\n  relative[\"ws\"] = 80;\n  relative[\"wss\"] = 443;\n  var relativePathDotMapping = Object.create(null);\n  relativePathDotMapping[\"%2e\"] = \".\";\n  relativePathDotMapping[\".%2e\"] = \"..\";\n  relativePathDotMapping[\"%2e.\"] = \"..\";\n  relativePathDotMapping[\"%2e%2e\"] = \"..\";\n  function isRelativeScheme(scheme) {\n    return relative[scheme] !== undefined;\n  }\n  function invalid() {\n    clear.call(this);\n    this._isInvalid = true;\n  }\n  function IDNAToASCII(h) {\n    if (\"\" == h) {\n      invalid.call(this);\n    }\n    return h.toLowerCase();\n  }\n  function percentEscape(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 63, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  function percentEscapeQuery(c) {\n    var unicode = c.charCodeAt(0);\n    if (unicode > 32 && unicode < 127 && [ 34, 35, 60, 62, 96 ].indexOf(unicode) == -1) {\n      return c;\n    }\n    return encodeURIComponent(c);\n  }\n  var EOF = undefined, ALPHA = /[a-zA-Z]/, ALPHANUMERIC = /[a-zA-Z0-9\\+\\-\\.]/;\n  function parse(input, stateOverride, base) {\n    function err(message) {\n      errors.push(message);\n    }\n    var state = stateOverride || \"scheme start\", cursor = 0, buffer = \"\", seenAt = false, seenBracket = false, errors = [];\n    loop: while ((input[cursor - 1] != EOF || cursor == 0) && !this._isInvalid) {\n      var c = input[cursor];\n      switch (state) {\n       case \"scheme start\":\n        if (c && ALPHA.test(c)) {\n          buffer += c.toLowerCase();\n          state = \"scheme\";\n        } else if (!stateOverride) {\n          buffer = \"\";\n          state = \"no scheme\";\n          continue;\n        } else {\n          err(\"Invalid scheme.\");\n          break loop;\n        }\n        break;\n\n       case \"scheme\":\n        if (c && ALPHANUMERIC.test(c)) {\n          buffer += c.toLowerCase();\n        } else if (\":\" == c) {\n          this._scheme = buffer;\n          buffer = \"\";\n          if (stateOverride) {\n            break loop;\n          }\n          if (isRelativeScheme(this._scheme)) {\n            this._isRelative = true;\n          }\n          if (\"file\" == this._scheme) {\n            state = \"relative\";\n          } else if (this._isRelative && base && base._scheme == this._scheme) {\n            state = \"relative or authority\";\n          } else if (this._isRelative) {\n            state = \"authority first slash\";\n          } else {\n            state = \"scheme data\";\n          }\n        } else if (!stateOverride) {\n          buffer = \"\";\n          cursor = 0;\n          state = \"no scheme\";\n          continue;\n        } else if (EOF == c) {\n          break loop;\n        } else {\n          err(\"Code point not allowed in scheme: \" + c);\n          break loop;\n        }\n        break;\n\n       case \"scheme data\":\n        if (\"?\" == c) {\n          this._query = \"?\";\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else {\n          if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n            this._schemeData += percentEscape(c);\n          }\n        }\n        break;\n\n       case \"no scheme\":\n        if (!base || !isRelativeScheme(base._scheme)) {\n          err(\"Missing scheme.\");\n          invalid.call(this);\n        } else {\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative or authority\":\n        if (\"/\" == c && \"/\" == input[cursor + 1]) {\n          state = \"authority ignore slashes\";\n        } else {\n          err(\"Expected /, got: \" + c);\n          state = \"relative\";\n          continue;\n        }\n        break;\n\n       case \"relative\":\n        this._isRelative = true;\n        if (\"file\" != this._scheme) this._scheme = base._scheme;\n        if (EOF == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._username = base._username;\n          this._password = base._password;\n          break loop;\n        } else if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) err(\"\\\\ is an invalid code point.\");\n          state = \"relative slash\";\n        } else if (\"?\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = \"?\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"query\";\n        } else if (\"#\" == c) {\n          this._host = base._host;\n          this._port = base._port;\n          this._path = base._path.slice();\n          this._query = base._query;\n          this._fragment = \"#\";\n          this._username = base._username;\n          this._password = base._password;\n          state = \"fragment\";\n        } else {\n          var nextC = input[cursor + 1];\n          var nextNextC = input[cursor + 2];\n          if (\"file\" != this._scheme || !ALPHA.test(c) || nextC != \":\" && nextC != \"|\" || EOF != nextNextC && \"/\" != nextNextC && \"\\\\\" != nextNextC && \"?\" != nextNextC && \"#\" != nextNextC) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n            this._path = base._path.slice();\n            this._path.pop();\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"relative slash\":\n        if (\"/\" == c || \"\\\\\" == c) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ is an invalid code point.\");\n          }\n          if (\"file\" == this._scheme) {\n            state = \"file host\";\n          } else {\n            state = \"authority ignore slashes\";\n          }\n        } else {\n          if (\"file\" != this._scheme) {\n            this._host = base._host;\n            this._port = base._port;\n            this._username = base._username;\n            this._password = base._password;\n          }\n          state = \"relative path\";\n          continue;\n        }\n        break;\n\n       case \"authority first slash\":\n        if (\"/\" == c) {\n          state = \"authority second slash\";\n        } else {\n          err(\"Expected '/', got: \" + c);\n          state = \"authority ignore slashes\";\n          continue;\n        }\n        break;\n\n       case \"authority second slash\":\n        state = \"authority ignore slashes\";\n        if (\"/\" != c) {\n          err(\"Expected '/', got: \" + c);\n          continue;\n        }\n        break;\n\n       case \"authority ignore slashes\":\n        if (\"/\" != c && \"\\\\\" != c) {\n          state = \"authority\";\n          continue;\n        } else {\n          err(\"Expected authority, got: \" + c);\n        }\n        break;\n\n       case \"authority\":\n        if (\"@\" == c) {\n          if (seenAt) {\n            err(\"@ already seen.\");\n            buffer += \"%40\";\n          }\n          seenAt = true;\n          for (var i = 0; i < buffer.length; i++) {\n            var cp = buffer[i];\n            if (\"\t\" == cp || \"\\n\" == cp || \"\\r\" == cp) {\n              err(\"Invalid whitespace in authority.\");\n              continue;\n            }\n            if (\":\" == cp && null === this._password) {\n              this._password = \"\";\n              continue;\n            }\n            var tempC = percentEscape(cp);\n            null !== this._password ? this._password += tempC : this._username += tempC;\n          }\n          buffer = \"\";\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          cursor -= buffer.length;\n          buffer = \"\";\n          state = \"host\";\n          continue;\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"file host\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          if (buffer.length == 2 && ALPHA.test(buffer[0]) && (buffer[1] == \":\" || buffer[1] == \"|\")) {\n            state = \"relative path\";\n          } else if (buffer.length == 0) {\n            state = \"relative path start\";\n          } else {\n            this._host = IDNAToASCII.call(this, buffer);\n            buffer = \"\";\n            state = \"relative path start\";\n          }\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid whitespace in file host.\");\n        } else {\n          buffer += c;\n        }\n        break;\n\n       case \"host\":\n       case \"hostname\":\n        if (\":\" == c && !seenBracket) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"port\";\n          if (\"hostname\" == stateOverride) {\n            break loop;\n          }\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c) {\n          this._host = IDNAToASCII.call(this, buffer);\n          buffer = \"\";\n          state = \"relative path start\";\n          if (stateOverride) {\n            break loop;\n          }\n          continue;\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          if (\"[\" == c) {\n            seenBracket = true;\n          } else if (\"]\" == c) {\n            seenBracket = false;\n          }\n          buffer += c;\n        } else {\n          err(\"Invalid code point in host/hostname: \" + c);\n        }\n        break;\n\n       case \"port\":\n        if (/[0-9]/.test(c)) {\n          buffer += c;\n        } else if (EOF == c || \"/\" == c || \"\\\\\" == c || \"?\" == c || \"#\" == c || stateOverride) {\n          if (\"\" != buffer) {\n            var temp = parseInt(buffer, 10);\n            if (temp != relative[this._scheme]) {\n              this._port = temp + \"\";\n            }\n            buffer = \"\";\n          }\n          if (stateOverride) {\n            break loop;\n          }\n          state = \"relative path start\";\n          continue;\n        } else if (\"\t\" == c || \"\\n\" == c || \"\\r\" == c) {\n          err(\"Invalid code point in port: \" + c);\n        } else {\n          invalid.call(this);\n        }\n        break;\n\n       case \"relative path start\":\n        if (\"\\\\\" == c) err(\"'\\\\' not allowed in path.\");\n        state = \"relative path\";\n        if (\"/\" != c && \"\\\\\" != c) {\n          continue;\n        }\n        break;\n\n       case \"relative path\":\n        if (EOF == c || \"/\" == c || \"\\\\\" == c || !stateOverride && (\"?\" == c || \"#\" == c)) {\n          if (\"\\\\\" == c) {\n            err(\"\\\\ not allowed in relative path.\");\n          }\n          var tmp;\n          if (tmp = relativePathDotMapping[buffer.toLowerCase()]) {\n            buffer = tmp;\n          }\n          if (\"..\" == buffer) {\n            this._path.pop();\n            if (\"/\" != c && \"\\\\\" != c) {\n              this._path.push(\"\");\n            }\n          } else if (\".\" == buffer && \"/\" != c && \"\\\\\" != c) {\n            this._path.push(\"\");\n          } else if (\".\" != buffer) {\n            if (\"file\" == this._scheme && this._path.length == 0 && buffer.length == 2 && ALPHA.test(buffer[0]) && buffer[1] == \"|\") {\n              buffer = buffer[0] + \":\";\n            }\n            this._path.push(buffer);\n          }\n          buffer = \"\";\n          if (\"?\" == c) {\n            this._query = \"?\";\n            state = \"query\";\n          } else if (\"#\" == c) {\n            this._fragment = \"#\";\n            state = \"fragment\";\n          }\n        } else if (\"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          buffer += percentEscape(c);\n        }\n        break;\n\n       case \"query\":\n        if (!stateOverride && \"#\" == c) {\n          this._fragment = \"#\";\n          state = \"fragment\";\n        } else if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._query += percentEscapeQuery(c);\n        }\n        break;\n\n       case \"fragment\":\n        if (EOF != c && \"\t\" != c && \"\\n\" != c && \"\\r\" != c) {\n          this._fragment += c;\n        }\n        break;\n      }\n      cursor++;\n    }\n  }\n  function clear() {\n    this._scheme = \"\";\n    this._schemeData = \"\";\n    this._username = \"\";\n    this._password = null;\n    this._host = \"\";\n    this._port = \"\";\n    this._path = [];\n    this._query = \"\";\n    this._fragment = \"\";\n    this._isInvalid = false;\n    this._isRelative = false;\n  }\n  function jURL(url, base) {\n    if (base !== undefined && !(base instanceof jURL)) base = new jURL(String(base));\n    this._url = url;\n    clear.call(this);\n    var input = url.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g, \"\");\n    parse.call(this, input, null, base);\n  }\n  jURL.prototype = {\n    toString: function() {\n      return this.href;\n    },\n    get href() {\n      if (this._isInvalid) return this._url;\n      var authority = \"\";\n      if (\"\" != this._username || null != this._password) {\n        authority = this._username + (null != this._password ? \":\" + this._password : \"\") + \"@\";\n      }\n      return this.protocol + (this._isRelative ? \"//\" + authority + this.host : \"\") + this.pathname + this._query + this._fragment;\n    },\n    set href(href) {\n      clear.call(this);\n      parse.call(this, href);\n    },\n    get protocol() {\n      return this._scheme + \":\";\n    },\n    set protocol(protocol) {\n      if (this._isInvalid) return;\n      parse.call(this, protocol + \":\", \"scheme start\");\n    },\n    get host() {\n      return this._isInvalid ? \"\" : this._port ? this._host + \":\" + this._port : this._host;\n    },\n    set host(host) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, host, \"host\");\n    },\n    get hostname() {\n      return this._host;\n    },\n    set hostname(hostname) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, hostname, \"hostname\");\n    },\n    get port() {\n      return this._port;\n    },\n    set port(port) {\n      if (this._isInvalid || !this._isRelative) return;\n      parse.call(this, port, \"port\");\n    },\n    get pathname() {\n      return this._isInvalid ? \"\" : this._isRelative ? \"/\" + this._path.join(\"/\") : this._schemeData;\n    },\n    set pathname(pathname) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._path = [];\n      parse.call(this, pathname, \"relative path start\");\n    },\n    get search() {\n      return this._isInvalid || !this._query || \"?\" == this._query ? \"\" : this._query;\n    },\n    set search(search) {\n      if (this._isInvalid || !this._isRelative) return;\n      this._query = \"?\";\n      if (\"?\" == search[0]) search = search.slice(1);\n      parse.call(this, search, \"query\");\n    },\n    get hash() {\n      return this._isInvalid || !this._fragment || \"#\" == this._fragment ? \"\" : this._fragment;\n    },\n    set hash(hash) {\n      if (this._isInvalid) return;\n      this._fragment = \"#\";\n      if (\"#\" == hash[0]) hash = hash.slice(1);\n      parse.call(this, hash, \"fragment\");\n    },\n    get origin() {\n      var host;\n      if (this._isInvalid || !this._scheme) {\n        return \"\";\n      }\n      switch (this._scheme) {\n       case \"data\":\n       case \"file\":\n       case \"javascript\":\n       case \"mailto\":\n        return \"null\";\n      }\n      host = this.host;\n      if (!host) {\n        return \"\";\n      }\n      return this._scheme + \"://\" + host;\n    }\n  };\n  var OriginalURL = scope.URL;\n  if (OriginalURL) {\n    jURL.createObjectURL = function(blob) {\n      return OriginalURL.createObjectURL.apply(OriginalURL, arguments);\n    };\n    jURL.revokeObjectURL = function(url) {\n      OriginalURL.revokeObjectURL(url);\n    };\n  }\n  scope.URL = jURL;\n})(self);\n\n(function(global) {\n  var registrationsTable = new WeakMap();\n  var setImmediate;\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    setImmediate = setTimeout;\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener(\"message\", function(e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function(func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, \"*\");\n    };\n  }\n  var isScheduled = false;\n  var scheduledObservers = [];\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n  }\n  function dispatchCallbacks() {\n    isScheduled = false;\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    observers.sort(function(o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function(observer) {\n      var queue = observer.takeRecords();\n      removeTransientObserversFor(observer);\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n    if (anyNonEmpty) dispatchCallbacks();\n  }\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function(node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations) return;\n      registrations.forEach(function(registration) {\n        if (registration.observer === observer) registration.removeTransientObservers();\n      });\n    });\n  }\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          var record = callback(options);\n          if (record) registration.enqueue(record);\n        }\n      }\n    }\n  }\n  var uidCounter = 0;\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n  JsMutationObserver.prototype = {\n    observe: function(target, options) {\n      target = wrapIfNeeded(target);\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n      registration.addListeners();\n    },\n    disconnect: function() {\n      this.nodes_.forEach(function(node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n    takeRecords: function() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n  var currentRecord, recordWithOldValue;\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue) return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord) return lastRecord;\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n    return null;\n  }\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype = {\n    enqueue: function(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    },\n    addListeners: function() {\n      this.addListeners_(this.target);\n    },\n    addListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    removeListeners: function() {\n      this.removeListeners_(this.target);\n    },\n    removeListeners_: function(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    addTransientObserver: function(node) {\n      if (node === this.target) return;\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations) registrationsTable.set(node, registrations = []);\n      registrations.push(this);\n    },\n    removeTransientObservers: function() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function(node) {\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n    },\n    handleEvent: function(e) {\n      e.stopImmediatePropagation();\n      switch (e.type) {\n       case \"DOMAttrModified\":\n        var name = e.attrName;\n        var namespace = e.relatedNode.namespaceURI;\n        var target = e.target;\n        var record = new getRecord(\"attributes\", target);\n        record.attributeName = name;\n        record.attributeNamespace = namespace;\n        var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.attributes) return;\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n            return;\n          }\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMCharacterDataModified\":\n        var target = e.target;\n        var record = getRecord(\"characterData\", target);\n        var oldValue = e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n          if (!options.characterData) return;\n          if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n          return record;\n        });\n        break;\n\n       case \"DOMNodeRemoved\":\n        this.addTransientObserver(e.target);\n\n       case \"DOMNodeInserted\":\n        var changedNode = e.target;\n        var addedNodes, removedNodes;\n        if (e.type === \"DOMNodeInserted\") {\n          addedNodes = [ changedNode ];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [ changedNode ];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n        var record = getRecord(\"childList\", e.target.parentNode);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function(options) {\n          if (!options.childList) return;\n          return record;\n        });\n      }\n      clearRecords();\n    }\n  };\n  global.JsMutationObserver = JsMutationObserver;\n  if (!global.MutationObserver) global.MutationObserver = JsMutationObserver;\n})(self);\n\nwindow.HTMLImports = window.HTMLImports || {\n  flags: {}\n};\n\n(function(scope) {\n  var IMPORT_LINK_TYPE = \"import\";\n  var useNative = Boolean(IMPORT_LINK_TYPE in document.createElement(\"link\"));\n  var hasShadowDOMPolyfill = Boolean(window.ShadowDOMPolyfill);\n  var wrap = function(node) {\n    return hasShadowDOMPolyfill ? window.ShadowDOMPolyfill.wrapIfNeeded(node) : node;\n  };\n  var rootDocument = wrap(document);\n  var currentScriptDescriptor = {\n    get: function() {\n      var script = window.HTMLImports.currentScript || document.currentScript || (document.readyState !== \"complete\" ? document.scripts[document.scripts.length - 1] : null);\n      return wrap(script);\n    },\n    configurable: true\n  };\n  Object.defineProperty(document, \"_currentScript\", currentScriptDescriptor);\n  Object.defineProperty(rootDocument, \"_currentScript\", currentScriptDescriptor);\n  var isIE = /Trident/.test(navigator.userAgent);\n  function whenReady(callback, doc) {\n    doc = doc || rootDocument;\n    whenDocumentReady(function() {\n      watchImportsLoad(callback, doc);\n    }, doc);\n  }\n  var requiredReadyState = isIE ? \"complete\" : \"interactive\";\n  var READY_EVENT = \"readystatechange\";\n  function isDocumentReady(doc) {\n    return doc.readyState === \"complete\" || doc.readyState === requiredReadyState;\n  }\n  function whenDocumentReady(callback, doc) {\n    if (!isDocumentReady(doc)) {\n      var checkReady = function() {\n        if (doc.readyState === \"complete\" || doc.readyState === requiredReadyState) {\n          doc.removeEventListener(READY_EVENT, checkReady);\n          whenDocumentReady(callback, doc);\n        }\n      };\n      doc.addEventListener(READY_EVENT, checkReady);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function markTargetLoaded(event) {\n    event.target.__loaded = true;\n  }\n  function watchImportsLoad(callback, doc) {\n    var imports = doc.querySelectorAll(\"link[rel=import]\");\n    var parsedCount = 0, importCount = imports.length, newImports = [], errorImports = [];\n    function checkDone() {\n      if (parsedCount == importCount && callback) {\n        callback({\n          allImports: imports,\n          loadedImports: newImports,\n          errorImports: errorImports\n        });\n      }\n    }\n    function loadedImport(e) {\n      markTargetLoaded(e);\n      newImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    function errorLoadingImport(e) {\n      errorImports.push(this);\n      parsedCount++;\n      checkDone();\n    }\n    if (importCount) {\n      for (var i = 0, imp; i < importCount && (imp = imports[i]); i++) {\n        if (isImportLoaded(imp)) {\n          parsedCount++;\n          checkDone();\n        } else {\n          imp.addEventListener(\"load\", loadedImport);\n          imp.addEventListener(\"error\", errorLoadingImport);\n        }\n      }\n    } else {\n      checkDone();\n    }\n  }\n  function isImportLoaded(link) {\n    return useNative ? link.__loaded || link.import && link.import.readyState !== \"loading\" : link.__importParsed;\n  }\n  if (useNative) {\n    new MutationObserver(function(mxns) {\n      for (var i = 0, l = mxns.length, m; i < l && (m = mxns[i]); i++) {\n        if (m.addedNodes) {\n          handleImports(m.addedNodes);\n        }\n      }\n    }).observe(document.head, {\n      childList: true\n    });\n    function handleImports(nodes) {\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (isImport(n)) {\n          handleImport(n);\n        }\n      }\n    }\n    function isImport(element) {\n      return element.localName === \"link\" && element.rel === \"import\";\n    }\n    function handleImport(element) {\n      var loaded = element.import;\n      if (loaded) {\n        markTargetLoaded({\n          target: element\n        });\n      } else {\n        element.addEventListener(\"load\", markTargetLoaded);\n        element.addEventListener(\"error\", markTargetLoaded);\n      }\n    }\n    (function() {\n      if (document.readyState === \"loading\") {\n        var imports = document.querySelectorAll(\"link[rel=import]\");\n        for (var i = 0, l = imports.length, imp; i < l && (imp = imports[i]); i++) {\n          handleImport(imp);\n        }\n      }\n    })();\n  }\n  whenReady(function(detail) {\n    window.HTMLImports.ready = true;\n    window.HTMLImports.readyTime = new Date().getTime();\n    var evt = rootDocument.createEvent(\"CustomEvent\");\n    evt.initCustomEvent(\"HTMLImportsLoaded\", true, true, detail);\n    rootDocument.dispatchEvent(evt);\n  });\n  scope.IMPORT_LINK_TYPE = IMPORT_LINK_TYPE;\n  scope.useNative = useNative;\n  scope.rootDocument = rootDocument;\n  scope.whenReady = whenReady;\n  scope.isIE = isIE;\n})(window.HTMLImports);\n\n(function(scope) {\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n})(window.HTMLImports);\n\nwindow.HTMLImports.addModule(function(scope) {\n  var CSS_URL_REGEXP = /(url\\()([^)]*)(\\))/g;\n  var CSS_IMPORT_REGEXP = /(@import[\\s]+(?!url\\())([^;]*)(;)/g;\n  var path = {\n    resolveUrlsInStyle: function(style, linkUrl) {\n      var doc = style.ownerDocument;\n      var resolver = doc.createElement(\"a\");\n      style.textContent = this.resolveUrlsInCssText(style.textContent, linkUrl, resolver);\n      return style;\n    },\n    resolveUrlsInCssText: function(cssText, linkUrl, urlObj) {\n      var r = this.replaceUrls(cssText, urlObj, linkUrl, CSS_URL_REGEXP);\n      r = this.replaceUrls(r, urlObj, linkUrl, CSS_IMPORT_REGEXP);\n      return r;\n    },\n    replaceUrls: function(text, urlObj, linkUrl, regexp) {\n      return text.replace(regexp, function(m, pre, url, post) {\n        var urlPath = url.replace(/[\"']/g, \"\");\n        if (linkUrl) {\n          urlPath = new URL(urlPath, linkUrl).href;\n        }\n        urlObj.href = urlPath;\n        urlPath = urlObj.href;\n        return pre + \"'\" + urlPath + \"'\" + post;\n      });\n    }\n  };\n  scope.path = path;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = {\n    async: true,\n    ok: function(request) {\n      return request.status >= 200 && request.status < 300 || request.status === 304 || request.status === 0;\n    },\n    load: function(url, next, nextContext) {\n      var request = new XMLHttpRequest();\n      if (scope.flags.debug || scope.flags.bust) {\n        url += \"?\" + Math.random();\n      }\n      request.open(\"GET\", url, xhr.async);\n      request.addEventListener(\"readystatechange\", function(e) {\n        if (request.readyState === 4) {\n          var locationHeader = request.getResponseHeader(\"Location\");\n          var redirectedUrl = null;\n          if (locationHeader) {\n            var redirectedUrl = locationHeader.substr(0, 1) === \"/\" ? location.origin + locationHeader : locationHeader;\n          }\n          next.call(nextContext, !xhr.ok(request) && request, request.response || request.responseText, redirectedUrl);\n        }\n      });\n      request.send();\n      return request;\n    },\n    loadDocument: function(url, next, nextContext) {\n      this.load(url, next, nextContext).responseType = \"document\";\n    }\n  };\n  scope.xhr = xhr;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var xhr = scope.xhr;\n  var flags = scope.flags;\n  var Loader = function(onLoad, onComplete) {\n    this.cache = {};\n    this.onload = onLoad;\n    this.oncomplete = onComplete;\n    this.inflight = 0;\n    this.pending = {};\n  };\n  Loader.prototype = {\n    addNodes: function(nodes) {\n      this.inflight += nodes.length;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        this.require(n);\n      }\n      this.checkDone();\n    },\n    addNode: function(node) {\n      this.inflight++;\n      this.require(node);\n      this.checkDone();\n    },\n    require: function(elt) {\n      var url = elt.src || elt.href;\n      elt.__nodeUrl = url;\n      if (!this.dedupe(url, elt)) {\n        this.fetch(url, elt);\n      }\n    },\n    dedupe: function(url, elt) {\n      if (this.pending[url]) {\n        this.pending[url].push(elt);\n        return true;\n      }\n      var resource;\n      if (this.cache[url]) {\n        this.onload(url, elt, this.cache[url]);\n        this.tail();\n        return true;\n      }\n      this.pending[url] = [ elt ];\n      return false;\n    },\n    fetch: function(url, elt) {\n      flags.load && console.log(\"fetch\", url, elt);\n      if (!url) {\n        setTimeout(function() {\n          this.receive(url, elt, {\n            error: \"href must be specified\"\n          }, null);\n        }.bind(this), 0);\n      } else if (url.match(/^data:/)) {\n        var pieces = url.split(\",\");\n        var header = pieces[0];\n        var body = pieces[1];\n        if (header.indexOf(\";base64\") > -1) {\n          body = atob(body);\n        } else {\n          body = decodeURIComponent(body);\n        }\n        setTimeout(function() {\n          this.receive(url, elt, null, body);\n        }.bind(this), 0);\n      } else {\n        var receiveXhr = function(err, resource, redirectedUrl) {\n          this.receive(url, elt, err, resource, redirectedUrl);\n        }.bind(this);\n        xhr.load(url, receiveXhr);\n      }\n    },\n    receive: function(url, elt, err, resource, redirectedUrl) {\n      this.cache[url] = resource;\n      var $p = this.pending[url];\n      for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n        this.onload(url, p, resource, err, redirectedUrl);\n        this.tail();\n      }\n      this.pending[url] = null;\n    },\n    tail: function() {\n      --this.inflight;\n      this.checkDone();\n    },\n    checkDone: function() {\n      if (!this.inflight) {\n        this.oncomplete();\n      }\n    }\n  };\n  scope.Loader = Loader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var Observer = function(addCallback) {\n    this.addCallback = addCallback;\n    this.mo = new MutationObserver(this.handler.bind(this));\n  };\n  Observer.prototype = {\n    handler: function(mutations) {\n      for (var i = 0, l = mutations.length, m; i < l && (m = mutations[i]); i++) {\n        if (m.type === \"childList\" && m.addedNodes.length) {\n          this.addedNodes(m.addedNodes);\n        }\n      }\n    },\n    addedNodes: function(nodes) {\n      if (this.addCallback) {\n        this.addCallback(nodes);\n      }\n      for (var i = 0, l = nodes.length, n, loading; i < l && (n = nodes[i]); i++) {\n        if (n.children && n.children.length) {\n          this.addedNodes(n.children);\n        }\n      }\n    },\n    observe: function(root) {\n      this.mo.observe(root, {\n        childList: true,\n        subtree: true\n      });\n    }\n  };\n  scope.Observer = Observer;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var path = scope.path;\n  var rootDocument = scope.rootDocument;\n  var flags = scope.flags;\n  var isIE = scope.isIE;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = \"link[rel=\" + IMPORT_LINK_TYPE + \"]\";\n  var importParser = {\n    documentSelectors: IMPORT_SELECTOR,\n    importsSelectors: [ IMPORT_SELECTOR, \"link[rel=stylesheet]:not([type])\", \"style:not([type])\", \"script:not([type])\", 'script[type=\"application/javascript\"]', 'script[type=\"text/javascript\"]' ].join(\",\"),\n    map: {\n      link: \"parseLink\",\n      script: \"parseScript\",\n      style: \"parseStyle\"\n    },\n    dynamicElements: [],\n    parseNext: function() {\n      var next = this.nextToParse();\n      if (next) {\n        this.parse(next);\n      }\n    },\n    parse: function(elt) {\n      if (this.isParsed(elt)) {\n        flags.parse && console.log(\"[%s] is already parsed\", elt.localName);\n        return;\n      }\n      var fn = this[this.map[elt.localName]];\n      if (fn) {\n        this.markParsing(elt);\n        fn.call(this, elt);\n      }\n    },\n    parseDynamic: function(elt, quiet) {\n      this.dynamicElements.push(elt);\n      if (!quiet) {\n        this.parseNext();\n      }\n    },\n    markParsing: function(elt) {\n      flags.parse && console.log(\"parsing\", elt);\n      this.parsingElement = elt;\n    },\n    markParsingComplete: function(elt) {\n      elt.__importParsed = true;\n      this.markDynamicParsingComplete(elt);\n      if (elt.__importElement) {\n        elt.__importElement.__importParsed = true;\n        this.markDynamicParsingComplete(elt.__importElement);\n      }\n      this.parsingElement = null;\n      flags.parse && console.log(\"completed\", elt);\n    },\n    markDynamicParsingComplete: function(elt) {\n      var i = this.dynamicElements.indexOf(elt);\n      if (i >= 0) {\n        this.dynamicElements.splice(i, 1);\n      }\n    },\n    parseImport: function(elt) {\n      elt.import = elt.__doc;\n      if (window.HTMLImports.__importsParsingHook) {\n        window.HTMLImports.__importsParsingHook(elt);\n      }\n      if (elt.import) {\n        elt.import.__importParsed = true;\n      }\n      this.markParsingComplete(elt);\n      if (elt.__resource && !elt.__error) {\n        elt.dispatchEvent(new CustomEvent(\"load\", {\n          bubbles: false\n        }));\n      } else {\n        elt.dispatchEvent(new CustomEvent(\"error\", {\n          bubbles: false\n        }));\n      }\n      if (elt.__pending) {\n        var fn;\n        while (elt.__pending.length) {\n          fn = elt.__pending.shift();\n          if (fn) {\n            fn({\n              target: elt\n            });\n          }\n        }\n      }\n      this.parseNext();\n    },\n    parseLink: function(linkElt) {\n      if (nodeIsImport(linkElt)) {\n        this.parseImport(linkElt);\n      } else {\n        linkElt.href = linkElt.href;\n        this.parseGeneric(linkElt);\n      }\n    },\n    parseStyle: function(elt) {\n      var src = elt;\n      elt = cloneStyle(elt);\n      src.__appliedElement = elt;\n      elt.__importElement = src;\n      this.parseGeneric(elt);\n    },\n    parseGeneric: function(elt) {\n      this.trackElement(elt);\n      this.addElementToDocument(elt);\n    },\n    rootImportForElement: function(elt) {\n      var n = elt;\n      while (n.ownerDocument.__importLink) {\n        n = n.ownerDocument.__importLink;\n      }\n      return n;\n    },\n    addElementToDocument: function(elt) {\n      var port = this.rootImportForElement(elt.__importElement || elt);\n      port.parentNode.insertBefore(elt, port);\n    },\n    trackElement: function(elt, callback) {\n      var self = this;\n      var done = function(e) {\n        elt.removeEventListener(\"load\", done);\n        elt.removeEventListener(\"error\", done);\n        if (callback) {\n          callback(e);\n        }\n        self.markParsingComplete(elt);\n        self.parseNext();\n      };\n      elt.addEventListener(\"load\", done);\n      elt.addEventListener(\"error\", done);\n      if (isIE && elt.localName === \"style\") {\n        var fakeLoad = false;\n        if (elt.textContent.indexOf(\"@import\") == -1) {\n          fakeLoad = true;\n        } else if (elt.sheet) {\n          fakeLoad = true;\n          var csr = elt.sheet.cssRules;\n          var len = csr ? csr.length : 0;\n          for (var i = 0, r; i < len && (r = csr[i]); i++) {\n            if (r.type === CSSRule.IMPORT_RULE) {\n              fakeLoad = fakeLoad && Boolean(r.styleSheet);\n            }\n          }\n        }\n        if (fakeLoad) {\n          setTimeout(function() {\n            elt.dispatchEvent(new CustomEvent(\"load\", {\n              bubbles: false\n            }));\n          });\n        }\n      }\n    },\n    parseScript: function(scriptElt) {\n      var script = document.createElement(\"script\");\n      script.__importElement = scriptElt;\n      script.src = scriptElt.src ? scriptElt.src : generateScriptDataUrl(scriptElt);\n      scope.currentScript = scriptElt;\n      this.trackElement(script, function(e) {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n        scope.currentScript = null;\n      });\n      this.addElementToDocument(script);\n    },\n    nextToParse: function() {\n      this._mayParse = [];\n      return !this.parsingElement && (this.nextToParseInDoc(rootDocument) || this.nextToParseDynamic());\n    },\n    nextToParseInDoc: function(doc, link) {\n      if (doc && this._mayParse.indexOf(doc) < 0) {\n        this._mayParse.push(doc);\n        var nodes = doc.querySelectorAll(this.parseSelectorsForNode(doc));\n        for (var i = 0, l = nodes.length, p = 0, n; i < l && (n = nodes[i]); i++) {\n          if (!this.isParsed(n)) {\n            if (this.hasResource(n)) {\n              return nodeIsImport(n) ? this.nextToParseInDoc(n.__doc, n) : n;\n            } else {\n              return;\n            }\n          }\n        }\n      }\n      return link;\n    },\n    nextToParseDynamic: function() {\n      return this.dynamicElements[0];\n    },\n    parseSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentSelectors : this.importsSelectors;\n    },\n    isParsed: function(node) {\n      return node.__importParsed;\n    },\n    needsDynamicParsing: function(elt) {\n      return this.dynamicElements.indexOf(elt) >= 0;\n    },\n    hasResource: function(node) {\n      if (nodeIsImport(node) && node.__doc === undefined) {\n        return false;\n      }\n      return true;\n    }\n  };\n  function nodeIsImport(elt) {\n    return elt.localName === \"link\" && elt.rel === IMPORT_LINK_TYPE;\n  }\n  function generateScriptDataUrl(script) {\n    var scriptContent = generateScriptContent(script);\n    return \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(scriptContent);\n  }\n  function generateScriptContent(script) {\n    return script.textContent + generateSourceMapHint(script);\n  }\n  function generateSourceMapHint(script) {\n    var owner = script.ownerDocument;\n    owner.__importedScripts = owner.__importedScripts || 0;\n    var moniker = script.ownerDocument.baseURI;\n    var num = owner.__importedScripts ? \"-\" + owner.__importedScripts : \"\";\n    owner.__importedScripts++;\n    return \"\\n//# sourceURL=\" + moniker + num + \".js\\n\";\n  }\n  function cloneStyle(style) {\n    var clone = style.ownerDocument.createElement(\"style\");\n    clone.textContent = style.textContent;\n    path.resolveUrlsInStyle(clone);\n    return clone;\n  }\n  scope.parser = importParser;\n  scope.IMPORT_SELECTOR = IMPORT_SELECTOR;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var flags = scope.flags;\n  var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE;\n  var IMPORT_SELECTOR = scope.IMPORT_SELECTOR;\n  var rootDocument = scope.rootDocument;\n  var Loader = scope.Loader;\n  var Observer = scope.Observer;\n  var parser = scope.parser;\n  var importer = {\n    documents: {},\n    documentPreloadSelectors: IMPORT_SELECTOR,\n    importsPreloadSelectors: [ IMPORT_SELECTOR ].join(\",\"),\n    loadNode: function(node) {\n      importLoader.addNode(node);\n    },\n    loadSubtree: function(parent) {\n      var nodes = this.marshalNodes(parent);\n      importLoader.addNodes(nodes);\n    },\n    marshalNodes: function(parent) {\n      return parent.querySelectorAll(this.loadSelectorsForNode(parent));\n    },\n    loadSelectorsForNode: function(node) {\n      var doc = node.ownerDocument || node;\n      return doc === rootDocument ? this.documentPreloadSelectors : this.importsPreloadSelectors;\n    },\n    loaded: function(url, elt, resource, err, redirectedUrl) {\n      flags.load && console.log(\"loaded\", url, elt);\n      elt.__resource = resource;\n      elt.__error = err;\n      if (isImportLink(elt)) {\n        var doc = this.documents[url];\n        if (doc === undefined) {\n          doc = err ? null : makeDocument(resource, redirectedUrl || url);\n          if (doc) {\n            doc.__importLink = elt;\n            this.bootDocument(doc);\n          }\n          this.documents[url] = doc;\n        }\n        elt.__doc = doc;\n      }\n      parser.parseNext();\n    },\n    bootDocument: function(doc) {\n      this.loadSubtree(doc);\n      this.observer.observe(doc);\n      parser.parseNext();\n    },\n    loadedAll: function() {\n      parser.parseNext();\n    }\n  };\n  var importLoader = new Loader(importer.loaded.bind(importer), importer.loadedAll.bind(importer));\n  importer.observer = new Observer();\n  function isImportLink(elt) {\n    return isLinkRel(elt, IMPORT_LINK_TYPE);\n  }\n  function isLinkRel(elt, rel) {\n    return elt.localName === \"link\" && elt.getAttribute(\"rel\") === rel;\n  }\n  function hasBaseURIAccessor(doc) {\n    return !!Object.getOwnPropertyDescriptor(doc, \"baseURI\");\n  }\n  function makeDocument(resource, url) {\n    var doc = document.implementation.createHTMLDocument(IMPORT_LINK_TYPE);\n    doc._URL = url;\n    var base = doc.createElement(\"base\");\n    base.setAttribute(\"href\", url);\n    if (!doc.baseURI && !hasBaseURIAccessor(doc)) {\n      Object.defineProperty(doc, \"baseURI\", {\n        value: url\n      });\n    }\n    var meta = doc.createElement(\"meta\");\n    meta.setAttribute(\"charset\", \"utf-8\");\n    doc.head.appendChild(meta);\n    doc.head.appendChild(base);\n    doc.body.innerHTML = resource;\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(doc);\n    }\n    return doc;\n  }\n  if (!document.baseURI) {\n    var baseURIDescriptor = {\n      get: function() {\n        var base = document.querySelector(\"base\");\n        return base ? base.href : window.location.href;\n      },\n      configurable: true\n    };\n    Object.defineProperty(document, \"baseURI\", baseURIDescriptor);\n    Object.defineProperty(rootDocument, \"baseURI\", baseURIDescriptor);\n  }\n  scope.importer = importer;\n  scope.importLoader = importLoader;\n});\n\nwindow.HTMLImports.addModule(function(scope) {\n  var parser = scope.parser;\n  var importer = scope.importer;\n  var dynamic = {\n    added: function(nodes) {\n      var owner, parsed, loading;\n      for (var i = 0, l = nodes.length, n; i < l && (n = nodes[i]); i++) {\n        if (!owner) {\n          owner = n.ownerDocument;\n          parsed = parser.isParsed(owner);\n        }\n        loading = this.shouldLoadNode(n);\n        if (loading) {\n          importer.loadNode(n);\n        }\n        if (this.shouldParseNode(n) && parsed) {\n          parser.parseDynamic(n, loading);\n        }\n      }\n    },\n    shouldLoadNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, importer.loadSelectorsForNode(node));\n    },\n    shouldParseNode: function(node) {\n      return node.nodeType === 1 && matches.call(node, parser.parseSelectorsForNode(node));\n    }\n  };\n  importer.observer.addCallback = dynamic.added.bind(dynamic);\n  var matches = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector;\n});\n\n(function(scope) {\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (scope.useNative) {\n    return;\n  }\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      e.preventDefault = function() {\n        Object.defineProperty(this, \"defaultPrevented\", {\n          get: function() {\n            return true;\n          }\n        });\n      };\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  initializeModules();\n  var rootDocument = scope.rootDocument;\n  function bootstrap() {\n    window.HTMLImports.importer.bootDocument(rootDocument);\n  }\n  if (document.readyState === \"complete\" || document.readyState === \"interactive\" && !window.attachEvent) {\n    bootstrap();\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", bootstrap);\n  }\n})(window.HTMLImports);\n\nwindow.CustomElements = window.CustomElements || {\n  flags: {}\n};\n\n(function(scope) {\n  var flags = scope.flags;\n  var modules = [];\n  var addModule = function(module) {\n    modules.push(module);\n  };\n  var initializeModules = function() {\n    modules.forEach(function(module) {\n      module(scope);\n    });\n  };\n  scope.addModule = addModule;\n  scope.initializeModules = initializeModules;\n  scope.hasNative = Boolean(document.registerElement);\n  scope.isIE = /Trident/.test(navigator.userAgent);\n  scope.useNative = !flags.register && scope.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative);\n})(window.CustomElements);\n\nwindow.CustomElements.addModule(function(scope) {\n  var IMPORT_LINK_TYPE = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : \"none\";\n  function forSubtree(node, cb) {\n    findAllElements(node, function(e) {\n      if (cb(e)) {\n        return true;\n      }\n      forRoots(e, cb);\n    });\n    forRoots(node, cb);\n  }\n  function findAllElements(node, find, data) {\n    var e = node.firstElementChild;\n    if (!e) {\n      e = node.firstChild;\n      while (e && e.nodeType !== Node.ELEMENT_NODE) {\n        e = e.nextSibling;\n      }\n    }\n    while (e) {\n      if (find(e, data) !== true) {\n        findAllElements(e, find, data);\n      }\n      e = e.nextElementSibling;\n    }\n    return null;\n  }\n  function forRoots(node, cb) {\n    var root = node.shadowRoot;\n    while (root) {\n      forSubtree(root, cb);\n      root = root.olderShadowRoot;\n    }\n  }\n  function forDocumentTree(doc, cb) {\n    _forDocumentTree(doc, cb, []);\n  }\n  function _forDocumentTree(doc, cb, processingDocuments) {\n    doc = window.wrap(doc);\n    if (processingDocuments.indexOf(doc) >= 0) {\n      return;\n    }\n    processingDocuments.push(doc);\n    var imports = doc.querySelectorAll(\"link[rel=\" + IMPORT_LINK_TYPE + \"]\");\n    for (var i = 0, l = imports.length, n; i < l && (n = imports[i]); i++) {\n      if (n.import) {\n        _forDocumentTree(n.import, cb, processingDocuments);\n      }\n    }\n    cb(doc);\n  }\n  scope.forDocumentTree = forDocumentTree;\n  scope.forSubtree = forSubtree;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  var forSubtree = scope.forSubtree;\n  var forDocumentTree = scope.forDocumentTree;\n  function addedNode(node, isAttached) {\n    return added(node, isAttached) || addedSubtree(node, isAttached);\n  }\n  function added(node, isAttached) {\n    if (scope.upgrade(node, isAttached)) {\n      return true;\n    }\n    if (isAttached) {\n      attached(node);\n    }\n  }\n  function addedSubtree(node, isAttached) {\n    forSubtree(node, function(e) {\n      if (added(e, isAttached)) {\n        return true;\n      }\n    });\n  }\n  var hasPolyfillMutations = !window.MutationObserver || window.MutationObserver === window.JsMutationObserver;\n  scope.hasPolyfillMutations = hasPolyfillMutations;\n  var isPendingMutations = false;\n  var pendingMutations = [];\n  function deferMutation(fn) {\n    pendingMutations.push(fn);\n    if (!isPendingMutations) {\n      isPendingMutations = true;\n      setTimeout(takeMutations);\n    }\n  }\n  function takeMutations() {\n    isPendingMutations = false;\n    var $p = pendingMutations;\n    for (var i = 0, l = $p.length, p; i < l && (p = $p[i]); i++) {\n      p();\n    }\n    pendingMutations = [];\n  }\n  function attached(element) {\n    if (hasPolyfillMutations) {\n      deferMutation(function() {\n        _attached(element);\n      });\n    } else {\n      _attached(element);\n    }\n  }\n  function _attached(element) {\n    if (element.__upgraded__ && !element.__attached) {\n      element.__attached = true;\n      if (element.attachedCallback) {\n        element.attachedCallback();\n      }\n    }\n  }\n  function detachedNode(node) {\n    detached(node);\n    forSubtree(node, function(e) {\n      detached(e);\n    });\n  }\n  function detached(element) {\n    if (hasPolyfillMutations) {\n      deferMutation(function() {\n        _detached(element);\n      });\n    } else {\n      _detached(element);\n    }\n  }\n  function _detached(element) {\n    if (element.__upgraded__ && element.__attached) {\n      element.__attached = false;\n      if (element.detachedCallback) {\n        element.detachedCallback();\n      }\n    }\n  }\n  function inDocument(element) {\n    var p = element;\n    var doc = window.wrap(document);\n    while (p) {\n      if (p == doc) {\n        return true;\n      }\n      p = p.parentNode || p.nodeType === Node.DOCUMENT_FRAGMENT_NODE && p.host;\n    }\n  }\n  function watchShadow(node) {\n    if (node.shadowRoot && !node.shadowRoot.__watched) {\n      flags.dom && console.log(\"watching shadow-root for: \", node.localName);\n      var root = node.shadowRoot;\n      while (root) {\n        observe(root);\n        root = root.olderShadowRoot;\n      }\n    }\n  }\n  function handler(root, mutations) {\n    if (flags.dom) {\n      var mx = mutations[0];\n      if (mx && mx.type === \"childList\" && mx.addedNodes) {\n        if (mx.addedNodes) {\n          var d = mx.addedNodes[0];\n          while (d && d !== document && !d.host) {\n            d = d.parentNode;\n          }\n          var u = d && (d.URL || d._URL || d.host && d.host.localName) || \"\";\n          u = u.split(\"/?\").shift().split(\"/\").pop();\n        }\n      }\n      console.group(\"mutations (%d) [%s]\", mutations.length, u || \"\");\n    }\n    var isAttached = inDocument(root);\n    mutations.forEach(function(mx) {\n      if (mx.type === \"childList\") {\n        forEach(mx.addedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          addedNode(n, isAttached);\n        });\n        forEach(mx.removedNodes, function(n) {\n          if (!n.localName) {\n            return;\n          }\n          detachedNode(n);\n        });\n      }\n    });\n    flags.dom && console.groupEnd();\n  }\n  function takeRecords(node) {\n    node = window.wrap(node);\n    if (!node) {\n      node = window.wrap(document);\n    }\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    var observer = node.__observer;\n    if (observer) {\n      handler(node, observer.takeRecords());\n      takeMutations();\n    }\n  }\n  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);\n  function observe(inRoot) {\n    if (inRoot.__observer) {\n      return;\n    }\n    var observer = new MutationObserver(handler.bind(this, inRoot));\n    observer.observe(inRoot, {\n      childList: true,\n      subtree: true\n    });\n    inRoot.__observer = observer;\n  }\n  function upgradeDocument(doc) {\n    doc = window.wrap(doc);\n    flags.dom && console.group(\"upgradeDocument: \", doc.baseURI.split(\"/\").pop());\n    var isMainDocument = doc === window.wrap(document);\n    addedNode(doc, isMainDocument);\n    observe(doc);\n    flags.dom && console.groupEnd();\n  }\n  function upgradeDocumentTree(doc) {\n    forDocumentTree(doc, upgradeDocument);\n  }\n  var originalCreateShadowRoot = Element.prototype.createShadowRoot;\n  if (originalCreateShadowRoot) {\n    Element.prototype.createShadowRoot = function() {\n      var root = originalCreateShadowRoot.call(this);\n      window.CustomElements.watchShadow(this);\n      return root;\n    };\n  }\n  scope.watchShadow = watchShadow;\n  scope.upgradeDocumentTree = upgradeDocumentTree;\n  scope.upgradeDocument = upgradeDocument;\n  scope.upgradeSubtree = addedSubtree;\n  scope.upgradeAll = addedNode;\n  scope.attached = attached;\n  scope.takeRecords = takeRecords;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var flags = scope.flags;\n  function upgrade(node, isAttached) {\n    if (!node.__upgraded__ && node.nodeType === Node.ELEMENT_NODE) {\n      var is = node.getAttribute(\"is\");\n      var definition = scope.getRegisteredDefinition(node.localName) || scope.getRegisteredDefinition(is);\n      if (definition) {\n        if (is && definition.tag == node.localName || !is && !definition.extends) {\n          return upgradeWithDefinition(node, definition, isAttached);\n        }\n      }\n    }\n  }\n  function upgradeWithDefinition(element, definition, isAttached) {\n    flags.upgrade && console.group(\"upgrade:\", element.localName);\n    if (definition.is) {\n      element.setAttribute(\"is\", definition.is);\n    }\n    implementPrototype(element, definition);\n    element.__upgraded__ = true;\n    created(element);\n    if (isAttached) {\n      scope.attached(element);\n    }\n    scope.upgradeSubtree(element, isAttached);\n    flags.upgrade && console.groupEnd();\n    return element;\n  }\n  function implementPrototype(element, definition) {\n    if (Object.__proto__) {\n      element.__proto__ = definition.prototype;\n    } else {\n      customMixin(element, definition.prototype, definition.native);\n      element.__proto__ = definition.prototype;\n    }\n  }\n  function customMixin(inTarget, inSrc, inNative) {\n    var used = {};\n    var p = inSrc;\n    while (p !== inNative && p !== HTMLElement.prototype) {\n      var keys = Object.getOwnPropertyNames(p);\n      for (var i = 0, k; k = keys[i]; i++) {\n        if (!used[k]) {\n          Object.defineProperty(inTarget, k, Object.getOwnPropertyDescriptor(p, k));\n          used[k] = 1;\n        }\n      }\n      p = Object.getPrototypeOf(p);\n    }\n  }\n  function created(element) {\n    if (element.createdCallback) {\n      element.createdCallback();\n    }\n  }\n  scope.upgrade = upgrade;\n  scope.upgradeWithDefinition = upgradeWithDefinition;\n  scope.implementPrototype = implementPrototype;\n});\n\nwindow.CustomElements.addModule(function(scope) {\n  var isIE = scope.isIE;\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeAll = scope.upgradeAll;\n  var upgradeWithDefinition = scope.upgradeWithDefinition;\n  var implementPrototype = scope.implementPrototype;\n  var useNative = scope.useNative;\n  function register(name, options) {\n    var definition = options || {};\n    if (!name) {\n      throw new Error(\"document.registerElement: first argument `name` must not be empty\");\n    }\n    if (name.indexOf(\"-\") < 0) {\n      throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\" + String(name) + \"'.\");\n    }\n    if (isReservedTag(name)) {\n      throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\" + String(name) + \"'. The type name is invalid.\");\n    }\n    if (getRegisteredDefinition(name)) {\n      throw new Error(\"DuplicateDefinitionError: a type with name '\" + String(name) + \"' is already registered\");\n    }\n    if (!definition.prototype) {\n      definition.prototype = Object.create(HTMLElement.prototype);\n    }\n    definition.__name = name.toLowerCase();\n    definition.lifecycle = definition.lifecycle || {};\n    definition.ancestry = ancestry(definition.extends);\n    resolveTagName(definition);\n    resolvePrototypeChain(definition);\n    overrideAttributeApi(definition.prototype);\n    registerDefinition(definition.__name, definition);\n    definition.ctor = generateConstructor(definition);\n    definition.ctor.prototype = definition.prototype;\n    definition.prototype.constructor = definition.ctor;\n    if (scope.ready) {\n      upgradeDocumentTree(document);\n    }\n    return definition.ctor;\n  }\n  function overrideAttributeApi(prototype) {\n    if (prototype.setAttribute._polyfilled) {\n      return;\n    }\n    var setAttribute = prototype.setAttribute;\n    prototype.setAttribute = function(name, value) {\n      changeAttribute.call(this, name, value, setAttribute);\n    };\n    var removeAttribute = prototype.removeAttribute;\n    prototype.removeAttribute = function(name) {\n      changeAttribute.call(this, name, null, removeAttribute);\n    };\n    prototype.setAttribute._polyfilled = true;\n  }\n  function changeAttribute(name, value, operation) {\n    name = name.toLowerCase();\n    var oldValue = this.getAttribute(name);\n    operation.apply(this, arguments);\n    var newValue = this.getAttribute(name);\n    if (this.attributeChangedCallback && newValue !== oldValue) {\n      this.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n  function isReservedTag(name) {\n    for (var i = 0; i < reservedTagList.length; i++) {\n      if (name === reservedTagList[i]) {\n        return true;\n      }\n    }\n  }\n  var reservedTagList = [ \"annotation-xml\", \"color-profile\", \"font-face\", \"font-face-src\", \"font-face-uri\", \"font-face-format\", \"font-face-name\", \"missing-glyph\" ];\n  function ancestry(extnds) {\n    var extendee = getRegisteredDefinition(extnds);\n    if (extendee) {\n      return ancestry(extendee.extends).concat([ extendee ]);\n    }\n    return [];\n  }\n  function resolveTagName(definition) {\n    var baseTag = definition.extends;\n    for (var i = 0, a; a = definition.ancestry[i]; i++) {\n      baseTag = a.is && a.tag;\n    }\n    definition.tag = baseTag || definition.__name;\n    if (baseTag) {\n      definition.is = definition.__name;\n    }\n  }\n  function resolvePrototypeChain(definition) {\n    if (!Object.__proto__) {\n      var nativePrototype = HTMLElement.prototype;\n      if (definition.is) {\n        var inst = document.createElement(definition.tag);\n        nativePrototype = Object.getPrototypeOf(inst);\n      }\n      var proto = definition.prototype, ancestor;\n      var foundPrototype = false;\n      while (proto) {\n        if (proto == nativePrototype) {\n          foundPrototype = true;\n        }\n        ancestor = Object.getPrototypeOf(proto);\n        if (ancestor) {\n          proto.__proto__ = ancestor;\n        }\n        proto = ancestor;\n      }\n      if (!foundPrototype) {\n        console.warn(definition.tag + \" prototype not found in prototype chain for \" + definition.is);\n      }\n      definition.native = nativePrototype;\n    }\n  }\n  function instantiate(definition) {\n    return upgradeWithDefinition(domCreateElement(definition.tag), definition);\n  }\n  var registry = {};\n  function getRegisteredDefinition(name) {\n    if (name) {\n      return registry[name.toLowerCase()];\n    }\n  }\n  function registerDefinition(name, definition) {\n    registry[name] = definition;\n  }\n  function generateConstructor(definition) {\n    return function() {\n      return instantiate(definition);\n    };\n  }\n  var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n  function createElementNS(namespace, tag, typeExtension) {\n    if (namespace === HTML_NAMESPACE) {\n      return createElement(tag, typeExtension);\n    } else {\n      return domCreateElementNS(namespace, tag);\n    }\n  }\n  function createElement(tag, typeExtension) {\n    if (tag) {\n      tag = tag.toLowerCase();\n    }\n    if (typeExtension) {\n      typeExtension = typeExtension.toLowerCase();\n    }\n    var definition = getRegisteredDefinition(typeExtension || tag);\n    if (definition) {\n      if (tag == definition.tag && typeExtension == definition.is) {\n        return new definition.ctor();\n      }\n      if (!typeExtension && !definition.is) {\n        return new definition.ctor();\n      }\n    }\n    var element;\n    if (typeExtension) {\n      element = createElement(tag);\n      element.setAttribute(\"is\", typeExtension);\n      return element;\n    }\n    element = domCreateElement(tag);\n    if (tag.indexOf(\"-\") >= 0) {\n      implementPrototype(element, HTMLElement);\n    }\n    return element;\n  }\n  var domCreateElement = document.createElement.bind(document);\n  var domCreateElementNS = document.createElementNS.bind(document);\n  var isInstance;\n  if (!Object.__proto__ && !useNative) {\n    isInstance = function(obj, ctor) {\n      if (obj instanceof ctor) {\n        return true;\n      }\n      var p = obj;\n      while (p) {\n        if (p === ctor.prototype) {\n          return true;\n        }\n        p = p.__proto__;\n      }\n      return false;\n    };\n  } else {\n    isInstance = function(obj, base) {\n      return obj instanceof base;\n    };\n  }\n  function wrapDomMethodToForceUpgrade(obj, methodName) {\n    var orig = obj[methodName];\n    obj[methodName] = function() {\n      var n = orig.apply(this, arguments);\n      upgradeAll(n);\n      return n;\n    };\n  }\n  wrapDomMethodToForceUpgrade(Node.prototype, \"cloneNode\");\n  wrapDomMethodToForceUpgrade(document, \"importNode\");\n  if (isIE) {\n    (function() {\n      var importNode = document.importNode;\n      document.importNode = function() {\n        var n = importNode.apply(document, arguments);\n        if (n.nodeType == n.DOCUMENT_FRAGMENT_NODE) {\n          var f = document.createDocumentFragment();\n          f.appendChild(n);\n          return f;\n        } else {\n          return n;\n        }\n      };\n    })();\n  }\n  document.registerElement = register;\n  document.createElement = createElement;\n  document.createElementNS = createElementNS;\n  scope.registry = registry;\n  scope.instanceof = isInstance;\n  scope.reservedTagList = reservedTagList;\n  scope.getRegisteredDefinition = getRegisteredDefinition;\n  document.register = document.registerElement;\n});\n\n(function(scope) {\n  var useNative = scope.useNative;\n  var initializeModules = scope.initializeModules;\n  var isIE = scope.isIE;\n  if (useNative) {\n    var nop = function() {};\n    scope.watchShadow = nop;\n    scope.upgrade = nop;\n    scope.upgradeAll = nop;\n    scope.upgradeDocumentTree = nop;\n    scope.upgradeSubtree = nop;\n    scope.takeRecords = nop;\n    scope.instanceof = function(obj, base) {\n      return obj instanceof base;\n    };\n  } else {\n    initializeModules();\n  }\n  var upgradeDocumentTree = scope.upgradeDocumentTree;\n  var upgradeDocument = scope.upgradeDocument;\n  if (!window.wrap) {\n    if (window.ShadowDOMPolyfill) {\n      window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded;\n      window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded;\n    } else {\n      window.wrap = window.unwrap = function(node) {\n        return node;\n      };\n    }\n  }\n  if (window.HTMLImports) {\n    window.HTMLImports.__importsParsingHook = function(elt) {\n      if (elt.import) {\n        upgradeDocument(wrap(elt.import));\n      }\n    };\n  }\n  function bootstrap() {\n    upgradeDocumentTree(window.wrap(document));\n    window.CustomElements.ready = true;\n    var requestAnimationFrame = window.requestAnimationFrame || function(f) {\n      setTimeout(f, 16);\n    };\n    requestAnimationFrame(function() {\n      setTimeout(function() {\n        window.CustomElements.readyTime = Date.now();\n        if (window.HTMLImports) {\n          window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime;\n        }\n        document.dispatchEvent(new CustomEvent(\"WebComponentsReady\", {\n          bubbles: true\n        }));\n      });\n    });\n  }\n  if (!window.CustomEvent || isIE && typeof window.CustomEvent !== \"function\") {\n    window.CustomEvent = function(inType, params) {\n      params = params || {};\n      var e = document.createEvent(\"CustomEvent\");\n      e.initCustomEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable), params.detail);\n      e.preventDefault = function() {\n        Object.defineProperty(this, \"defaultPrevented\", {\n          get: function() {\n            return true;\n          }\n        });\n      };\n      return e;\n    };\n    window.CustomEvent.prototype = window.Event.prototype;\n  }\n  if (document.readyState === \"complete\" || scope.flags.eager) {\n    bootstrap();\n  } else if (document.readyState === \"interactive\" && !window.attachEvent && (!window.HTMLImports || window.HTMLImports.ready)) {\n    bootstrap();\n  } else {\n    var loadEvent = window.HTMLImports && !window.HTMLImports.ready ? \"HTMLImportsLoaded\" : \"DOMContentLoaded\";\n    window.addEventListener(loadEvent, bootstrap);\n  }\n})(window.CustomElements);\n\n(function(scope) {\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function(scope) {\n      var self = this;\n      var args = Array.prototype.slice.call(arguments, 1);\n      return function() {\n        var args2 = args.slice();\n        args2.push.apply(args2, arguments);\n        return self.apply(scope, args2);\n      };\n    };\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  \"use strict\";\n  if (!window.performance) {\n    var start = Date.now();\n    window.performance = {\n      now: function() {\n        return Date.now() - start;\n      }\n    };\n  }\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function() {\n      var nativeRaf = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;\n      return nativeRaf ? function(callback) {\n        return nativeRaf(function() {\n          callback(performance.now());\n        });\n      } : function(callback) {\n        return window.setTimeout(callback, 1e3 / 60);\n      };\n    }();\n  }\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function() {\n      return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(id) {\n        clearTimeout(id);\n      };\n    }();\n  }\n})(window.WebComponents);\n\n(function(scope) {\n  var style = document.createElement(\"style\");\n  style.textContent = \"\" + \"body {\" + \"transition: opacity ease-in 0.2s;\" + \" } \\n\" + \"body[unresolved] {\" + \"opacity: 0; display: block; overflow: hidden; position: relative;\" + \" } \\n\";\n  var head = document.querySelector(\"head\");\n  head.insertBefore(style, head.firstChild);\n})(window.WebComponents);\n\n(function(scope) {\n  window.Platform = scope;\n})(window.WebComponents);",
"static/index.html": "<!doctype html>\n<html>\n\t<head>\n\t\t<title>pilot</title>\n\t\t<script src=\"/static/deps/jquery.min.js\"></script>\n    <script src=\"/static/deps/webcomponents.js\"></script>\n    <link rel=\"import\" href=\"/static/deps/polymer.html\">\n    <link rel=\"import\" href=\"/static/components/app.html\">\n\t</head>\n\t<body>\n\t\t<pilot-main></pilot-main>\n\t</body>\n</html>",
"static/components/index.html": "<dom-module id=\"pilot-index\">\n\n  <script src=\"/static/deps/api.js\"></script>\n\n  <template>\n    <style>\n    </style>\n    <template is=\"dom-repeat\" items=\"{{files}}\" as=\"file\">\n      <a href=\"{{file.link}}\">{{file.name}}</p>\n    </template>\n  </template>\n\n  <script>\n    Polymer({\n      is: 'pilot-index',\n      ready: function() {\n      \tthis.files = [];\n        api.Call('ListFiles', {}, function(resp) {\n          if (!resp.Files) { return }\n          this.set('files', resp.Files.map(function(file) {\n            return {\n              link: '#!/play/' + file,\n              name: file\n            };\n          }));\n        }.bind(this));\n      }\n    });\n  </script>\n\n</dom-module>",
"static/components/play.html": "<dom-module id=\"pilot-play\">\n\n  <template>\n    <style>\n    </style>\n    <video\n    \tid=\"video\"\n      src=\"{{video}}\"\n      controls\n      autoplay\n    ></video>\n  </template>\n\n  <script>\n    Polymer({\n      is: 'pilot-play',\n      properties: {\n      \tvideo: String\n      },\n      ready: function() {\n      \tthis.$.video.addEventListener('loadedmetadata', function() {\n\t      \tvar state = localStorage.getItem('pilot-play');\n\t      \tif (state) {\n\t      \t\tstate = JSON.parse(state);\n\t      \t\tif (state.video == this.video) {\n\t      \t\t\tthis.$.video.currentTime = state.currentTime - 5;\n\t      \t\t}\n\t      \t}\n      \t}.bind(this));\n      \tthis.$.video.addEventListener('timeupdate', function() {\n\t      \tlocalStorage.setItem('pilot-play', JSON.stringify({\n\t      \t\tvideo: this.video,\n\t      \t\tcurrentTime: this.$.video.currentTime\n\t      \t}));\n      \t}.bind(this));\n      }\n    });\n  </script>\n\n</dom-module>",
"static/components/tv.html": "<dom-module id=\"pilot-tv\">\n\n  <script src=\"/static/deps/api.js\"></script>\n\n  <template>\n    <style>\n    </style>\n    <template is=\"dom-if\" if=\"!tv.On\">\n      <button>On</button>\n    </template>\n    <button on-click=\"play\">Play</button>\n    <button on-click=\"pause\">Pause</button>\n    <button on-click=\"stop\">Stop</button>\n    <p>Now playing: <span>{{tv.Playing}}</span></p>\n  </template>\n\n  <script>\n    Polymer({\n      is: 'pilot-tv',\n      ready: function() {\n      \tthis.tv = null;\n        api.Call('TVStatus', {}, function(resp) {\n          this.set('tv', resp.TV);\n        }.bind(this));\n      },\n      play: function() {\n        api.Call('Play', {Filename: 'content/sample1.mp4'}, function(resp) {\n          this.set('tv', resp.TV);\n        }.bind(this));\n      },\n      pause: function() {\n        api.Call('Pause', {}, function(resp) {\n          this.set('tv', resp.TV);\n        }.bind(this));\n      },\n      stop: function() {\n        api.Call('Stop', {}, function(resp) {\n          this.set('tv', resp.TV);\n        }.bind(this));\n      }\n    });\n  </script>\n\n</dom-module>",
"static/deps/page.js": "!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.page=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\n  /* globals require, module */\n\n  'use strict';\n\n  /**\n   * Module dependencies.\n   */\n\n  var pathtoRegexp = require('path-to-regexp');\n\n  /**\n   * Module exports.\n   */\n\n  module.exports = page;\n\n  /**\n   * Detect click event\n   */\n  var clickEvent = ('undefined' !== typeof document) && document.ontouchstart ? 'touchstart' : 'click';\n\n  /**\n   * To work properly with the URL\n   * history.location generated polyfill in https://github.com/devote/HTML5-History-API\n   */\n\n  var location = ('undefined' !== typeof window) && (window.history.location || window.location);\n\n  /**\n   * Perform initial dispatch.\n   */\n\n  var dispatch = true;\n\n\n  /**\n   * Decode URL components (query string, pathname, hash).\n   * Accommodates both regular percent encoding and x-www-form-urlencoded format.\n   */\n  var decodeURLComponents = true;\n\n  /**\n   * Base path.\n   */\n\n  var base = '';\n\n  /**\n   * Running flag.\n   */\n\n  var running;\n\n  /**\n   * HashBang option\n   */\n\n  var hashbang = false;\n\n  /**\n   * Previous context, for capturing\n   * page exit events.\n   */\n\n  var prevContext;\n\n  /**\n   * Register `path` with callback `fn()`,\n   * or route `path`, or redirection,\n   * or `page.start()`.\n   *\n   *   page(fn);\n   *   page('*', fn);\n   *   page('/user/:id', load, user);\n   *   page('/user/' + user.id, { some: 'thing' });\n   *   page('/user/' + user.id);\n   *   page('/from', '/to')\n   *   page();\n   *\n   * @param {String|Function} path\n   * @param {Function} fn...\n   * @api public\n   */\n\n  function page(path, fn) {\n    // <callback>\n    if ('function' === typeof path) {\n      return page('*', path);\n    }\n\n    // route <path> to <callback ...>\n    if ('function' === typeof fn) {\n      var route = new Route(path);\n      for (var i = 1; i < arguments.length; ++i) {\n        page.callbacks.push(route.middleware(arguments[i]));\n      }\n      // show <path> with [state]\n    } else if ('string' === typeof path) {\n      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);\n      // start [options]\n    } else {\n      page.start(path);\n    }\n  }\n\n  /**\n   * Callback functions.\n   */\n\n  page.callbacks = [];\n  page.exits = [];\n\n  /**\n   * Current path being processed\n   * @type {String}\n   */\n  page.current = '';\n\n  /**\n   * Number of pages navigated to.\n   * @type {number}\n   *\n   *     page.len == 0;\n   *     page('/login');\n   *     page.len == 1;\n   */\n\n  page.len = 0;\n\n  /**\n   * Get or set basepath to `path`.\n   *\n   * @param {String} path\n   * @api public\n   */\n\n  page.base = function(path) {\n    if (0 === arguments.length) return base;\n    base = path;\n  };\n\n  /**\n   * Bind with the given `options`.\n   *\n   * Options:\n   *\n   *    - `click` bind to click events [true]\n   *    - `popstate` bind to popstate [true]\n   *    - `dispatch` perform initial dispatch [true]\n   *\n   * @param {Object} options\n   * @api public\n   */\n\n  page.start = function(options) {\n    options = options || {};\n    if (running) return;\n    running = true;\n    if (false === options.dispatch) dispatch = false;\n    if (false === options.decodeURLComponents) decodeURLComponents = false;\n    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);\n    if (false !== options.click) {\n      document.addEventListener(clickEvent, onclick, false);\n    }\n    if (true === options.hashbang) hashbang = true;\n    if (!dispatch) return;\n    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;\n    page.replace(url, null, true, dispatch);\n  };\n\n  /**\n   * Unbind click and popstate event handlers.\n   *\n   * @api public\n   */\n\n  page.stop = function() {\n    if (!running) return;\n    page.current = '';\n    page.len = 0;\n    running = false;\n    document.removeEventListener(clickEvent, onclick, false);\n    window.removeEventListener('popstate', onpopstate, false);\n  };\n\n  /**\n   * Show `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @param {Boolean} dispatch\n   * @return {Context}\n   * @api public\n   */\n\n  page.show = function(path, state, dispatch, push) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    if (false !== dispatch) page.dispatch(ctx);\n    if (false !== ctx.handled && false !== push) ctx.pushState();\n    return ctx;\n  };\n\n  /**\n   * Goes back in the history\n   * Back should always let the current route push state and then go back.\n   *\n   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base\n   * @param {Object} [state]\n   * @api public\n   */\n\n  page.back = function(path, state) {\n    if (page.len > 0) {\n      // this may need more testing to see if all browsers\n      // wait for the next tick to go back in history\n      history.back();\n      page.len--;\n    } else if (path) {\n      setTimeout(function() {\n        page.show(path, state);\n      });\n    }else{\n      setTimeout(function() {\n        page.show(base, state);\n      });\n    }\n  };\n\n\n  /**\n   * Register route to redirect from one path to other\n   * or just redirect to another route\n   *\n   * @param {String} from - if param 'to' is undefined redirects to 'from'\n   * @param {String} [to]\n   * @api public\n   */\n  page.redirect = function(from, to) {\n    // Define route from a path to another\n    if ('string' === typeof from && 'string' === typeof to) {\n      page(from, function(e) {\n        setTimeout(function() {\n          page.replace(to);\n        }, 0);\n      });\n    }\n\n    // Wait for the push state and replace it with another\n    if ('string' === typeof from && 'undefined' === typeof to) {\n      setTimeout(function() {\n        page.replace(from);\n      }, 0);\n    }\n  };\n\n  /**\n   * Replace `path` with optional `state` object.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @return {Context}\n   * @api public\n   */\n\n\n  page.replace = function(path, state, init, dispatch) {\n    var ctx = new Context(path, state);\n    page.current = ctx.path;\n    ctx.init = init;\n    ctx.save(); // save before dispatching, which may redirect\n    if (false !== dispatch) page.dispatch(ctx);\n    return ctx;\n  };\n\n  /**\n   * Dispatch the given `ctx`.\n   *\n   * @param {Object} ctx\n   * @api private\n   */\n\n  page.dispatch = function(ctx) {\n    var prev = prevContext,\n      i = 0,\n      j = 0;\n\n    prevContext = ctx;\n\n    function nextExit() {\n      var fn = page.exits[j++];\n      if (!fn) return nextEnter();\n      fn(prev, nextExit);\n    }\n\n    function nextEnter() {\n      var fn = page.callbacks[i++];\n\n      if (ctx.path !== page.current) {\n        ctx.handled = false;\n        return;\n      }\n      if (!fn) return unhandled(ctx);\n      fn(ctx, nextEnter);\n    }\n\n    if (prev) {\n      nextExit();\n    } else {\n      nextEnter();\n    }\n  };\n\n  /**\n   * Unhandled `ctx`. When it's not the initial\n   * popstate then redirect. If you wish to handle\n   * 404s on your own use `page('*', callback)`.\n   *\n   * @param {Context} ctx\n   * @api private\n   */\n\n  function unhandled(ctx) {\n    if (ctx.handled) return;\n    var current;\n\n    if (hashbang) {\n      current = base + location.hash.replace('#!', '');\n    } else {\n      current = location.pathname + location.search;\n    }\n\n    if (current === ctx.canonicalPath) return;\n    page.stop();\n    ctx.handled = false;\n    location.href = ctx.canonicalPath;\n  }\n\n  /**\n   * Register an exit route on `path` with\n   * callback `fn()`, which will be called\n   * on the previous context when a new\n   * page is visited.\n   */\n  page.exit = function(path, fn) {\n    if (typeof path === 'function') {\n      return page.exit('*', path);\n    }\n\n    var route = new Route(path);\n    for (var i = 1; i < arguments.length; ++i) {\n      page.exits.push(route.middleware(arguments[i]));\n    }\n  };\n\n  /**\n   * Remove URL encoding from the given `str`.\n   * Accommodates whitespace in both x-www-form-urlencoded\n   * and regular percent-encoded form.\n   *\n   * @param {str} URL component to decode\n   */\n  function decodeURLEncodedURIComponent(val) {\n    if (typeof val !== 'string') { return val; }\n    return decodeURLComponents ? decodeURIComponent(val.replace(/\\+/g, ' ')) : val;\n  }\n\n  /**\n   * Initialize a new \"request\" `Context`\n   * with the given `path` and optional initial `state`.\n   *\n   * @param {String} path\n   * @param {Object} state\n   * @api public\n   */\n\n  function Context(path, state) {\n    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;\n    var i = path.indexOf('?');\n\n    this.canonicalPath = path;\n    this.path = path.replace(base, '') || '/';\n    if (hashbang) this.path = this.path.replace('#!', '') || '/';\n\n    this.title = document.title;\n    this.state = state || {};\n    this.state.path = path;\n    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';\n    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);\n    this.params = {};\n\n    // fragment\n    this.hash = '';\n    if (!hashbang) {\n      if (!~this.path.indexOf('#')) return;\n      var parts = this.path.split('#');\n      this.path = parts[0];\n      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';\n      this.querystring = this.querystring.split('#')[0];\n    }\n  }\n\n  /**\n   * Expose `Context`.\n   */\n\n  page.Context = Context;\n\n  /**\n   * Push state.\n   *\n   * @api private\n   */\n\n  Context.prototype.pushState = function() {\n    page.len++;\n    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Save the context state.\n   *\n   * @api public\n   */\n\n  Context.prototype.save = function() {\n    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);\n  };\n\n  /**\n   * Initialize `Route` with the given HTTP `path`,\n   * and an array of `callbacks` and `options`.\n   *\n   * Options:\n   *\n   *   - `sensitive`    enable case-sensitive routes\n   *   - `strict`       enable strict matching for trailing slashes\n   *\n   * @param {String} path\n   * @param {Object} options.\n   * @api private\n   */\n\n  function Route(path, options) {\n    options = options || {};\n    this.path = (path === '*') ? '(.*)' : path;\n    this.method = 'GET';\n    this.regexp = pathtoRegexp(this.path,\n      this.keys = [],\n      options.sensitive,\n      options.strict);\n  }\n\n  /**\n   * Expose `Route`.\n   */\n\n  page.Route = Route;\n\n  /**\n   * Return route middleware with\n   * the given callback `fn()`.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   * @api public\n   */\n\n  Route.prototype.middleware = function(fn) {\n    var self = this;\n    return function(ctx, next) {\n      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);\n      next();\n    };\n  };\n\n  /**\n   * Check if this route matches `path`, if so\n   * populate `params`.\n   *\n   * @param {String} path\n   * @param {Object} params\n   * @return {Boolean}\n   * @api private\n   */\n\n  Route.prototype.match = function(path, params) {\n    var keys = this.keys,\n      qsIndex = path.indexOf('?'),\n      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,\n      m = this.regexp.exec(decodeURIComponent(pathname));\n\n    if (!m) return false;\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = keys[i - 1];\n      var val = decodeURLEncodedURIComponent(m[i]);\n      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  };\n\n\n  /**\n   * Handle \"populate\" events.\n   */\n\n  var onpopstate = (function () {\n    var loaded = false;\n    if ('undefined' === typeof window) {\n      return;\n    }\n    if (document.readyState === 'complete') {\n      loaded = true;\n    } else {\n      window.addEventListener('load', function() {\n        setTimeout(function() {\n          loaded = true;\n        }, 0);\n      });\n    }\n    return function onpopstate(e) {\n      if (!loaded) return;\n      if (e.state) {\n        var path = e.state.path;\n        page.replace(path, e.state);\n      } else {\n        page.show(location.pathname + location.hash, undefined, undefined, false);\n      }\n    };\n  })();\n  /**\n   * Handle \"click\" events.\n   */\n\n  function onclick(e) {\n\n    if (1 !== which(e)) return;\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) return;\n    if (e.defaultPrevented) return;\n\n\n\n    // ensure link\n    // use shadow dom when available\n    var el = e.path ? e.path[0] : e.target;\n    while (el && 'A' !== el.nodeName) el = el.parentNode;\n    if (!el || 'A' !== el.nodeName) return;\n\n\n\n    // Ignore if tag has\n    // 1. \"download\" attribute\n    // 2. rel=\"external\" attribute\n    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;\n\n    // ensure non-hash for the same path\n    var link = el.getAttribute('href');\n    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;\n\n\n\n    // Check for mailto: in the href\n    if (link && link.indexOf('mailto:') > -1) return;\n\n    // check target\n    if (el.target) return;\n\n    // x-origin\n    if (!sameOrigin(el.href)) return;\n\n\n\n    // rebuild path\n    var path = el.pathname + el.search + (el.hash || '');\n\n    // strip leading \"/[drive letter]:\" on NW.js on Windows\n    if (typeof process !== 'undefined' && path.match(/^\\/[a-zA-Z]:\\//)) {\n      path = path.replace(/^\\/[a-zA-Z]:\\//, '/');\n    }\n\n    // same page\n    var orig = path;\n\n    if (path.indexOf(base) === 0) {\n      path = path.substr(base.length);\n    }\n\n    if (hashbang) path = path.replace('#!', '');\n\n    if (base && orig === path) return;\n\n    e.preventDefault();\n    page.show(orig);\n  }\n\n  /**\n   * Event button.\n   */\n\n  function which(e) {\n    e = e || window.event;\n    return null === e.which ? e.button : e.which;\n  }\n\n  /**\n   * Check if `href` is the same origin.\n   */\n\n  function sameOrigin(href) {\n    var origin = location.protocol + '//' + location.hostname;\n    if (location.port) origin += ':' + location.port;\n    return (href && (0 === href.indexOf(origin)));\n  }\n\n  page.sameOrigin = sameOrigin;\n\n}).call(this,require('_process'))\n},{\"_process\":2,\"path-to-regexp\":3}],2:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}],3:[function(require,module,exports){\nvar isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n\n},{\"isarray\":4}],4:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}]},{},[1])(1)\n});\n",
"static/login.html": "<!doctype html>\n<html>\n\t<head>\n\t\t<title>pilot</title>\n\t</head>\n\t<body>\n\t\t<form action=\"/login\" method=\"post\">\n      <input id=\"password\" type=\"password\" name=\"password\" placeholder=\"password\">\n      <button type=\"submit\">Login</button>\n    </form>\n\t</body>\n</html>",
}
